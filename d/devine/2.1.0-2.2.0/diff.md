# Comparing `tmp/devine-2.1.0-py3-none-any.whl.zip` & `tmp/devine-2.2.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,13 +1,13 @@
-Zip file size: 133597 bytes, number of entries: 63
+Zip file size: 134382 bytes, number of entries: 63
 -rw-r--r--  2.0 unx       80 b- defN 80-Jan-01 00:00 devine/__main__.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 devine/commands/__init__.py
 -rw-r--r--  2.0 unx     9622 b- defN 80-Jan-01 00:00 devine/commands/auth.py
 -rw-r--r--  2.0 unx     3254 b- defN 80-Jan-01 00:00 devine/commands/cfg.py
--rw-r--r--  2.0 unx    45258 b- defN 80-Jan-01 00:00 devine/commands/dl.py
+-rw-r--r--  2.0 unx    47586 b- defN 80-Jan-01 00:00 devine/commands/dl.py
 -rw-r--r--  2.0 unx     2247 b- defN 80-Jan-01 00:00 devine/commands/env.py
 -rw-r--r--  2.0 unx     7986 b- defN 80-Jan-01 00:00 devine/commands/kv.py
 -rw-r--r--  2.0 unx     1743 b- defN 80-Jan-01 00:00 devine/commands/serve.py
 -rw-r--r--  2.0 unx     9243 b- defN 80-Jan-01 00:00 devine/commands/util.py
 -rw-r--r--  2.0 unx     9325 b- defN 80-Jan-01 00:00 devine/commands/wvd.py
 -rw-r--r--  2.0 unx       22 b- defN 80-Jan-01 00:00 devine/core/__init__.py
 -rw-r--r--  2.0 unx     2865 b- defN 80-Jan-01 00:00 devine/core/__main__.py
@@ -18,18 +18,18 @@
 -rw-r--r--  2.0 unx     1434 b- defN 80-Jan-01 00:00 devine/core/constants.py
 -rw-r--r--  2.0 unx     3380 b- defN 80-Jan-01 00:00 devine/core/credential.py
 -rw-r--r--  2.0 unx       79 b- defN 80-Jan-01 00:00 devine/core/downloaders/__init__.py
 -rw-r--r--  2.0 unx     6571 b- defN 80-Jan-01 00:00 devine/core/downloaders/aria2c.py
 -rw-r--r--  2.0 unx     1263 b- defN 80-Jan-01 00:00 devine/core/downloaders/saldl.py
 -rw-r--r--  2.0 unx      193 b- defN 80-Jan-01 00:00 devine/core/drm/__init__.py
 -rw-r--r--  2.0 unx     3457 b- defN 80-Jan-01 00:00 devine/core/drm/clearkey.py
--rw-r--r--  2.0 unx    11502 b- defN 80-Jan-01 00:00 devine/core/drm/widevine.py
+-rw-r--r--  2.0 unx    11761 b- defN 80-Jan-01 00:00 devine/core/drm/widevine.py
 -rw-r--r--  2.0 unx       67 b- defN 80-Jan-01 00:00 devine/core/manifests/__init__.py
--rw-r--r--  2.0 unx    29280 b- defN 80-Jan-01 00:00 devine/core/manifests/dash.py
--rw-r--r--  2.0 unx    20236 b- defN 80-Jan-01 00:00 devine/core/manifests/hls.py
+-rw-r--r--  2.0 unx    29526 b- defN 80-Jan-01 00:00 devine/core/manifests/dash.py
+-rw-r--r--  2.0 unx    20243 b- defN 80-Jan-01 00:00 devine/core/manifests/hls.py
 -rw-r--r--  2.0 unx      111 b- defN 80-Jan-01 00:00 devine/core/proxies/__init__.py
 -rw-r--r--  2.0 unx      929 b- defN 80-Jan-01 00:00 devine/core/proxies/basic.py
 -rw-r--r--  2.0 unx     2290 b- defN 80-Jan-01 00:00 devine/core/proxies/hola.py
 -rw-r--r--  2.0 unx     5565 b- defN 80-Jan-01 00:00 devine/core/proxies/nordvpn.py
 -rw-r--r--  2.0 unx     1048 b- defN 80-Jan-01 00:00 devine/core/proxies/proxy.py
 -rw-r--r--  2.0 unx    10763 b- defN 80-Jan-01 00:00 devine/core/service.py
 -rw-r--r--  2.0 unx     2606 b- defN 80-Jan-01 00:00 devine/core/services.py
@@ -37,29 +37,29 @@
 -rw-r--r--  2.0 unx     7998 b- defN 80-Jan-01 00:00 devine/core/titles/episode.py
 -rw-r--r--  2.0 unx     5534 b- defN 80-Jan-01 00:00 devine/core/titles/movie.py
 -rw-r--r--  2.0 unx     4685 b- defN 80-Jan-01 00:00 devine/core/titles/song.py
 -rw-r--r--  2.0 unx     2593 b- defN 80-Jan-01 00:00 devine/core/titles/title.py
 -rw-r--r--  2.0 unx      222 b- defN 80-Jan-01 00:00 devine/core/tracks/__init__.py
 -rw-r--r--  2.0 unx     4865 b- defN 80-Jan-01 00:00 devine/core/tracks/audio.py
 -rw-r--r--  2.0 unx     3069 b- defN 80-Jan-01 00:00 devine/core/tracks/chapter.py
--rw-r--r--  2.0 unx    17699 b- defN 80-Jan-01 00:00 devine/core/tracks/subtitle.py
--rw-r--r--  2.0 unx    11257 b- defN 80-Jan-01 00:00 devine/core/tracks/track.py
--rw-r--r--  2.0 unx    16711 b- defN 80-Jan-01 00:00 devine/core/tracks/tracks.py
--rw-r--r--  2.0 unx    12662 b- defN 80-Jan-01 00:00 devine/core/tracks/video.py
--rw-r--r--  2.0 unx     8411 b- defN 80-Jan-01 00:00 devine/core/utilities.py
+-rw-r--r--  2.0 unx    17815 b- defN 80-Jan-01 00:00 devine/core/tracks/subtitle.py
+-rw-r--r--  2.0 unx    11630 b- defN 80-Jan-01 00:00 devine/core/tracks/track.py
+-rw-r--r--  2.0 unx    16817 b- defN 80-Jan-01 00:00 devine/core/tracks/tracks.py
+-rw-r--r--  2.0 unx    12569 b- defN 80-Jan-01 00:00 devine/core/tracks/video.py
+-rw-r--r--  2.0 unx     8732 b- defN 80-Jan-01 00:00 devine/core/utilities.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 devine/core/utils/__init__.py
--rw-r--r--  2.0 unx     4232 b- defN 80-Jan-01 00:00 devine/core/utils/click_types.py
+-rw-r--r--  2.0 unx     4613 b- defN 80-Jan-01 00:00 devine/core/utils/click_types.py
 -rw-r--r--  2.0 unx     1532 b- defN 80-Jan-01 00:00 devine/core/utils/collections.py
 -rw-r--r--  2.0 unx     3699 b- defN 80-Jan-01 00:00 devine/core/utils/sslciphers.py
 -rw-r--r--  2.0 unx      845 b- defN 80-Jan-01 00:00 devine/core/utils/subprocess.py
 -rw-r--r--  2.0 unx      791 b- defN 80-Jan-01 00:00 devine/core/utils/xml.py
 -rw-r--r--  2.0 unx     1709 b- defN 80-Jan-01 00:00 devine/core/vault.py
 -rw-r--r--  2.0 unx     2516 b- defN 80-Jan-01 00:00 devine/core/vaults.py
 -rw-r--r--  2.0 unx     8485 b- defN 80-Jan-01 00:00 devine/vaults/MySQL.py
 -rw-r--r--  2.0 unx     6076 b- defN 80-Jan-01 00:00 devine/vaults/SQLite.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 devine/vaults/__init__.py
--rw-r--r--  2.0 unx    35821 b- defN 80-Jan-01 00:00 devine-2.1.0.dist-info/LICENSE
--rw-r--r--  2.0 unx       52 b- defN 80-Jan-01 00:00 devine-2.1.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 devine-2.1.0.dist-info/WHEEL
--rw-r--r--  2.0 unx    19241 b- defN 80-Jan-01 00:00 devine-2.1.0.dist-info/METADATA
-?rw-r--r--  2.0 unx     5194 b- defN 16-Jan-01 00:00 devine-2.1.0.dist-info/RECORD
-63 files, 404829 bytes uncompressed, 125441 bytes compressed:  69.0%
+-rw-r--r--  2.0 unx    35821 b- defN 80-Jan-01 00:00 devine-2.2.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 devine-2.2.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       52 b- defN 80-Jan-01 00:00 devine-2.2.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx    19252 b- defN 80-Jan-01 00:00 devine-2.2.0.dist-info/METADATA
+?rw-r--r--  2.0 unx     5194 b- defN 16-Jan-01 00:00 devine-2.2.0.dist-info/RECORD
+63 files, 408884 bytes uncompressed, 126226 bytes compressed:  69.1%
```

## zipnote {}

```diff
@@ -168,23 +168,23 @@
 
 Filename: devine/vaults/SQLite.py
 Comment: 
 
 Filename: devine/vaults/__init__.py
 Comment: 
 
-Filename: devine-2.1.0.dist-info/LICENSE
+Filename: devine-2.2.0.dist-info/LICENSE
 Comment: 
 
-Filename: devine-2.1.0.dist-info/entry_points.txt
+Filename: devine-2.2.0.dist-info/WHEEL
 Comment: 
 
-Filename: devine-2.1.0.dist-info/WHEEL
+Filename: devine-2.2.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: devine-2.1.0.dist-info/METADATA
+Filename: devine-2.2.0.dist-info/METADATA
 Comment: 
 
-Filename: devine-2.1.0.dist-info/RECORD
+Filename: devine-2.2.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## devine/commands/dl.py

```diff
@@ -11,14 +11,15 @@
 import sys
 import time
 from concurrent import futures
 from concurrent.futures import ThreadPoolExecutor
 from copy import deepcopy
 from functools import partial
 from http.cookiejar import MozillaCookieJar
+from itertools import zip_longest
 from pathlib import Path
 from threading import Event, Lock
 from typing import Any, Callable, Optional
 from uuid import UUID
 
 import click
 import jsonpickle
@@ -48,15 +49,15 @@
 from devine.core.proxies import Basic, Hola, NordVPN
 from devine.core.service import Service
 from devine.core.services import Services
 from devine.core.titles import Movie, Song, Title_T
 from devine.core.titles.episode import Episode
 from devine.core.tracks import Audio, Subtitle, Video
 from devine.core.utilities import get_binary_path, is_close_match, time_elapsed_since
-from devine.core.utils.click_types import LANGUAGE_RANGE, QUALITY, SEASON_RANGE, ContextData
+from devine.core.utils.click_types import LANGUAGE_RANGE, SEASON_RANGE, ContextData, QUALITY_LIST
 from devine.core.utils.collections import merge_dict
 from devine.core.utils.subprocess import ffprobe
 from devine.core.vaults import Vaults
 
 
 class dl:
     @click.group(
@@ -65,16 +66,16 @@
         context_settings=dict(
             **context_settings,
             default_map=config.dl,
             token_normalize_func=Services.get_tag
         ))
     @click.option("-p", "--profile", type=str, default=None,
                   help="Profile to use for Credentials and Cookies (if available). Overrides profile set by config.")
-    @click.option("-q", "--quality", type=QUALITY, default=None,
-                  help="Download Resolution, defaults to best available.")
+    @click.option("-q", "--quality", type=QUALITY_LIST, default=[],
+                  help="Download Resolution(s), defaults to the best available resolution.")
     @click.option("-v", "--vcodec", type=click.Choice(Video.Codec, case_sensitive=False),
                   default=Video.Codec.AVC,
                   help="Video Codec to download, defaults to H.264.")
     @click.option("-a", "--acodec", type=click.Choice(Audio.Codec, case_sensitive=False),
                   default=None,
                   help="Audio Codec to download, defaults to any codec.")
     @click.option("-vb", "--vbitrate", type=int,
@@ -242,15 +243,15 @@
         # needs to be added this way instead of @cli.result_callback to be
         # able to keep `self` as the first positional
         self.cli._result_callback = self.result
 
     def result(
         self,
         service: Service,
-        quality: Optional[int],
+        quality: list[int],
         vcodec: Video.Codec,
         acodec: Optional[Audio.Codec],
         vbitrate: int,
         abitrate: int,
         range_: Video.Range,
         channels: float,
         wanted: list[str],
@@ -352,32 +353,55 @@
                 ))
                 continue
 
             with console.status("Selecting tracks...", spinner="dots"):
                 if isinstance(title, (Movie, Episode)):
                     # filter video tracks
                     title.tracks.select_video(lambda x: x.codec == vcodec)
+                    if not title.tracks.videos:
+                        self.log.error(f"There's no {vcodec.name} Video Track...")
+                        sys.exit(1)
+
                     title.tracks.select_video(lambda x: x.range == range_)
+                    if not title.tracks.videos:
+                        self.log.error(f"There's no {range_.name} Video Track...")
+                        sys.exit(1)
+
                     if vbitrate:
                         title.tracks.select_video(lambda x: x.bitrate and x.bitrate // 1000 == vbitrate)
                         if not title.tracks.videos:
                             self.log.error(f"There's no {vbitrate}kbps Video Track...")
                             sys.exit(1)
-                    if quality:
-                        title.tracks.with_resolution(quality)
-                    if not title.tracks.videos:
-                        self.log.error(f"There's no {quality}p {vcodec.name} ({range_.name}) Video Track...")
-                        sys.exit(1)
 
-                    video_language = v_lang or lang
-                    if video_language and "all" not in video_language:
-                        title.tracks.videos = title.tracks.select_per_language(title.tracks.videos, video_language)
+                    video_languages = v_lang or lang
+                    if video_languages and "all" not in video_languages:
+                        title.tracks.videos = title.tracks.by_language(title.tracks.videos, video_languages)
                         if not title.tracks.videos:
-                            self.log.error(f"There's no {video_language} Video Track...")
+                            self.log.error(f"There's no {video_languages} Video Track...")
+                            sys.exit(1)
+
+                    if quality:
+                        title.tracks.by_resolutions(quality, per_resolution=1)
+                        missing_resolutions = []
+                        for resolution in quality:
+                            if any(video.height == resolution for video in title.tracks.videos):
+                                continue
+                            if any(int(video.width * (9 / 16)) == resolution for video in title.tracks.videos):
+                                continue
+                            missing_resolutions.append(resolution)
+                        if missing_resolutions:
+                            res_list = ""
+                            if len(missing_resolutions) > 1:
+                                res_list = (", ".join([f"{x}p" for x in missing_resolutions[:-1]])) + " or "
+                            res_list = f"{res_list}{missing_resolutions[-1]}p"
+                            plural = "s" if len(missing_resolutions) > 1 else ""
+                            self.log.error(f"There's no {res_list} Video Track{plural}...")
                             sys.exit(1)
+                    else:
+                        title.tracks.videos = [title.tracks.videos[0]]
 
                     # filter subtitle tracks
                     if s_lang and "all" not in s_lang:
                         title.tracks.select_subtitles(lambda x: is_close_match(x.language, s_lang))
                         if not title.tracks.subtitles:
                             self.log.error(f"There's no {s_lang} Subtitle Track...")
                             sys.exit(1)
@@ -398,15 +422,15 @@
                         sys.exit(1)
                 if channels:
                     title.tracks.select_audio(lambda x: math.ceil(x.channels) == math.ceil(channels))
                     if not title.tracks.audio:
                         self.log.error(f"There's no {channels} Audio Track...")
                         sys.exit(1)
                 if lang and "all" not in lang:
-                    title.tracks.audio = title.tracks.select_per_language(title.tracks.audio, lang)
+                    title.tracks.audio = title.tracks.by_language(title.tracks.audio, lang, per_language=1)
                     if not title.tracks.audio:
                         if all(x.descriptor == Video.Descriptor.M3U for x in title.tracks.videos):
                             self.log.warning(f"There's no {lang} Audio Tracks, "
                                              f"likely part of an invariant playlist, continuing...")
                         else:
                             self.log.error(f"There's no {lang} Audio Track, cannot continue...")
                             sys.exit(1)
@@ -499,14 +523,20 @@
                         console.print_exception()
                     console.print(Padding(
                         Group(*error_messages),
                         (1, 5)
                     ))
                     return
 
+                dl_time = time_elapsed_since(dl_start_time)
+                console.print(Padding(
+                    f"Track downloads finished in [progress.elapsed]{dl_time}[/]",
+                    (0, 5)
+                ))
+
                 video_track_n = 0
 
                 while (
                     not title.tracks.subtitles and
                     len(title.tracks.videos) > video_track_n and
                     any(
                         x.get("codec_name", "").startswith("eia_")
@@ -565,23 +595,77 @@
                             has_repacked = True
                             if callable(track.OnRepacked):
                                 track.OnRepacked(track)
                     if has_repacked:
                         # we don't want to fill up the log with "Repacked x track"
                         self.log.info("Repacked one or more tracks with FFMPEG")
 
-                final_path = self.mux_tracks(title, not no_folder, not no_source)
+                muxed_paths = []
 
-                title_dl_time = time_elapsed_since(dl_start_time)
+                if isinstance(title, (Movie, Episode)):
+                    progress = Progress(
+                        TextColumn("[progress.description]{task.description}"),
+                        SpinnerColumn(finished_text=""),
+                        BarColumn(),
+                        "•",
+                        TimeRemainingColumn(compact=True, elapsed_when_finished=True),
+                        console=console
+                    )
+                    multi_jobs = len(title.tracks.videos) > 1
+                    tasks = [
+                        progress.add_task(
+                            f"Multiplexing{f' {x.height}p' if multi_jobs else ''}...",
+                            total=None,
+                            start=False
+                        )
+                        for x in title.tracks.videos or [None]
+                    ]
+                    with Live(
+                        Padding(progress, (0, 5, 1, 5)),
+                        console=console
+                    ):
+                        for task, video_track in zip_longest(tasks, title.tracks.videos, fillvalue=None):
+                            if video_track:
+                                title.tracks.videos = [video_track]
+                            progress.start_task(task)  # TODO: Needed?
+                            muxed_path, return_code = title.tracks.mux(
+                                str(title),
+                                progress=partial(progress.update, task_id=task),
+                                delete=False
+                            )
+                            muxed_paths.append(muxed_path)
+                            if return_code == 1:
+                                self.log.warning("mkvmerge had at least one warning, will continue anyway...")
+                            elif return_code >= 2:
+                                self.log.error(f"Failed to Mux video to Matroska file ({return_code})")
+                                sys.exit(1)
+                            if video_track:
+                                video_track.delete()
+                        for track in title.tracks:
+                            track.delete()
+                else:
+                    # dont mux
+                    muxed_paths.append(title.tracks.audio[0].path)
+
+                for muxed_path in muxed_paths:
+                    media_info = MediaInfo.parse(muxed_path)
+                    final_dir = config.directories.downloads
+                    final_filename = title.get_filename(media_info, show_service=not no_source)
+
+                    if not no_folder and isinstance(title, (Episode, Song)):
+                        final_dir /= title.get_filename(media_info, show_service=not no_source, folder=True)
 
-                downloaded_table = Table.grid(expand=True)
-                downloaded_table.add_row(f" :tada: Download Finished in [progress.elapsed]{title_dl_time}[/]!")
-                downloaded_table.add_row(Text(str(final_path), overflow="fold"))
+                    final_dir.mkdir(parents=True, exist_ok=True)
+                    final_path = final_dir / f"{final_filename}{muxed_path.suffix}"
+
+                    shutil.move(muxed_path, final_path)
+
+                title_dl_time = time_elapsed_since(dl_start_time)
                 console.print(Padding(
-                    downloaded_table,
+                    f":tada: Title downloaded in [progress.elapsed]{title_dl_time}[/]!",
                     (0, 5, 1, 5)
                 ))
 
             # update cookies
             cookie_file = config.directories.cookies / service.__class__.__name__ / f"{self.profile}.txt"
             if cookie_file.exists():
                 cookie_jar = MozillaCookieJar(cookie_file)
@@ -639,15 +723,15 @@
                     is_track_kid = ["", "*"][kid == track_kid]
 
                     if not cdm_only:
                         content_key, vault_used = self.vaults.get_key(kid)
                         if content_key:
                             drm.content_keys[kid] = content_key
                             label = f"[text2]{kid.hex}:{content_key}{is_track_kid} from {vault_used}"
-                            if not any(x.label == label for x in cek_tree.children):
+                            if not any(f"{kid.hex}:{content_key}" in x.label for x in cek_tree.children):
                                 cek_tree.add(label)
                             self.vaults.add_key(kid, content_key, excluding=vault_used)
                         elif vaults_only:
                             msg = f"No Vault has a Key for {kid.hex} and --vaults-only was used"
                             cek_tree.add(f"[logging.level.error]{msg}")
                             if not pre_existing_tree:
                                 table.add_row(cek_tree)
@@ -672,15 +756,15 @@
                                 table.add_row(cek_tree)
                             raise e
 
                         for kid_, key in drm.content_keys.items():
                             if key == "0" * 32:
                                 key = f"[red]{key}[/]"
                             label = f"[text2]{kid_.hex}:{key}{is_track_kid}"
-                            if not any(x.label == label for x in cek_tree.children):
+                            if not any(f"{kid_.hex}:{key}" in x.label for x in cek_tree.children):
                                 cek_tree.add(label)
 
                         drm.content_keys = {
                             kid_: key
                             for kid_, key in drm.content_keys.items()
                             if key and key.count("0") != len(key)
                         }
@@ -849,60 +933,14 @@
                     if not track.needs_proxy else ""
                 )
             )
 
         if callable(track.OnDownloaded):
             track.OnDownloaded(track)
 
-    def mux_tracks(self, title: Title_T, season_folder: bool = True, add_source: bool = True) -> Path:
-        """Mux Tracks, Delete Pre-Mux files, and move to the final location."""
-        if isinstance(title, (Movie, Episode)):
-            multiplexing_progress = Progress(
-                TextColumn("[progress.description]{task.description}"),
-                SpinnerColumn(finished_text=""),
-                BarColumn(),
-                "•",
-                TimeRemainingColumn(compact=True, elapsed_when_finished=True),
-                console=console
-            )
-            with Live(
-                Padding(multiplexing_progress, (0, 5, 1, 5)),
-                console=console
-            ):
-                task = multiplexing_progress.add_task("Multiplexing...", total=100)
-                muxed_path, return_code = title.tracks.mux(
-                    str(title),
-                    progress=partial(
-                        multiplexing_progress.update,
-                        task_id=task
-                    )
-                )
-                if return_code == 1:
-                    self.log.warning("mkvmerge had at least one warning, will continue anyway...")
-                elif return_code >= 2:
-                    self.log.error(f"Failed to Mux video to Matroska file ({return_code})")
-                    sys.exit(1)
-        else:
-            # dont mux
-            muxed_path = title.tracks.audio[0].path
-
-        media_info = MediaInfo.parse(muxed_path)
-        final_dir = config.directories.downloads
-        final_filename = title.get_filename(media_info, show_service=add_source)
-
-        if season_folder and isinstance(title, (Episode, Song)):
-            final_dir /= title.get_filename(media_info, show_service=add_source, folder=True)
-
-        final_dir.mkdir(parents=True, exist_ok=True)
-        final_path = final_dir / f"{final_filename}{muxed_path.suffix}"
-
-        shutil.move(muxed_path, final_path)
-
-        return final_path
-
     @staticmethod
     def get_profile(service: str) -> Optional[str]:
         """Get profile for Service from config."""
         profile = config.profiles.get(service)
         if profile is False:
             return None  # auth-less service if `false` in config
         if not profile:
```

## devine/core/drm/widevine.py

```diff
@@ -254,19 +254,24 @@
             p = subprocess.Popen(
                 [executable, *arguments],
                 stdout=subprocess.DEVNULL,
                 stderr=subprocess.PIPE,
                 universal_newlines=True
             )
 
+            stream_skipped = False
+
             shaka_log_buffer = ""
             for line in iter(p.stderr.readline, ""):
                 line = line.strip()
                 if not line:
                     continue
+                if "Skip stream" in line:
+                    # file/segment was so small that it didn't have any actual data, ignore
+                    stream_skipped = True
                 if ":INFO:" in line:
                     continue
                 if "Insufficient bits in bitstream for given AVC profile" in line:
                     # this is a warning and is something we don't have to worry about
                     continue
                 shaka_log_buffer += f"{line.strip()}\n"
 
@@ -279,22 +284,23 @@
                 ))
                 console.log(Text.from_ansi("\n[Widevine]: " + shaka_log_buffer))
 
             p.wait()
 
             if p.returncode != 0:
                 raise subprocess.CalledProcessError(p.returncode, arguments)
+
+            path.unlink()
+            if not stream_skipped:
+                shutil.move(decrypted_path, path)
         except subprocess.CalledProcessError as e:
             if e.returncode == 0xC000013A:  # STATUS_CONTROL_C_EXIT
                 raise KeyboardInterrupt()
             raise
 
-        path.unlink()
-        shutil.move(decrypted_path, path)
-
     class Exceptions:
         class PSSHNotFound(Exception):
             """PSSH (Protection System Specific Header) was not found."""
 
         class KIDNotFound(Exception):
             """KID (Encryption Key ID) was not found."""
```

## devine/core/manifests/dash.py

```diff
@@ -406,20 +406,25 @@
                                 RepresentationID=representation.get("id"),
                                 Time=s
                             ), None
                         ))
             elif segment_list is not None:
                 init_data = None
                 initialization = segment_list.find("Initialization")
-                if initialization:
+                if initialization is not None:
                     source_url = initialization.get("sourceURL")
                     if source_url is None:
                         source_url = rep_base_url
 
-                    res = session.get(source_url)
+                    if initialization.get("range"):
+                        headers = {"Range": f"bytes={initialization.get('range')}"}
+                    else:
+                        headers = None
+
+                    res = session.get(url=source_url, headers=headers)
                     res.raise_for_status()
                     init_data = res.content
                     track_kid = track.get_key_id(init_data)
 
                 segment_urls = segment_list.findall("SegmentURL")
                 for segment_url in segment_urls:
                     media_url = segment_url.get("media")
@@ -464,21 +469,21 @@
                 segment_uri, segment_range = segment
 
                 attempts = 1
                 while True:
                     try:
                         if segment_range:
                             # aria2(c) doesn't support byte ranges, let's use python-requests (likely slower)
-                            r = session.get(
+                            res = session.get(
                                 url=segment_uri,
                                 headers={
                                     "Range": f"bytes={segment_range}"
                                 }
                             )
-                            r.raise_for_status()
+                            res.raise_for_status()
                             segment_save_path.parent.mkdir(parents=True, exist_ok=True)
                             segment_save_path.write_bytes(res.content)
                         else:
                             asyncio.run(aria2c(
                                 uri=segment_uri,
                                 out=segment_save_path,
                                 headers=session.headers,
@@ -564,15 +569,15 @@
                         time_since = now - last_speed_refresh
 
                         if download_size:  # no size == skipped dl
                             download_sizes.append(download_size)
 
                         if download_sizes and (time_since > 5 or finished_threads == len(segments)):
                             data_size = sum(download_sizes)
-                            download_speed = data_size / time_since
+                            download_speed = data_size / (time_since or 1)
                             progress(downloaded=f"DASH {filesize.decimal(download_speed)}/s")
                             last_speed_refresh = now
                             download_sizes.clear()
 
             with open(save_path, "wb") as f:
                 for segment_file in sorted(save_dir.iterdir()):
                     f.write(segment_file.read_bytes())
```

## devine/core/manifests/hls.py

```diff
@@ -409,15 +409,15 @@
                     time_since = now - last_speed_refresh
 
                     if download_size:  # no size == skipped dl
                         download_sizes.append(download_size)
 
                     if download_sizes and (time_since > 5 or finished_threads == len(master.segments)):
                         data_size = sum(download_sizes)
-                        download_speed = data_size / time_since
+                        download_speed = data_size / (time_since or 1)
                         progress(downloaded=f"HLS {filesize.decimal(download_speed)}/s")
                         last_speed_refresh = now
                         download_sizes.clear()
 
         with open(save_path, "wb") as f:
             for segment_file in sorted(save_dir.iterdir()):
                 f.write(segment_file.read_bytes())
```

## devine/core/tracks/subtitle.py

```diff
@@ -1,9 +1,10 @@
 from __future__ import annotations
 
+import re
 import subprocess
 from collections import defaultdict
 from enum import Enum
 from io import BytesIO
 from typing import Any, Iterable, Optional
 
 import pycaption
@@ -157,14 +158,16 @@
                 ):
                     for lang in segment.get_languages():
                         captions[lang].extend(segment.get_captions(lang))
                 captions: pycaption.CaptionSet = pycaption.CaptionSet(captions)
                 return captions
             if codec == Subtitle.Codec.TimedTextMarkupLang:
                 text = data.decode("utf8").replace("tt:", "")
+                # negative size values aren't allowed in TTML/DFXP spec, replace with 0
+                text = re.sub(r'"(-\d+(\.\d+)?(px|em|%|c|pt))"', '"0"', text)
                 return pycaption.DFXPReader().read(text)
             if codec == Subtitle.Codec.fVTT:
                 caption_lists: dict[str, pycaption.CaptionList] = defaultdict(pycaption.CaptionList)
                 caption_list, language = Subtitle.merge_segmented_wvtt(data)
                 caption_lists[language] = caption_list
                 caption_set: pycaption.CaptionSet = pycaption.CaptionSet(caption_lists)
                 return caption_set
@@ -174,16 +177,16 @@
                 text = data.decode("utf8"). \
                     replace("WEBVTT", "\n\nWEBVTT"). \
                     replace("\r", ""). \
                     replace("\n\n\n", "\n \n\n"). \
                     replace("\n\n<", "\n<")
                 captions: pycaption.CaptionSet = pycaption.WebVTTReader().read(text)
                 return captions
-        except pycaption.exceptions.CaptionReadSyntaxError:
-            raise SyntaxError(f"A syntax error has occurred when reading the \"{codec}\" subtitle")
+        except pycaption.exceptions.CaptionReadSyntaxError as e:
+            raise SyntaxError(f"A syntax error has occurred when reading the \"{codec}\" subtitle: {e}")
         except pycaption.exceptions.CaptionReadNoCaptions:
             return pycaption.CaptionSet({"en": []})
 
         raise ValueError(f"Unknown Subtitle Format \"{codec}\"...")
 
     @staticmethod
     def merge_same_cues(caption_set: pycaption.CaptionSet):
@@ -308,25 +311,24 @@
                     if vttc_box.type == b"vtte":
                         # vtte is a vttc that's empty, skip
                         continue
 
                     layout: Optional[Layout] = None
                     nodes: list[CaptionNode] = []
 
-                    for cue_box in MP4.parse_stream(BytesIO(vttc_box.data)):
+                    for cue_box in vttc_box.children:
                         if cue_box.type == b"vsid":
                             # this is a V(?) Source ID box, we don't care
                             continue
-                        cue_data = cue_box.data.decode("utf8")
                         if cue_box.type == b"sttg":
-                            layout = Layout(webvtt_positioning=cue_data)
+                            layout = Layout(webvtt_positioning=cue_box.settings)
                         elif cue_box.type == b"payl":
                             nodes.extend([
                                 node
-                                for line in cue_data.split("\n")
+                                for line in cue_box.cue_text.split("\n")
                                 for node in [
                                     CaptionNode.create_text(WebVTTReader()._decode(line)),
                                     CaptionNode.create_break()
                                 ]
                             ])
                             nodes.pop()
```

## devine/core/tracks/track.py

```diff
@@ -117,17 +117,24 @@
             for stream in probe.get("streams") or []:
                 enc_key_id = stream.get("tags", {}).get("enc_key_id")
                 if enc_key_id:
                     return UUID(bytes=base64.b64decode(enc_key_id))
 
         # look for track encryption mp4 boxes
         for tenc in get_boxes(init_data, b"tenc"):
-            if tenc.key_ID.int != 0:
+            if tenc.version <= 1 and tenc.key_ID.int != 0:
                 return tenc.key_ID
 
+        # look for UUID mp4 boxes holding track encryption mp4 boxes
+        for uuid_box in get_boxes(init_data, b"uuid"):
+            if uuid_box.extended_type == UUID("8974dbce-7be7-4c51-84f9-7148f9882554"):
+                tenc = uuid_box.data
+                if tenc.version <= 1 and tenc.key_ID.int != 0:
+                    return tenc.key_ID
+
     def get_init_segment(
         self,
         maximum_size: int = 20000,
         url: Optional[str] = None,
         byte_range: Optional[str] = None,
         session: Optional[requests.Session] = None
     ) -> bytes:
```

## devine/core/tracks/tracks.py

```diff
@@ -255,46 +255,54 @@
 
     def select_audio(self, x: Callable[[Audio], bool]) -> None:
         self.audio = list(filter(x, self.audio))
 
     def select_subtitles(self, x: Callable[[Subtitle], bool]) -> None:
         self.subtitles = list(filter(x, self.subtitles))
 
-    def with_resolution(self, resolution: int) -> None:
-        if resolution:
-            # Note: Do not merge these list comprehensions. They must be done separately so the results
-            # from the 16:9 canvas check is only used if there's no exact height resolution match.
-            videos_quality = [x for x in self.videos if x.height == resolution]
-            if not videos_quality:
-                videos_quality = [x for x in self.videos if int(x.width * (9 / 16)) == resolution]
-            self.videos = videos_quality
+    def by_resolutions(self, resolutions: list[int], per_resolution: int = 0) -> None:
+        # Note: Do not merge these list comprehensions. They must be done separately so the results
+        # from the 16:9 canvas check is only used if there's no exact height resolution match.
+        selected = []
+        for resolution in resolutions:
+            matches = [  # exact matches
+                x
+                for x in self.videos
+                if x.height == resolution
+            ]
+            if not matches:
+                matches = [  # 16:9 canvas matches
+                    x
+                    for x in self.videos
+                    if int(x.width * (9 / 16)) == resolution
+                ]
+            selected.extend(matches[:per_resolution or None])
+        self.videos = selected
+
+    @staticmethod
+    def by_language(tracks: list[TrackT], languages: list[str], per_language: int = 0) -> list[TrackT]:
+        selected = []
+        for language in languages:
+            selected.extend([
+                x
+                for x in tracks
+                if closest_supported_match(x.language, [language], LANGUAGE_MAX_DISTANCE)
+            ][:per_language or None])
+        return selected
 
     def export_chapters(self, to_file: Optional[Union[Path, str]] = None) -> str:
         """Export all chapters in order to a string or file."""
         self.sort_chapters()
         data = "\n".join(map(repr, self.chapters))
         if to_file:
             to_file = Path(to_file)
             to_file.parent.mkdir(parents=True, exist_ok=True)
             to_file.write_text(data, encoding="utf8")
         return data
 
-    @staticmethod
-    def select_per_language(tracks: list[TrackT], languages: list[str]) -> list[TrackT]:
-        """
-        Enumerates and return the first Track per language.
-        You should sort the list so the wanted track is closer to the start of the list.
-        """
-        tracks_ = []
-        for language in languages:
-            match = closest_supported_match(language, [str(x.language) for x in tracks], LANGUAGE_MAX_DISTANCE)
-            if match:
-                tracks_.append(next(x for x in tracks if str(x.language) == match))
-        return tracks_
-
     def mux(self, title: str, delete: bool = True, progress: Optional[partial] = None) -> tuple[Path, int]:
         """
         Multiplex all the Tracks into a Matroska Container file.
 
         Parameters:
             title: Set the Matroska Container file title. Usually displayed in players
                 instead of the filename if set.
```

## devine/core/tracks/video.py

```diff
@@ -201,33 +201,34 @@
         if not self.path:
             raise ValueError("You must download the track first.")
 
         executable = get_binary_path("ccextractor", "ccextractorwin", "ccextractorwinfull")
         if not executable:
             raise EnvironmentError("ccextractor executable was not found.")
 
+        # ccextractor often fails in weird ways unless we repack
+        self.repackage()
+
         out_path = Path(out_path)
 
         try:
             subprocess.run([
                 executable,
-                "-trim", "-noru", "-ru1",
-                self.path, "-o", out_path
+                "-trim",
+                "-nobom",
+                "-noru", "-ru1",
+                "-o", out_path,
+                self.path
             ], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         except subprocess.CalledProcessError as e:
             out_path.unlink(missing_ok=True)
             if not e.returncode == 10:  # No captions found
                 raise
 
         if out_path.exists():
-            if out_path.stat().st_size <= 3:
-                # An empty UTF-8 file with BOM is 3 bytes.
-                # If the subtitle file is empty, mkvmerge will fail to mux.
-                out_path.unlink()
-                return None
             cc_track = Subtitle(
                 id_=track_id,
                 url="",  # doesn't need to be downloaded
                 codec=Subtitle.Codec.SubRip,
                 language=language,
                 is_original_lang=original,
                 cc=True
```

## devine/core/utilities.py

```diff
@@ -12,14 +12,15 @@
 from pathlib import Path
 from types import ModuleType
 from typing import AsyncIterator, Optional, Sequence, Union
 from urllib.parse import urlparse
 
 import pproxy
 import requests
+from construct import ConstError
 from langcodes import Language, closest_match
 from pymp4.parser import Box
 from unidecode import unidecode
 
 from devine.core.config import config
 from devine.core.constants import LANGUAGE_MAX_DISTANCE
 
@@ -142,14 +143,20 @@
             index -= 4  # size is before box type and is 4 bytes long
         data = data[index:]
         try:
             box = Box.parse(data)
         except IOError:
             # TODO: Does this miss any data we may need?
             break
+        except ConstError as e:
+            if box_type == b"tenc":
+                # ignore this error on tenc boxes as the tenc definition isn't consistent
+                # some services don't even put valid data and mix it up with avc1...
+                continue
+            raise e
         if as_bytes:
             box = Box.build(box)
         yield box
 
 
 def ap_case(text: str, keep_spaces: bool = False, stop_words: tuple[str] = None) -> str:
     """
```

## devine/core/utils/click_types.py

```diff
@@ -90,26 +90,38 @@
         if isinstance(value, list):
             return value
         if not value:
             return []
         return re.split(r"\s*[,;]\s*", value)
 
 
-class Quality(click.ParamType):
-    name = "quality"
+class QualityList(click.ParamType):
+    name = "quality_list"
 
-    def convert(self, value: str, param: Optional[click.Parameter] = None, ctx: Optional[click.Context] = None) -> int:
-        try:
-            return int(value.lower().rstrip("p"))
-        except TypeError:
-            self.fail(
-                f"expected string for int() conversion, got {value!r} of type {type(value).__name__}",
-                param,
-                ctx
-            )
-        except ValueError:
-            self.fail(f"{value!r} is not a valid integer", param, ctx)
+    def convert(
+        self,
+        value: Union[str, list[str]],
+        param: Optional[click.Parameter] = None,
+        ctx: Optional[click.Context] = None
+    ) -> list[int]:
+        if not value:
+            return []
+        if not isinstance(value, list):
+            value = value.split(",")
+        resolutions = []
+        for resolution in value:
+            try:
+                resolutions.append(int(resolution.lower().rstrip("p")))
+            except TypeError:
+                self.fail(
+                    f"Expected string for int() conversion, got {resolution!r} of type {type(resolution).__name__}",
+                    param,
+                    ctx
+                )
+            except ValueError:
+                self.fail(f"{resolution!r} is not a valid integer", param, ctx)
+        return sorted(resolutions, reverse=True)
 
 
 SEASON_RANGE = SeasonRange()
 LANGUAGE_RANGE = LanguageRange()
-QUALITY = Quality()
+QUALITY_LIST = QualityList()
```

## Comparing `devine-2.1.0.dist-info/LICENSE` & `devine-2.2.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `devine-2.1.0.dist-info/METADATA` & `devine-2.2.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: devine
-Version: 2.1.0
+Version: 2.2.0
 Summary: Open-Source Movie, TV, and Music Downloading Solution
 Home-page: https://github.com/devine-dl/devine
 License: GPL-3.0-only
 Keywords: widevine,drm,downloader
 Author: rlaphoenix
 Author-email: rlaphoenix@pm.me
 Requires-Python: >=3.9.0,<3.12
@@ -32,19 +32,19 @@
 Requires-Dist: lxml (>=4.9.2,<5.0.0)
 Requires-Dist: pproxy (>=2.7.8,<3.0.0)
 Requires-Dist: protobuf (==4.21.6)
 Requires-Dist: pycaption (>=2.1.1,<3.0.0)
 Requires-Dist: pycryptodomex (>=3.17.0,<4.0.0)
 Requires-Dist: pyjwt (>=2.6.0,<3.0.0)
 Requires-Dist: pymediainfo (>=6.0.1,<7.0.0)
-Requires-Dist: pymp4 (>=1.2.0,<2.0.0)
 Requires-Dist: pymysql (>=1.0.2,<2.0.0)
 Requires-Dist: pywidevine[serve] (>=1.6.0,<2.0.0)
 Requires-Dist: requests[socks] (>=2.28.2,<3.0.0)
 Requires-Dist: rich (>=13.3.1,<14.0.0)
+Requires-Dist: rlaphoenix-pymp4 (>=1.5.0,<2.0.0)
 Requires-Dist: rlaphoenix.m3u8 (>=3.4.0,<4.0.0)
 Requires-Dist: ruamel.yaml (>=0.17.21,<0.18.0)
 Requires-Dist: sortedcontainers (>=2.4.0,<3.0.0)
 Requires-Dist: subtitle-filter (>=1.4.4,<2.0.0)
 Requires-Dist: urllib3 (>=1.26.14,<2.0.0)
 Project-URL: Repository, https://github.com/devine-dl/devine
 Description-Content-Type: text/markdown
```

### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: devine Version: 2.1.0 Summary: Open-Source Movie,
+Metadata-Version: 2.1 Name: devine Version: 2.2.0 Summary: Open-Source Movie,
 TV, and Music Downloading Solution Home-page: https://github.com/devine-dl/
 devine License: GPL-3.0-only Keywords: widevine,drm,downloader Author:
 rlaphoenix Author-email: rlaphoenix@pm.me Requires-Python: >=3.9.0,<3.12
 Classifier: Development Status :: 4 - Beta Classifier: Environment :: Console
 Classifier: Intended Audience :: End Users/Desktop Classifier: License :: OSI
 Approved :: GNU General Public License v3 (GPLv3) Classifier: Natural Language
 :: English Classifier: Operating System :: OS Independent Classifier:
@@ -14,22 +14,23 @@
 (>=1.3.6,<2.0.0) Requires-Dist: appdirs (>=1.4.4,<2.0.0) Requires-Dist: click
 (>=8.1.3,<9.0.0) Requires-Dist: construct (>=2.8.8,<3.0.0) Requires-Dist:
 crccheck (>=1.3.0,<2.0.0) Requires-Dist: jsonpickle (>=3.0.1,<4.0.0) Requires-
 Dist: langcodes[data] (>=3.3.0,<4.0.0) Requires-Dist: lxml (>=4.9.2,<5.0.0)
 Requires-Dist: pproxy (>=2.7.8,<3.0.0) Requires-Dist: protobuf (==4.21.6)
 Requires-Dist: pycaption (>=2.1.1,<3.0.0) Requires-Dist: pycryptodomex
 (>=3.17.0,<4.0.0) Requires-Dist: pyjwt (>=2.6.0,<3.0.0) Requires-Dist:
-pymediainfo (>=6.0.1,<7.0.0) Requires-Dist: pymp4 (>=1.2.0,<2.0.0) Requires-
-Dist: pymysql (>=1.0.2,<2.0.0) Requires-Dist: pywidevine[serve]
-(>=1.6.0,<2.0.0) Requires-Dist: requests[socks] (>=2.28.2,<3.0.0) Requires-
-Dist: rich (>=13.3.1,<14.0.0) Requires-Dist: rlaphoenix.m3u8 (>=3.4.0,<4.0.0)
-Requires-Dist: ruamel.yaml (>=0.17.21,<0.18.0) Requires-Dist: sortedcontainers
-(>=2.4.0,<3.0.0) Requires-Dist: subtitle-filter (>=1.4.4,<2.0.0) Requires-Dist:
-urllib3 (>=1.26.14,<2.0.0) Project-URL: Repository, https://github.com/devine-
-dl/devine Description-Content-Type: text/markdown
+pymediainfo (>=6.0.1,<7.0.0) Requires-Dist: pymysql (>=1.0.2,<2.0.0) Requires-
+Dist: pywidevine[serve] (>=1.6.0,<2.0.0) Requires-Dist: requests[socks]
+(>=2.28.2,<3.0.0) Requires-Dist: rich (>=13.3.1,<14.0.0) Requires-Dist:
+rlaphoenix-pymp4 (>=1.5.0,<2.0.0) Requires-Dist: rlaphoenix.m3u8
+(>=3.4.0,<4.0.0) Requires-Dist: ruamel.yaml (>=0.17.21,<0.18.0) Requires-Dist:
+sortedcontainers (>=2.4.0,<3.0.0) Requires-Dist: subtitle-filter
+(>=1.4.4,<2.0.0) Requires-Dist: urllib3 (>=1.26.14,<2.0.0) Project-URL:
+Repository, https://github.com/devine-dl/devine Description-Content-Type: text/
+markdown
  [https://user-images.githubusercontent.com/17136956/216880837-478f3ec7-6af6-
                       4cca-8eef-5c98ff02104c.png] Devine
              Open-Source Movie, TV, and Music Downloading Solution
                  [Build_status] [Python_version] [DeepSource]
 ## Features - ð¥ Supports Movies, TV shows, and Music - ð§© Easy
 installation via PIP/PyPI - ð¥ Multi-profile authentication per-service with
 credentials or cookies - ð¤ Automatic P2P filename structure with Group Tag -
```

## Comparing `devine-2.1.0.dist-info/RECORD` & `devine-2.2.0.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 devine/__main__.py,sha256=I0IuClBcXzYKreeH1kyu2ud23owaLEnjztnyTHdMpWg,80
 devine/commands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 devine/commands/auth.py,sha256=_D-3RocD5TrgfRHPxchjIoPPGAcO7yQfxZofTCDw0rE,9622
 devine/commands/cfg.py,sha256=6xFC98GY_eeWOHDZOg876-K2EvjaoOfaPqaXPD-n8dk,3254
-devine/commands/dl.py,sha256=3P_1nqvm_xEK89aQjI2yawoA7qnAcYeqT2PyWjGdCYw,45258
+devine/commands/dl.py,sha256=m9QOpoKfzJNqMPAV9xTySKQCuz5Nz8cU8tubBEWnaMY,47586
 devine/commands/env.py,sha256=6pTU8vmGunJ5P73dA0u6K85SuakCH6T2smLL048s5xU,2247
 devine/commands/kv.py,sha256=3BMZj9ZQLXfj37WLIaE8xCh295GrIqUFznk6iy1BXPI,7986
 devine/commands/serve.py,sha256=Z0VLHARuu6tyv_QbYrTqB-iiN0Lhq3LWcT4e5hf3noA,1743
 devine/commands/util.py,sha256=zAhJZin0S31n5KkTPYeh0euMrZHP4mWuwKN5bW6tdgI,9243
 devine/commands/wvd.py,sha256=6UdaG_g0BE8sivPdRb1j6pcNM26iydMfC1ZkjBuIeRM,9325
 devine/core/__init__.py,sha256=Xybt2skBZamGMNlLuOX1IG-h4uIxqUDGAO8MIGWrJac,22
 devine/core/__main__.py,sha256=bPq-A2MGwv_rqnp-jqNHW3VF3mFQeKgsO73qdh74pFE,2865
@@ -17,18 +17,18 @@
 devine/core/constants.py,sha256=wIZIFHXS1qUIizEXKTj899s43qgPRwAQX4Czy3ehQLg,1434
 devine/core/credential.py,sha256=TEWUUcJCEJvIIKu14NaSDUmaNMjcHrw0NLDL9QlD38s,3380
 devine/core/downloaders/__init__.py,sha256=r_M68Rmyjv_IzmjzgROb4iDcwRtNR8TICLhDiqjDT9w,79
 devine/core/downloaders/aria2c.py,sha256=GBOLAYd1QpnRL1apgdy0Ad3vRB7Xg7C7bVyf2BplgQY,6571
 devine/core/downloaders/saldl.py,sha256=1vdOjt-oRbgXu6DXCnaRnH9Dr5qANqhbsWVIu6XLp14,1263
 devine/core/drm/__init__.py,sha256=z91OHFB9vE2aA7-1M2kvxHgUw_KcV3klZCFF6nIJ8PA,193
 devine/core/drm/clearkey.py,sha256=ANf_O2Bn0xIhchSUfedYsxJScXDCMzeyot3iwEDVGB4,3457
-devine/core/drm/widevine.py,sha256=XLHqakwnBMS_p-Uk5GUwok5p0ZvAdKsqKr5YLoHNvL4,11502
+devine/core/drm/widevine.py,sha256=e2ZaQPty7Eh6_qCwS6xbycaznX_ed1Bqc-8WHuUW0q4,11761
 devine/core/manifests/__init__.py,sha256=mu4lhDrGaGdejRpULKqVot2CnIp_50JfhOeBHpCCqQQ,67
-devine/core/manifests/dash.py,sha256=xN1jBgWGtbxaQ32tx-eNC2fz2FG8kEqz8rrphTLunLw,29280
-devine/core/manifests/hls.py,sha256=1A-Yps9-tDM_z5dOTQ8BO9_fV6wr1U33RoZ43q7vlGQ,20236
+devine/core/manifests/dash.py,sha256=UE8_rxuv5PnEPgi5nsB480g9ZW1vddK-erNEonefRcU,29526
+devine/core/manifests/hls.py,sha256=lqyHEz_cKvxVdtUgnus9rSBwKsIBlM6irDYXEHlzZ-g,20243
 devine/core/proxies/__init__.py,sha256=KswhpMdSDFSMnzs8UwjyMZE4GeiSl4qvjDZ1pJ-pYak,111
 devine/core/proxies/basic.py,sha256=tJcuzS_vbX4JifjEJncsnafm-jKJkNPPhRJfvt7G6fQ,929
 devine/core/proxies/hola.py,sha256=HpDm2g48XLNhidyh7dTfo5RFe7AXyFL8cFe-58ya-OU,2290
 devine/core/proxies/nordvpn.py,sha256=6PZur1W_8a5wRq2tNVbpS2fVW7huHIzoijRUj19ntYM,5565
 devine/core/proxies/proxy.py,sha256=UHv2CB87N41Rzgkb3Lb1AL3l3YIqcCPGGyOtg3X36Gs,1048
 devine/core/service.py,sha256=RADul7o7V2JGV5aztiJGVLr6NCJV7pIwQse-358AdPE,10763
 devine/core/services.py,sha256=ilmDjVFoB4w-yD4L1PbLeSwHD7g0ONdLwYGbuP7dg3s,2606
@@ -36,28 +36,28 @@
 devine/core/titles/episode.py,sha256=vof85Y-Mj7p1nA-yq-_Jurhv4n7U5SX7M_UjB0a_XaY,7998
 devine/core/titles/movie.py,sha256=kSekTJPeuD-CJplH_n3Y5DP-e_vU7FYAhfMo_Z4by0k,5534
 devine/core/titles/song.py,sha256=sH72NqaQNyz8ZvHtFyUj8O1NXRyRu5HFjuJpgsRBsZg,4685
 devine/core/titles/title.py,sha256=tuToZW-nY9Bt2P5VhoQjT2iimUOgtiGEUsn3Nwnha1M,2593
 devine/core/tracks/__init__.py,sha256=NY5oDXpexBFeCB212ztbYXjw5FNpCw--OmQgvIEtAnU,222
 devine/core/tracks/audio.py,sha256=xM7GRYc_MNfbQdXgs0sdodq_sqYTg1i3PQIpxTjYSbY,4865
 devine/core/tracks/chapter.py,sha256=OU5lLjb-KZH8YJSvqU6FYJSk79QwrSziUnNzNWboTDg,3069
-devine/core/tracks/subtitle.py,sha256=Xko1kIi83jRQpVp0oyLW2jxUV_yzIzG9UFUEhGtwamQ,17699
-devine/core/tracks/track.py,sha256=FplA7YohMqlcdUgmKjFTbmDfOEmMGGbp94HdtZVcWYk,11257
-devine/core/tracks/tracks.py,sha256=3bQVyzPyefwq0YdKdHR4zCdICnni2dlusim6coelBck,16711
-devine/core/tracks/video.py,sha256=Lnj53REhSHfwwW8zyyVhHQTHnpj7H7Wdri147AZaqJA,12662
-devine/core/utilities.py,sha256=YxQkM3kciTvrd2YTPF4914LUw4Hkt34ho7z6OrF01Bc,8411
+devine/core/tracks/subtitle.py,sha256=eoBkYVXKWvDmE844j2l0BEbZuXlvR6VjuS0sYWUHTko,17815
+devine/core/tracks/track.py,sha256=QB6XOqGHTZsnmP4b9FrEXI2WJLA8VUvbizp50y7EPBY,11630
+devine/core/tracks/tracks.py,sha256=DlJEugBcPQYcJul4sADVUTE-bwbuc7U5jLwJcUsIKGQ,16817
+devine/core/tracks/video.py,sha256=23dNpWsC90GcueIL12Vz5zowq5RqqLWKOtP7ux5VdQc,12569
+devine/core/utilities.py,sha256=3-gMbgh0foKz87l04_CnRzzfP0RnYzWjS52BBNKQJzU,8732
 devine/core/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-devine/core/utils/click_types.py,sha256=LeTgWltpR2chyzOeIxJLlKcq_eJFr76bFzTdbJi-22o,4232
+devine/core/utils/click_types.py,sha256=QQPGLnglwkfZ2n6tHgDAI2UgVzLENKoDuKEAcVc19QU,4613
 devine/core/utils/collections.py,sha256=8jEUE8hRNzpTHX0oMV8-Jzm3V0UuzNlgTeNAKPm-VwU,1532
 devine/core/utils/sslciphers.py,sha256=yJWdPXqPwnd08p-q-AdMiM7pWRUWtd07ZQvAQGCCxrA,3699
 devine/core/utils/subprocess.py,sha256=CYDfzzYQsmWTVwRz3Wb2hwbYABxmlH1Dw46x2rycZWU,845
 devine/core/utils/xml.py,sha256=xfUk6wbpGdLz25vp8qXoARlribZYDK-O50RzrRml_-4,791
 devine/core/vault.py,sha256=nEfJL9z3FG8r-YU15JJtdt4xh2yL35-KitglN_4WHKA,1709
 devine/core/vaults.py,sha256=VLGxWcum2MDlKPNUCb3N8WOgQRhM6eVPKiONyYdAtXw,2516
 devine/vaults/MySQL.py,sha256=FrZgCkkX91mDGl2Pv4v2IlD1Dw5jhaWLH0o4KvRd9a8,8485
 devine/vaults/SQLite.py,sha256=_EDuG5AXJELKZf_5AcPnS0UEs0OZHkpYVWlumrUrDSA,6076
 devine/vaults/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-devine-2.1.0.dist-info/LICENSE,sha256=gcuuhKKc5-dwvyvHsXjlC9oM6N5gZ6umYbC8ewW1Yvg,35821
-devine-2.1.0.dist-info/entry_points.txt,sha256=u-Ox5EokBkkFJYbqhVB6FUMG3YU5oPWJ2yO3YQ7UQCo,52
-devine-2.1.0.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
-devine-2.1.0.dist-info/METADATA,sha256=ZLnyudwkTx9R313l7G2hxQ2Dwu8q-D2L4Irb3dnPM_8,19241
-devine-2.1.0.dist-info/RECORD,,
+devine-2.2.0.dist-info/LICENSE,sha256=gcuuhKKc5-dwvyvHsXjlC9oM6N5gZ6umYbC8ewW1Yvg,35821
+devine-2.2.0.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
+devine-2.2.0.dist-info/entry_points.txt,sha256=u-Ox5EokBkkFJYbqhVB6FUMG3YU5oPWJ2yO3YQ7UQCo,52
+devine-2.2.0.dist-info/METADATA,sha256=rFc_1d7IF_zUN3oRjGdgkjxtIYlmbAL3zbDtTGecSrc,19252
+devine-2.2.0.dist-info/RECORD,,
```

