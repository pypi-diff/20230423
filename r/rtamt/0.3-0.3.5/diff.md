# Comparing `tmp/rtamt-0.3.tar.gz` & `tmp/rtamt-0.3.5.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\rtamt-0.3.tar", last modified: Fri Mar 25 10:16:04 2022, max compression
+gzip compressed data, was "rtamt-0.3.5.tar", last modified: Sun Apr 23 14:51:02 2023, max compression
```

## Comparing `rtamt-0.3.tar` & `rtamt-0.3.5.tar`

### file list

```diff
@@ -1,369 +1,324 @@
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/
--rw-rw-rw-   0        0        0     1545 2022-03-25 10:06:31.000000 rtamt-0.3/LICENSE
--rw-rw-rw-   0        0        0    19978 2022-03-25 10:16:04.000000 rtamt-0.3/PKG-INFO
--rw-rw-rw-   0        0        0    18810 2022-03-25 10:06:31.000000 rtamt-0.3/README.md
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/
--rw-rw-rw-   0        0        0     1445 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/ast/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/ast/visitor/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/visitor/__init__.py
--rw-rw-rw-   0        0        0      458 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/visitor/abstract_visitor.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/ast/visitor/ltl/
--rw-rw-rw-   0        0        0     7171 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/visitor/ltl/ASTVisitor.py
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/visitor/ltl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/ast/visitor/stl/
--rw-rw-rw-   0        0        0     9352 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/visitor/stl/ASTVisitor.py
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/ast/visitor/stl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/enumerations/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/enumerations/__init__.py
--rw-rw-rw-   0        0        0      121 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/enumerations/bool_ops.py
--rw-rw-rw-   0        0        0      580 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/enumerations/comp_op.py
--rw-rw-rw-   0        0        0      235 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/enumerations/comp_oper.py
--rw-rw-rw-   0        0        0      185 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/enumerations/io_type.py
--rw-rw-rw-   0        0        0      551 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/enumerations/options.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/ltl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/cpp/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/cpp/__init__.py
--rw-rw-rw-   0        0        0     7669 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/cpp/online_discrete_time_cpp_monitor.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/python/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/python/__init__.py
--rw-rw-rw-   0        0        0     7439 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/discrete_time/online/python/online_discrete_time_python_monitor.py
--rw-rw-rw-   0        0        0     9424 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/ltl/online_evaluator.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/offline/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/offline/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/offline/python/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/offline/python/__init__.py
--rw-rw-rw-   0        0        0     9543 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/offline/python/offline_dense_time_python_monitor.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/online/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/online/python/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/online/python/__init__.py
--rw-rw-rw-   0        0        0     8741 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/dense_time/online/python/online_dense_time_python_monitor.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/offline/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/offline/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/offline/python/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/offline/python/__init__.py
--rw-rw-rw-   0        0        0    10151 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/offline/python/offline_discrete_time_python_monitor.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/cpp/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/cpp/__init__.py
--rw-rw-rw-   0        0        0     9284 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/cpp/online_discrete_time_cpp_monitor.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/python/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/python/__init__.py
--rw-rw-rw-   0        0        0     9320 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/discrete_time/online/python/online_discrete_time_python_monitor.py
--rw-rw-rw-   0        0        0    13287 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/offline_evaluator.py
--rw-rw-rw-   0        0        0    12966 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/evaluator/stl/online_evaluator.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/exception/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/exception/__init__.py
--rw-rw-rw-   0        0        0       42 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/exception/exception.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/exception/ltl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/exception/ltl/__init__.py
--rw-rw-rw-   0        0        0      382 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/exception/ltl/exception.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/exception/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/exception/stl/__init__.py
--rw-rw-rw-   0        0        0      328 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/exception/stl/exception.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/interval/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/interval/__init__.py
--rw-rw-rw-   0        0        0     1083 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/interval/interval.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/lib/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/lib/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/lib/rtamt_stl_library_wrapper/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/lib/rtamt_stl_library_wrapper/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/node/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/__init__.py
--rw-rw-rw-   0        0        0     1539 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/abstract_node.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/node/arithmetic/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/__init__.py
--rw-rw-rw-   0        0        0      558 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/abs.py
--rw-rw-rw-   0        0        0      772 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/addition.py
--rw-rw-rw-   0        0        0      598 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/division.py
--rw-rw-rw-   0        0        0      458 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/exp.py
--rw-rw-rw-   0        0        0      620 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/multiplication.py
--rw-rw-rw-   0        0        0      573 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/pow.py
--rw-rw-rw-   0        0        0      466 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/sqrt.py
--rw-rw-rw-   0        0        0      608 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/arithmetic/subtraction.py
--rw-rw-rw-   0        0        0      266 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/binary_node.py
--rw-rw-rw-   0        0        0      132 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/leaf_node.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/node/ltl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/__init__.py
--rw-rw-rw-   0        0        0      512 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/always.py
--rw-rw-rw-   0        0        0      714 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/conjunction.py
--rw-rw-rw-   0        0        0      751 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/constant.py
--rw-rw-rw-   0        0        0      591 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/disjunction.py
--rw-rw-rw-   0        0        0      525 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/eventually.py
--rw-rw-rw-   0        0        0      467 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/fall.py
--rw-rw-rw-   0        0        0      510 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/historically.py
--rw-rw-rw-   0        0        0      578 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/iff.py
--rw-rw-rw-   0        0        0      591 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/implies.py
--rw-rw-rw-   0        0        0      495 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/neg.py
--rw-rw-rw-   0        0        0      459 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/next.py
--rw-rw-rw-   0        0        0      505 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/once.py
--rw-rw-rw-   0        0        0     1197 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/predicate.py
--rw-rw-rw-   0        0        0      489 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/previous.py
--rw-rw-rw-   0        0        0      467 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/rise.py
--rw-rw-rw-   0        0        0      604 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/since.py
--rw-rw-rw-   0        0        0      630 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/until.py
--rw-rw-rw-   0        0        0     1406 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/variable.py
--rw-rw-rw-   0        0        0      578 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/ltl/xor.py
--rw-rw-rw-   0        0        0     1824 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/node.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/node/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/__init__.py
--rw-rw-rw-   0        0        0      389 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/time_bound.py
--rw-rw-rw-   0        0        0      791 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_always.py
--rw-rw-rw-   0        0        0      706 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_eventually.py
--rw-rw-rw-   0        0        0      725 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_historically.py
--rw-rw-rw-   0        0        0      694 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_once.py
--rw-rw-rw-   0        0        0      925 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_precedes.py
--rw-rw-rw-   0        0        0      843 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_since.py
--rw-rw-rw-   0        0        0      833 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/stl/timed_until.py
--rw-rw-rw-   0        0        0      205 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/node/unary_node.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/operation/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/__init__.py
--rw-rw-rw-   0        0        0      478 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/abstract_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/operation/arithmetic/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/__init__.py
--rw-rw-rw-   0        0        0      402 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/abs_operation.py
--rw-rw-rw-   0        0        0      587 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/addition_operation.py
--rw-rw-rw-   0        0        0      569 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/division_operation.py
--rw-rw-rw-   0        0        0      420 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/exp_operation.py
--rw-rw-rw-   0        0        0      581 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/multiplication_operation.py
--rw-rw-rw-   0        0        0      561 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/pow_operation.py
--rw-rw-rw-   0        0        0      527 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/sqrt_operation.py
--rw-rw-rw-   0        0        0      575 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/offline/subtraction_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/__init__.py
--rw-rw-rw-   0        0        0      755 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/abs_operation.py
--rw-rw-rw-   0        0        0     1083 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/addition_operation.py
--rw-rw-rw-   0        0        0     1085 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/division_operation.py
--rw-rw-rw-   0        0        0      502 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/exp_operation.py
--rw-rw-rw-   0        0        0     1101 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/multiplication_operation.py
--rw-rw-rw-   0        0        0      751 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/pow_operation.py
--rw-rw-rw-   0        0        0      605 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/sqrt_operation.py
--rw-rw-rw-   0        0        0     1092 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/subtraction_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/__init__.py
--rw-rw-rw-   0        0        0      367 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/abs_operation.py
--rw-rw-rw-   0        0        0      385 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/addition_operation.py
--rw-rw-rw-   0        0        0      385 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/division_operation.py
--rw-rw-rw-   0        0        0      385 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/exp_operation.py
--rw-rw-rw-   0        0        0      389 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/multiplication_operation.py
--rw-rw-rw-   0        0        0      400 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/pow_operation.py
--rw-rw-rw-   0        0        0      483 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/sqrt_operation.py
--rw-rw-rw-   0        0        0      388 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/offline/subtraction_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/__init__.py
--rw-rw-rw-   0        0        0      267 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/abs_operation.py
--rw-rw-rw-   0        0        0      278 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/addition_operation.py
--rw-rw-rw-   0        0        0      276 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/division_operation.py
--rw-rw-rw-   0        0        0      285 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/exp_operation.py
--rw-rw-rw-   0        0        0      282 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/multiplication_operation.py
--rw-rw-rw-   0        0        0      293 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/pow_operation.py
--rw-rw-rw-   0        0        0      374 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/sqrt_operation.py
--rw-rw-rw-   0        0        0      281 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/arithmetic/discrete_time/online/subtraction_operation.py
--rw-rw-rw-   0        0        0      900 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/sample.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/dense_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/__init__.py
--rw-rw-rw-   0        0        0     2107 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/always_bounded_operation.py
--rw-rw-rw-   0        0        0      715 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/always_operation.py
--rw-rw-rw-   0        0        0      447 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/and_operation.py
--rw-rw-rw-   0        0        0      285 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/constant_operation.py
--rw-rw-rw-   0        0        0     2058 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/eventually_bounded_operation.py
--rw-rw-rw-   0        0        0      721 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/eventually_operation.py
--rw-rw-rw-   0        0        0     2389 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/historically_bounded_operation.py
--rw-rw-rw-   0        0        0      682 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/historically_operation.py
--rw-rw-rw-   0        0        0      710 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/iff_operation.py
--rw-rw-rw-   0        0        0      722 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/implies_operation.py
--rw-rw-rw-   0        0        0     3739 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/intersection.py
--rw-rw-rw-   0        0        0      383 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/not_operation.py
--rw-rw-rw-   0        0        0     2390 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/once_bounded_operation.py
--rw-rw-rw-   0        0        0      674 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/once_operation.py
--rw-rw-rw-   0        0        0      717 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/or_operation.py
--rw-rw-rw-   0        0        0     2841 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/predicate_operation.py
--rw-rw-rw-   0        0        0     1413 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/since_bounded_operation.py
--rw-rw-rw-   0        0        0      864 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/since_operation.py
--rw-rw-rw-   0        0        0     1401 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/until_bounded_operation.py
--rw-rw-rw-   0        0        0      909 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/until_operation.py
--rw-rw-rw-   0        0        0      711 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/offline/xor_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/__init__.py
--rw-rw-rw-   0        0        0     1093 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/always_operation.py
--rw-rw-rw-   0        0        0     1076 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/and_operation.py
--rw-rw-rw-   0        0        0      539 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/constant_operation.py
--rw-rw-rw-   0        0        0     4319 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/historically_bounded_operation.py
--rw-rw-rw-   0        0        0     1101 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/historically_operation.py
--rw-rw-rw-   0        0        0     1162 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/iff_operation.py
--rw-rw-rw-   0        0        0     1182 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/implies_operation.py
--rw-rw-rw-   0        0        0     2424 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/intersection.py
--rw-rw-rw-   0        0        0      828 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/not_operation.py
--rw-rw-rw-   0        0        0     4321 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/once_bounded_operation.py
--rw-rw-rw-   0        0        0     1095 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/once_operation.py
--rw-rw-rw-   0        0        0     1177 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/or_operation.py
--rw-rw-rw-   0        0        0     5120 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/predicate_operation.py
--rw-rw-rw-   0        0        0     2331 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/since_bounded_operation.py
--rw-rw-rw-   0        0        0     3274 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/since_operation.py
--rw-rw-rw-   0        0        0     1167 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/dense_time/online/xor_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/__init__.py
--rw-rw-rw-   0        0        0      575 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/always_bounded_operation.py
--rw-rw-rw-   0        0        0      439 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/always_operation.py
--rw-rw-rw-   0        0        0      256 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/and_operation.py
--rw-rw-rw-   0        0        0      219 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/constant_operation.py
--rw-rw-rw-   0        0        0      578 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/eventually_bounded_operation.py
--rw-rw-rw-   0        0        0      446 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/eventually_operation.py
--rw-rw-rw-   0        0        0      328 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/fall_operation.py
--rw-rw-rw-   0        0        0      458 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/historically_bounded_operation.py
--rw-rw-rw-   0        0        0      416 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/historically_operation.py
--rw-rw-rw-   0        0        0      263 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/iff_operation.py
--rw-rw-rw-   0        0        0      269 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/implies_operation.py
--rw-rw-rw-   0        0        0      267 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/next_operation.py
--rw-rw-rw-   0        0        0      255 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/not_operation.py
--rw-rw-rw-   0        0        0      450 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/once_bounded_operation.py
--rw-rw-rw-   0        0        0      407 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/once_operation.py
--rw-rw-rw-   0        0        0      255 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/or_operation.py
--rw-rw-rw-   0        0        0     1968 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/predicate_operation.py
--rw-rw-rw-   0        0        0      381 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/previous_operation.py
--rw-rw-rw-   0        0        0      325 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/rise_operation.py
--rw-rw-rw-   0        0        0     1182 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/since_bounded_operation.py
--rw-rw-rw-   0        0        0      487 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/since_operation.py
--rw-rw-rw-   0        0        0     1213 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/until_bounded_operation.py
--rw-rw-rw-   0        0        0      546 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/until_operation.py
--rw-rw-rw-   0        0        0      284 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/offline/xor_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/__init__.py
--rw-rw-rw-   0        0        0      360 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/always_operation.py
--rw-rw-rw-   0        0        0      277 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/and_operation.py
--rw-rw-rw-   0        0        0      257 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/constant_operation.py
--rw-rw-rw-   0        0        0      370 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/eventually_operation.py
--rw-rw-rw-   0        0        0      351 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/fall_operation.py
--rw-rw-rw-   0        0        0      814 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/historically_bounded_operation.py
--rw-rw-rw-   0        0        0      368 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/historically_operation.py
--rw-rw-rw-   0        0        0      279 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/iff_operation.py
--rw-rw-rw-   0        0        0      282 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/implies_operation.py
--rw-rw-rw-   0        0        0      264 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/not_operation.py
--rw-rw-rw-   0        0        0      813 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/once_bounded_operation.py
--rw-rw-rw-   0        0        0      364 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/once_operation.py
--rw-rw-rw-   0        0        0      274 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/or_operation.py
--rw-rw-rw-   0        0        0     1413 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/precedes_bounded_operation.py
--rw-rw-rw-   0        0        0     1680 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/predicate_operation.py
--rw-rw-rw-   0        0        0      338 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/previous_operation.py
--rw-rw-rw-   0        0        0      349 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/rise_operation.py
--rw-rw-rw-   0        0        0     1246 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/since_bounded_operation.py
--rw-rw-rw-   0        0        0      398 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/since_operation.py
--rw-rw-rw-   0        0        0      276 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/operation/stl/discrete_time/online/xor_operation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/parser/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/parser/ltl/
--rw-rw-rw-   0        0        0    31895 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/ltl/LtlLexer.py
--rw-rw-rw-   0        0        0    97636 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/ltl/LtlParser.py
--rw-rw-rw-   0        0        0     7589 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/ltl/LtlParserVisitor.py
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/ltl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/parser/ltl/error/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/ltl/error/__init__.py
--rw-rw-rw-   0        0        0      877 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/ltl/error/parser_error_listener.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/parser/stl/
--rw-rw-rw-   0        0        0    31895 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/stl/StlLexer.py
--rw-rw-rw-   0        0        0   109291 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/stl/StlParser.py
--rw-rw-rw-   0        0        0     8173 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/stl/StlParserVisitor.py
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/stl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/parser/stl/error/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/stl/error/__init__.py
--rw-rw-rw-   0        0        0      877 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/parser/stl/error/parser_error_listener.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/pastifier/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/pastifier/ltl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/ltl/__init__.py
--rw-rw-rw-   0        0        0     5794 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/ltl/horizon.py
--rw-rw-rw-   0        0        0     6785 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/ltl/pastifier.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/pastifier/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/stl/__init__.py
--rw-rw-rw-   0        0        0     2089 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/stl/horizon.py
--rw-rw-rw-   0        0        0     3214 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/pastifier/stl/pastifier.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/reset/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/reset/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/reset/ltl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/reset/ltl/__init__.py
--rw-rw-rw-   0        0        0     5526 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/reset/ltl/reset.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/reset/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/reset/stl/__init__.py
--rw-rw-rw-   0        0        0     1787 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/reset/stl/reset.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/spec/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/__init__.py
--rw-rw-rw-   0        0        0     6161 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/abstract_specification.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/spec/ltl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/ltl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/spec/ltl/discrete_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/ltl/discrete_time/__init__.py
--rw-rw-rw-   0        0        0     9971 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/ltl/discrete_time/specification.py
--rw-rw-rw-   0        0        0    14183 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/ltl/discrete_time/specification_parser.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/spec/stl/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/spec/stl/dense_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/dense_time/__init__.py
--rw-rw-rw-   0        0        0     3777 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/dense_time/specification.py
--rw-rw-rw-   0        0        0      884 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/dense_time/specification_parser.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/rtamt/spec/stl/discrete_time/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/discrete_time/__init__.py
--rw-rw-rw-   0        0        0    10139 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/discrete_time/specification.py
--rw-rw-rw-   0        0        0     8421 2022-03-25 10:06:31.000000 rtamt-0.3/rtamt/spec/stl/discrete_time/specification_parser.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt.egg-info/
--rw-rw-rw-   0        0        0    19978 2022-03-25 10:16:02.000000 rtamt-0.3/rtamt.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    14185 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2022-03-25 10:16:02.000000 rtamt-0.3/rtamt.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       28 2022-03-25 10:16:02.000000 rtamt-0.3/rtamt.egg-info/requires.txt
--rw-rw-rw-   0        0        0       12 2022-03-25 10:16:03.000000 rtamt-0.3/rtamt.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2022-03-25 10:16:04.000000 rtamt-0.3/setup.cfg
--rw-rw-rw-   0        0        0     1072 2022-03-25 10:09:38.000000 rtamt-0.3/setup.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/tests/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/tests/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/tests/python/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/__init__.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/tests/python/general/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/general/__init__.py
--rw-rw-rw-   0        0        0      624 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/general/test_enums.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/tests/python/oper/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/oper/__init__.py
--rw-rw-rw-   0        0        0    26152 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/oper/test_stl_ct_boolean_and_temporal_online.py
--rw-rw-rw-   0        0        0    47404 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/oper/test_stl_dense_time_offline_evaluation.py
--rw-rw-rw-   0        0        0    11999 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/oper/test_stl_discrete_time_offline_evaluation.py
--rw-rw-rw-   0        0        0    22232 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/oper/test_stl_discrete_time_online_evaluation.py
-drwxrwxrwx   0        0        0        0 2022-03-25 10:16:04.000000 rtamt-0.3/tests/python/spec/
--rw-rw-rw-   0        0        0        0 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/__init__.py
--rw-rw-rw-   0        0        0     3195 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_ia_stl_spec_dense_time_online_evaluation.py
--rw-rw-rw-   0        0        0     2948 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_ia_stl_spec_discrete_time_offline_evaluation.py
--rw-rw-rw-   0        0        0     4819 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_ia_stl_spec_discrete_time_online_evaluation.py
--rw-rw-rw-   0        0        0    24908 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_ltl_spec_discrete_time_online_evaluation.py
--rw-rw-rw-   0        0        0     2124 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_interval_style.py
--rw-rw-rw-   0        0        0    19472 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_pastification.py
--rw-rw-rw-   0        0        0    21980 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_reset.py
--rw-rw-rw-   0        0        0     2568 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_sampling_time_units.py
--rw-rw-rw-   0        0        0    18889 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_spec_dense_time_offline_evaluation.py
--rw-rw-rw-   0        0        0    41640 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_spec_dense_time_online_evaluation.py
--rw-rw-rw-   0        0        0    17494 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_spec_discrete_time_offline_evaluation.py
--rw-rw-rw-   0        0        0    32502 2022-03-25 10:06:31.000000 rtamt-0.3/tests/python/spec/test_stl_spec_discrete_time_online_evaluation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.219968 rtamt-0.3.5/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1516 2023-04-23 14:34:21.000000 rtamt-0.3.5/LICENSE
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    18880 2023-04-23 14:51:02.219968 rtamt-0.3.5/PKG-INFO
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    18227 2023-04-23 14:34:21.000000 rtamt-0.3.5/README.md
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.099968 rtamt-0.3.5/rtamt/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1039 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.103968 rtamt-0.3.5/rtamt/antlr/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.103968 rtamt-0.3.5/rtamt/antlr/parser/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.107968 rtamt-0.3.5/rtamt/antlr/parser/ltl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    31513 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/ltl/LtlLexer.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    96472 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/ltl/LtlParser.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     7317 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/ltl/LtlParserVisitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/ltl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.111968 rtamt-0.3.5/rtamt/antlr/parser/ltl/error/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/ltl/error/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      843 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/ltl/error/parser_error_listener.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.111968 rtamt-0.3.5/rtamt/antlr/parser/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    31513 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/stl/StlLexer.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)   108413 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/stl/StlParser.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     7881 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/stl/StlParserVisitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/stl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.115968 rtamt-0.3.5/rtamt/antlr/parser/stl/error/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/stl/error/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      843 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/antlr/parser/stl/error/parser_error_listener.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.115968 rtamt-0.3.5/rtamt/exception/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/exception/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      343 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/exception/exception.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.115968 rtamt-0.3.5/rtamt/lib/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/lib/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.115968 rtamt-0.3.5/rtamt/lib/rtamt_stl_library_wrapper/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/lib/rtamt_stl_library_wrapper/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.119968 rtamt-0.3.5/rtamt/pastifier/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.119968 rtamt-0.3.5/rtamt/pastifier/ltl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/ltl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     5056 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/ltl/horizon.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     7480 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/ltl/pastifier.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.123968 rtamt-0.3.5/rtamt/pastifier/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/stl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1861 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/stl/horizon.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3656 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/pastifier/stl/pastifier.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.127968 rtamt-0.3.5/rtamt/semantics/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1764 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_dense_time_offline_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     5250 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_dense_time_online_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      407 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_dense_time_online_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2275 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_discrete_time_offline_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3510 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_discrete_time_online_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      541 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      619 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_offline_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3275 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_online_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      583 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/abstract_online_operation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.127968 rtamt-0.3.5/rtamt/semantics/arithmetic/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.127968 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.131968 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      602 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/abs_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1033 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/addition_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1034 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/division_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      593 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/exp_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1045 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/multiplication_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1010 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/pow_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      670 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/sqrt_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      972 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/dense_time/online/subtraction_operation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.131968 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.135968 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      292 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/abs_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      332 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/addition_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      331 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/division_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      309 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/exp_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      337 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/multiplication_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      347 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/pow_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      396 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/sqrt_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      335 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/arithmetic/discrete_time/online/subtraction_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1221 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/dense_time_interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     4140 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/discrete_time_interpreter.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.135968 rtamt-0.3.5/rtamt/semantics/enumerations/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/enumerations/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      114 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/enumerations/bool_ops.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      552 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/enumerations/comp_op.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      221 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/enumerations/comp_oper.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      174 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/enumerations/io_type.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      529 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/enumerations/options.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.135968 rtamt-0.3.5/rtamt/semantics/iastl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.135968 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.139968 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/offline/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/offline/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     4044 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/offline/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1308 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/offline/interpreter.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.143968 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/online/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/online/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1803 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/online/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1249 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/online/interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2412 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/dense_time/online/predicate_operation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.143968 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.143968 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/offline/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/offline/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3571 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/offline/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1403 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/offline/interpreter.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.147968 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/online/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/online/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2209 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/online/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1333 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/online/interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1115 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/iastl/discrete_time/online/predicate_operation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.147968 rtamt-0.3.5/rtamt/semantics/interval/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/interval/__init__.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     1542 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/interval/interval.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      850 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/sample.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.147968 rtamt-0.3.5/rtamt/semantics/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.151968 rtamt-0.3.5/rtamt/semantics/stl/dense_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.151968 rtamt-0.3.5/rtamt/semantics/stl/dense_time/offline/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/offline/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    21090 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/offline/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      391 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/offline/interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3771 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/offline/intersection.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.159968 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      648 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/always_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1105 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/and_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     7341 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      441 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/constant_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      653 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/historically_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2842 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/historically_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1048 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/iff_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1032 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/implies_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      381 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2290 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/intersection.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      586 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/not_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      647 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/once_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2845 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/once_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1026 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/or_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     5697 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/predicate_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1972 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/since_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1792 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/since_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1019 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/xor_operation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.159968 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.159968 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/offline/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/offline/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    14398 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/offline/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      417 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/offline/interpreter.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.171968 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      383 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/always_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      330 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/and_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     7921 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      263 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/constant_operation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.171968 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/cpp/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/cpp/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     9099 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/cpp/ast_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      427 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/cpp/interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      388 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/eventually_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      364 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/fall_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      388 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/historically_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      696 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/historically_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      332 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/iff_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      335 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/implies_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      408 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/interpreter.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      289 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/not_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      382 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/once_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      691 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/once_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      328 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/or_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1186 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/precedes_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2123 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/predicate_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      354 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/previous_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      365 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/rise_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      464 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/since_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1239 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/since_timed_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      330 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/xor_operation.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      360 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/semantics/time_interpreter.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.175968 rtamt-0.3.5/rtamt/spec/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    11029 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/abstract_specification.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.175968 rtamt-0.3.5/rtamt/spec/iastl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/iastl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.175968 rtamt-0.3.5/rtamt/spec/iastl/dense_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/iastl/dense_time/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2355 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/iastl/dense_time/specification.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.175968 rtamt-0.3.5/rtamt/spec/iastl/discrete_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/iastl/discrete_time/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3469 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/iastl/discrete_time/specification.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.175968 rtamt-0.3.5/rtamt/spec/ltl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/ltl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.175968 rtamt-0.3.5/rtamt/spec/ltl/discrete_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/ltl/discrete_time/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     8986 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/ltl/discrete_time/specification.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.179968 rtamt-0.3.5/rtamt/spec/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/stl/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.179968 rtamt-0.3.5/rtamt/spec/stl/dense_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/stl/dense_time/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3107 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/stl/dense_time/specification.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.179968 rtamt-0.3.5/rtamt/spec/stl/discrete_time/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/stl/discrete_time/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     3819 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/spec/stl/discrete_time/specification.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.179968 rtamt-0.3.5/rtamt/syntax/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.179968 rtamt-0.3.5/rtamt/syntax/ast/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.179968 rtamt-0.3.5/rtamt/syntax/ast/parser/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    10205 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/abstract_ast_parser.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.183968 rtamt-0.3.5/rtamt/syntax/ast/parser/ltl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/ltl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    12672 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/ltl/parser_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      723 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/ltl/specification_parser.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.183968 rtamt-0.3.5/rtamt/syntax/ast/parser/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/stl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     4837 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/stl/parser_visitor.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      665 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/parser/stl/specification_parser.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.187968 rtamt-0.3.5/rtamt/syntax/ast/visitor/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/visitor/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1612 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/visitor/abstract_ast_visitor.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.187968 rtamt-0.3.5/rtamt/syntax/ast/visitor/ltl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/visitor/ltl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     7546 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/visitor/ltl/ast_visitor.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.187968 rtamt-0.3.5/rtamt/syntax/ast/visitor/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/visitor/stl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2583 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/ast/visitor/stl/ast_visitor.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.187968 rtamt-0.3.5/rtamt/syntax/node/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     2175 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/abstract_node.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.191968 rtamt-0.3.5/rtamt/syntax/node/arithmetic/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      538 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/abs.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      748 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/addition.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      583 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/division.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      445 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/exp.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      606 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/multiplication.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      559 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/pow.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      453 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/sqrt.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      594 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/arithmetic/subtraction.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      293 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/binary_node.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      156 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/leaf_node.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.199968 rtamt-0.3.5/rtamt/syntax/node/ltl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      493 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/always.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      693 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/conjunction.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      719 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/constant.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      575 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/disjunction.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      514 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/eventually.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      453 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/fall.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      500 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/historically.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      562 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/iff.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      576 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/implies.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      480 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/neg.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      450 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/next.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      491 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/once.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1165 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/predicate.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      475 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/previous.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      453 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/rise.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      590 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/since.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      615 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/until.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1412 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/variable.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      587 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/ltl/xor.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.203968 rtamt-0.3.5/rtamt/syntax/node/stl/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      870 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_always.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      799 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_eventually.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      582 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_historically.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      783 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_once.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1035 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_precedes.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      931 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_since.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      920 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/stl/timed_until.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      232 2023-04-23 14:34:22.000000 rtamt-0.3.5/rtamt/syntax/node/unary_node.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.103968 rtamt-0.3.5/rtamt.egg-info/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    18880 2023-04-23 14:51:01.000000 rtamt-0.3.5/rtamt.egg-info/PKG-INFO
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    11827 2023-04-23 14:51:01.000000 rtamt-0.3.5/rtamt.egg-info/SOURCES.txt
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        1 2023-04-23 14:51:01.000000 rtamt-0.3.5/rtamt.egg-info/dependency_links.txt
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)       62 2023-04-23 14:51:01.000000 rtamt-0.3.5/rtamt.egg-info/requires.txt
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)       12 2023-04-23 14:51:01.000000 rtamt-0.3.5/rtamt.egg-info/top_level.txt
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)       38 2023-04-23 14:51:02.219968 rtamt-0.3.5/setup.cfg
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)     1126 2023-04-23 14:49:36.000000 rtamt-0.3.5/setup.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.203968 rtamt-0.3.5/tests/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.207968 rtamt-0.3.5/tests/cpp/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/cpp/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)    31924 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/cpp/test_stl_discrete_time_online_specification_cpp.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    18996 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/cpp/test_stl_evaluation_cpp.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    18792 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/cpp/test_stl_reset_cpp.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     1280 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/cpp/test_stl_sampling_time_units_cpp.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.207968 rtamt-0.3.5/tests/python/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/__init__.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.215968 rtamt-0.3.5/tests/python/api/
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/special_var.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     3100 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_iastl_dense_time_online_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     2860 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_iastl_discrete_time_offline_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     4694 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_iastl_discrete_time_online_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    24146 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_ltl_discrete_time_online_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     2068 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_object_vars.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     2207 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_sampling_frequency.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     2068 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_spec.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    19693 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_dense_time_offline_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    40460 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_dense_time_online_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    16944 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_discrete_time_offline_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    31536 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_discrete_time_online_specification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     2057 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_interval_style.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    13790 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_pastification.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    21337 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_reset.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)     2483 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/api/test_stl_sampling_time_units.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.215968 rtamt-0.3.5/tests/python/general/
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/general/__init__.py
+-rw-rw-r--   0 nickovic  (1000) nickovic  (1000)      607 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/general/test_enums.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.215968 rtamt-0.3.5/tests/python/oper/
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/oper/__init__.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    25586 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/oper/test_stl_ct_boolean_and_temporal_online.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    21636 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/oper/test_stl_discrete_time_online_evaluation.py
+drwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:51:02.219968 rtamt-0.3.5/tests/python/semantics/
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)        0 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/semantics/__init__.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    70844 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/semantics/test_stl_dense_time_offline_evaluation.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    25829 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/semantics/test_stl_dense_time_online_update.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    21639 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/semantics/test_stl_discrete_time_offline_evaluation.py
+-rwxrwxr-x   0 nickovic  (1000) nickovic  (1000)    22644 2023-04-23 14:34:22.000000 rtamt-0.3.5/tests/python/semantics/test_stl_discrete_time_online_update.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `rtamt-0.3/LICENSE` & `rtamt-0.3.5/LICENSE`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-BSD 3-Clause License
-
-Copyright (c) 2019, nickovic
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its
-   contributors may be used to endorse or promote products derived from
-   this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+BSD 3-Clause License
+
+Copyright (c) 2019, nickovic
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `rtamt-0.3/README.md` & `rtamt-0.3.5/PKG-INFO`

 * *Files 13% similar despite different names*

```diff
@@ -1,527 +1,544 @@
-<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
-**Table of Contents**
-
-- [About](#about)
-- [Installation](#installation)
-  - [Install prerequisites for RTAMT installation](#install-prerequisites-for-rtamt-installation)
-  - [Option 1: Install Python package version](#option-1-install-python-package-version)
-  - [Option 2: Build the tool](#option-2-build-the-tool)
-    - [Clone the repository](#clone-the-repository)
-    - [Build CPP libraries](#build-cpp-libraries)
-    - [Install RTAMT](#install-rtamt)
-    - [uninstall RTAMT](#uninstall-rtamt)
-  - [test RTAMT](#test-rtamt)
-- [Theory](#theory)
-  - [Specification Language](#specification-language)
-- [Usage](#usage)
-  - [Example Usage](#example-usage)
-    - [Discrete-time online monitor](#discrete-time-online-monitor)
-    - [Dense-time online monitor](#dense-time-online-monitor)
-  - [Dense-time Offline Monitor](#dense-time-offline-monitor)
-  - [Discrete-time Specifics](#discrete-time-specifics)
-    - [Working with time units and timing assumptions](#working-with-time-units-and-timing-assumptions)
-- [References](#references)
-
-<!-- markdown-toc end -->
-
-# About
-
-RTAMT is a Python (2- and 3-compatible) library for monitoring of Signal Temporal Logic (STL).
-The library implements algorithms offline and online monitoring of discrete-time and dense-time STL.
-The online monitors support the bounded future fragment of STL.
-The online discrete-time part of the library has an optimized C++ back-end.
-
-# Installation
-
-## Install prerequisites for RTAMT installation
-
-```bash
-sudo apt install libboost-all-dev
-sudo apt install python-dev
-sudo apt install python-pip
-```
-
-If your want to extend the specification language, you may need the ANTLR4 parser generator.
-
-```bash
-sudo apt install antlr4
-```
-
-You will also need CMake version 3.12 or higher if you need to build the CPP backend.
-
-```bash
-sudo apt install cmake
-```
-
-In our experience, Ubuntu 16.04, 18.04 don't support the versions in default. You can check [our manual intallation of cmake](README_cmake.md).
-
-## Option 1: Install Python package version
-
-We provide Python package version of RTAMT.
-
-for Python 2
-
-```bash
-sudo pip2 install rtamt
-```
-
-for Python 3
-
-```bash
-sudo pip3 install rtamt
-```
-
-## Option 2: Build the tool
-
-### Clone the repository
-
-```bash
-git clone https://github.com/nickovic/rtamt
-```
-
-### Build CPP libraries
-
-This step is needed only if you want to use the CPP backend and
-can be skipped if you want to use pure Python monitors.
-
-for Python 2
-
-```bash
-cd rtamt/rtamt
-mkdir build
-cd build
-cmake -DPythonVersion=2 ../
-make
-```
-
-for Python 3
-
-```bash
-cd rtamt/rtamt
-mkdir build
-cd build
-cmake -DPythonVersion=3 ../
-make
-```
-
-### Install RTAMT
-
-for Python 2
-
-```bash
-cd rtamt/
-sudo pip2 install .
-```
-
-for Python 3
-
-```bash
-cd rtamt/
-sudo pip3 install .
-```
-
-### uninstall RTAMT
-
-for Python 2
-
-```bash
-sudo pip2 uninstall rtamt
-```
-
-for Python 3
-
-```bash
-sudo pip3 uninstall rtamt
-```
-
-## test RTAMT
-
-for Python 2
-
-```bash
-cd rtamt/
-python2 -m unittest discover tests/
-```
-
-for Python 3
-
-```bash
-cd rtamt/
-python3 -m unittest discover tests/
-```
-
-# Theory
-
-RTAMT is a Python library for offline and online monitoring of (bounded-future)  
-Signal Temporal Logic (STL). The library is inspired by several theoretical and practical  
-works:
-
-- The bounded-future fragment of STL is inspired by [2]
-- The interface-aware interpretation of STL quantitative semantics is inspired by [3]
-- The periodic-sampling interpretation of specifications (even in presence of timestamps that are not prefectly periodic) is inpired by [4]
-- The translation of bounded-future STL to "equirobust" past STL prior to the online monitoring phase is inspired by [2]
-
-## Specification Language
-
-RTAMT supports Signal Temporal Logic (STL) and interface-aware STL (IA-STL).
-
-The library supports a variant of STL with past and future temporal operators as well as basic arithmetic and absolute value operators.  
-Semantics of STL is defined in terms of a robustness degree `rho(phi,w,t)`, a function defined over real numbers extended with `+inf` and `-inf` that takes as input an STL specification `phi`, an input signal `w` and time index `t`, and computes how far is the signal `w` at time `t` from satisfying/violating `phi`. The robustness degree function is defined inductively as follows (`c` is a real constant, `x` is a variable, `w_x(t)` denotes the value of `w` projected to `x` at time `t`, `a,b` are rational constants such that `0 <= a <= b` and `|w|` is the length of `w`):
-
-```txt
-% Constant
-rho(c,w,t) = c
-
-% Variable
-rho(x,w,t) = w_x(t)
-
-% Absolute value, exponentials
-rho(abs(phi),w,t) = |rho(phi,w,t)|
-rho(exp(phi),w,t) = e**rho(phi,w,t)
-rho(pow(phi1, phi2),w,t) = rho(phi1,w,t)**rho(phi2,w,t)
-
-% Arithmetic operators
-rho(phi + psi,w,t) = rho(phi,w,t) + rho(psi,w,t)
-rho(phi - psi,w,t) = rho(phi,w,t) - rho(psi,w,t)
-rho(phi * psi,w,t) = rho(phi,w,t) * rho(psi,w,t)
-rho(phi / psi,w,t) = rho(phi,w,t) / rho(psi,w,t)
-
-% Numeric predicates
-rho(phi <= psi,w,t) = rho(psi,w,t) - rho(phi,w,t) 
-rho(phi < psi,w,t) = rho(psi,w,t) - rho(phi,w,t)
-rho(phi >= psi,w,t) = rho(phi,w,t) - rho(psi,w,t)
-rho(phi > psi,w,t) = rho(phi,w,t) - rho(psi,w,t)
-rho(phi == psi,w,t) = -|rho(phi,w,t) - rho(psi,w,t)|
-rho(phi !== psi,w,t) = |rho(phi,w,t) - rho(psi,w,t)|
-
-% Boolean operators
-rho(not(phi),w,t) = -rho(phi,w,t)
-rho(phi or psi,w,t) = max(rho(phi,w,t),rho(psi,w,t))
-rho(phi and psi,w,t) = min(rho(phi,w,t),rho(psi,w,t))
-rho(phi -> psi,w,t) = max(-rho(phi,w,t),rho(psi,w,t))
-rho(phi <-> psi,w,t) = -|rho(phi,w,t) - rho(psi,w,t)|
-rho(phi xor psi,w,t) = |rho(phi,w,t) - rho(psi,w,t)|
-
-% Events
-rho(rise(phi),w,t) = rho(phi,w,t)                     if t=0
-                     min(-rho(phi,w,t-1),rho(phi,w,t) otherwise
-rho(fall(phi),w,t) = -rho(phi,w,t)                    if t=0
-                     min(rho(phi,w,t-1),-rho(phi,w,t) otherwise
-
-% Past untimed temporal operators
-rho(prev phi,w,t) = -inf            if t<=0
-                    rho(phi,w,t-1) otherwise
-rho(once phi,w,t) = max_{t' in [0,t]} rho(phi,w,t')
-rho(historically phi,w,t) = min_{t' in [0,t]} rho(phi,w,t')
-rho(phi since psi,w,t) = max_{t' in [0,t]}(min(rho(psi,w,t'), min_{t'' in (t',t]} rho(phi,w,t'')))
-
-% Past timed temporal operators
-rho(once[a,b] phi,w,t) = -inf                                                            if t-a < 0
-                         max_{t' in ([0,t] intersect [t-a,t-b])} rho(phi,w,t')           otherwise
-rho(historically[a,b] phi,w,t) = inf                                                     if t-a < 0
-                                 min_{t' in ([0,t] intersect [t-a,t-b])} rho(phi,w,t')   otherwise
-rho(phi since[a,b] psi,w,t) = -inf                                                       if t-a < 0 
-                              max_{t' in ([0,t] intersect [t-a,t-b]} (min(rho(psi,w,t'), 
-                              min_{t'' in (t',t]} rho(phi,w,t'')))          otherwise
-
-% Future untimed temporal operators
-rho(next phi,w,t) = rho(phi,w,t+1)
-rho(eventually phi,w,t) = max_{t' in [t,|w|]} rho(phi,w,t')
-rho(always phi,w,t) = min_{t' in [t, |w|]} rho(phi,w,t')
-rho(phi until psi,w,t) = max_{t' in [t,|w|] min(rho(psi,w,t'), 
-                              min_{t'' in [t,t')}rho(psi,w,t') rho(phi,w,t'')))         otherwise
-
-
-% Future timed temporal operators
-rho(eventually[a,b] phi,w,t) = -inf                                                     if t+a >= |w|
-                               max_{t' in ([0,t] intersect [t+a,t+b])} rho(phi,w,t')    otherwise
-rho(always[a,b] phi,w,t) = inf                                                          if t+a >= |w|
-                           min_{t' in ([0,t] intersect [t+a,t+b])} rho(phi,w,t')        otherwise
-rho(phi until[a,b] psi,w,t) = -inf                                                      if t+a >= |w|
-                              max_{t' in ([0,t] intersect [t+a,t+b]}(min(rho(psi,w,t'), 
-                              min_{t'' in [t,t')}rho(psi,w,t') rho(phi,w,t'')))         otherwise   
-```
-
-We define the robustness degree `rho(phi,w)` as `rho(phi,w,0)`.
-
-There are several important points to note about the above syntax and semantics:
-
-- In the online monitoring mode, the library allows only bounded-future STL specifications, meaning that _unbounded_ future operators `always` `eventually` and `until` cannot appear in the specification.  
-- The `prev` and `next` operators are valid only under the discrete-time interpretation of STL
-- The `unless` operator is added as syntactic sugar - `phi unless[a,b] psi = always[0,b] phi or phi until[a,b] psi
-
-We can see from the semantics of bounded-future STL that the direct evaluation of a formula `phi` at time `t` may depend on inputs at `t'>t` that have not arrived yet.
-The library monitors bounded-future STL formulas with a fixed _delay_. In order to compute `rho(phi,w,t)`, the monitor waits for all inputs required to evaluate `phi` to become available before computing the robustness degree. This delay is fixed and depends on the specification. For instance, the specification `always((req >= 3) -> eventually[0:2]always[0:3](gnt >= 3)`is evaluated with delay `5` - the time needed to capture all inputs required for evaluating bounded `eventually` and `always` operators. We refer the reader to [2] for algorithmic details regarding monitoring with delay.
-
-# Usage
-
-The API provides two monitoring classes:
-
-- `STLDiscreteTimeSpecification` for discrete-time monitors
-- `STLDenseTimeSpecification` for dense-time monitors
-
-Both classes implement online and offline monitors:
-
-- `update` method is used for online evaluation
-. `evaluate` method is used for offline evaluation
-
-## Example Usage
-
-### Discrete-time online monitor
-
-```python
-import sys
-import rtamt
-
-def monitor():
-    # # stl
-    spec = rtamt.STLSpecification()
-    spec.declare_var('a', 'float')
-    spec.declare_var('b', 'float')
-    spec.spec = 'eventually[0,1] (a >= b)'
-
-    try:
-        spec.parse()
-        spec.pastify()
-    except rtamt.RTAMTException as err:
-        print('RTAMT Exception: {}'.format(err))
-        sys.exit()
-
-    rob = spec.update(0, [('a', 100.0), ('b', 20.0)])
-    print('time=' + str(0) + ' rob=' + str(rob))
-
-    rob = spec.update(1, [('a', -1.0), ('b', 2.0)])
-    print('time=' + str(0) + ' rob=' + str(rob))
-
-    rob = spec.update(2, [('a', -2.0), ('b', -10.0)])
-    print('time=' + str(0) + ' rob=' + str(rob))
-
-if __name__ == '__main__':
-    monitor()
-```
-
-### Dense-time online monitor
-
-```python
-import sys
-import rtamt
-
-def monitor():
-    a1 = [(0, 3), (3, 2)]
-    b1 = [(0, 2), (2, 5), (4, 1), (7, -7)]
-
-    a2 = [(5, 6), (6, -2), (8, 7), (11, -1)]
-    b2 = [(10, 4)]
-
-    a3 = [(13, -6), (15, 0)]
-    b3 = [(15, 0)]
-
-    # # stl
-    spec = rtamt.STLDenseTimeSpecification()
-    spec.name = 'STL dense-time specification'
-    spec.declare_var('a', 'float')
-    spec.spec = 'a>=2'
-    try:
-        spec.parse()
-    except rtamt.STLParseException as err:
-        print('STL Parse Exception: {}'.format(err))
-        sys.exit()
-
-    rob = spec.update(['a', a1], ['b', b1])
-    print('rob: ' + str(rob))
-
-    rob = spec.update(['a', a2], ['b', b2])
-    print('rob: ' + str(rob))
-
-    rob = spec.update(['a', a3], ['b', b3])
-    print('rob: ' + str(rob))
-
-if __name__ == '__main__':
-    monitor()
-```
-
-## Dense-time Offline Monitor
-
-```python
-import sys
-import rtamt
-
-def monitor():
-
-    req = [[0.0, 0.0], [3.0, 6.0], [5.0, 0.0], [11.0, 0.0]]
-    gnt = [[0.0, 0.0], [7.0, 6.0], [9.0, 0.0], [11.0, 0.0]]
-    
-    spec = rtamt.STLDenseTimeSpecification()
-    spec.name = 'STL Dense-time Offline Monitor'
-    spec.declare_var('req', 'float')
-    spec.declare_var('gnt', 'float')
-    spec.declare_var('out', 'float')
-    spec.set_var_io_type('req', 'input')
-    spec.set_var_io_type('gnt', 'output')
-    spec.spec = 'out = always((req>=3) implies (eventually[0:5](gnt>=3)))'
-    try:
-        spec.parse()
-        spec.pastify()
-    except rtamt.STLParseException as err:
-        print('STL Parse Exception: {}'.format(err))
-        sys.exit()
-
-    rob = spec.evaluate(['req', req], ['gnt', gnt])
-
-    print('Robustness: {}'.format(rob))
-
-if __name__ == '__main__':
-    # Process arguments
-    monitor()
-```
-
-## Discrete-time Specifics
-
-### Working with time units and timing assumptions
-
-The default unit in RTAMT is seconds, and the default expected period between two consecutive input samples is `1s` with `10%` tolerance.  
-The following program uses these default values to implicitely set up the monitor.  
-The specification intuitively states that whenever the `req` is above `3`, eventually within `5s` `gnt` also goes above `3`.  
-The user feeds the monitor with values timestamped _exactly_ `1s` apart from each other. It follows that the periodic sampling assumption holds.
-
-RTAMT counts how many times the periodic sampling assumption has been violated up to the moment of being invoked via the `sampling_violation_counter` member.  
-In this example, this violation obviously occurs `0` times.
-
-```python
-# examples/documentation/time_units_1.py
-import sys
-import rtamt
-
-def monitor():
-    spec = rtamt.STLDiscreteTimeSpecification()
-    spec.name = 'Bounded-response Request-Grant'
-
-    spec.declare_var('req', 'float')
-    spec.declare_var('gnt', 'float')
-    spec.declare_var('out', 'float')
-
-    spec.spec = 'out = always((req>=3) implies (eventually[0:5](gnt>=3)))'
-
-    try:
-        spec.parse()
-        spec.update(0, [('req', 0.1), ('gnt', 0.3)])
-        spec.update(1, [('req', 0.45), ('gnt', 0.12)])
-        spec.update(2, [('req', 0.78), ('gnt', 0.18)])
-        nb_violations = spec.sampling_violation_counter // nb_violations = 0
-    except rtamt.STLParseException as err:
-        print('STL Parse Exception: {}'.format(err))
-        sys.exit()
-
-if __name__ == '__main__':
-    # Process arguments
-    monitor()
-}
-```
-
-The same program, but with slightly different timestamps still reports `0` number of periodic sampling assumption violations. This is because the difference between all consecutive sampling timestamps remains within the (implicitely) specified `10%` tolerance.
-
-```python
-# examples/documentation/time_units_2.py
-    ...
-    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
-    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])
-    spec.update(1.98, [('req', 0.78), ('gnt', 0.18)])
-    nb_violations = spec.sampling_violation_counter // nb_violations = 0
-    ....
-```
-
-On the other hand, the following sequence of inputs results in `1` reported violation of periodic sampling assumption.
-This is because the third input is `1.12s` away from the second sample, which is `12%` above the assumed `1s` period.
-
-```python
-# examples/documentation/time_units_3.py
-    ...
-    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
-    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])
-    spec.update(2.14, [('req', 0.78), ('gnt', 0.18)])
-    nb_violations = spec.sampling_violation_counter // nb_violations = 1
-```
-
-This same sequence of inputs results in `0` reported violation of periodic sampling assumption if we explicitely set the sampling period tolerance value to `20%`.  
-
-```python
-# examples/documentation/time_units_4.py
-    ...
-    spec.set_sampling_period(1, 's', 0.2)
-    ...
-    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
-    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])
-    spec.update(2.14, [('req', 0.78), ('gnt', 0.18)])
-    nb_violations = spec.sampling_violation_counter // nb_violations = 0
-```
-
-The user can also explicitely set the default unit, as well as the expected period and tolerance. In that case, the user must ensure that the timing bounds declared in the specification are divisible by the sampling period. The following specification is correct, since the sampling period is set to `500ms`, the default unit is set to seconds, and the specification implicitely defines the bound from `0.5s = 500ms` and `1.5s = 1500ms`, i.e. between `1` amd `3` sampling periods.
-
-```python
-# examples/documentation/time_units_5.py
-    ...
-    spec.unit = 's'
-    spec.set_sampling_period(500, 'ms', 0.1)
-    ...
-    spec.spec = 'out = always((req>=3) implies (eventually[0.5:1.5](gnt>=3)))'
-    ...
-    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
-    spec.update(0.5, [('req', 0.45), ('gnt', 0.12)])
-    spec.update(1, [('req', 0.78), ('gnt', 0.18)])
-    nb_violations = spec.sampling_violation_counter // nb_violations = 0
-}
-```
-
-The following defines the same program, but now with `ms` as the default unit.
-
-```python
- # examples/documentation/time_units_6.py
-    ...
-    spec.unit = 'ms'
-    spec.set_sampling_period(500, 'ms', 0.1)
-    ...
-    spec.spec = 'out = always((req>=3) implies (eventually[500:1500](gnt>=3)))'
-    ...
-    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
-    spec.update(500, [('req', 0.45), ('gnt', 0.12)])
-    spec.update(1000, [('req', 0.78), ('gnt', 0.18)])
-    nb_violations = spec.sampling_violation_counter // nb_violations = 0
-}
-```
-
-The following program throws an exception - the temporal bound is defined between `500ms` and `1500ms`, while the sampling period equals to `1s = 1000ms`.
-
-```python
-# examples/documentation/time_units_7.py
-    ...
-    spec.unit = 'ms'
-    spec.set_sampling_period(1, 's', 0.1)
-    ...
-    spec.spec = 'out = always((req>=3) implies (eventually[500:1500](gnt>=3)))'
-    ...
-    spec.parse()
-    ...
-    
-}
-```
-
-Finally, the following program is correct, because the temporal bound is explicitely defined between `500s` and `1500s`, while the sampling period equals to `1s`.
-
-```python
-# examples/documentation/time_units_8.py
-    ...
-    spec.unit = 'ms'
-    spec.set_sampling_period(1, 's', 0.1)
-    ...
-    spec.spec = 'out = always((req>=3) implies (eventually[500s:1500s](gnt>=3)))'
-    ...
-    spec.parse()
-    ...
-```
-
-# References
-
-- [1] Dejan Nickovic, Tomoya Yamaguchi: RTAMT: Online Robustness Monitors from STL. CoRR abs/2005.11827 (2020)
-- [2] Stefan Jaksic, Ezio Bartocci, Radu Grosu, Reinhard Kloibhofer, Thang Nguyen, Dejan Nickovic: From signal temporal logic to FPGA monitors. MEMOCODE 2015: 218-227
-- [3] Thomas Ferrre, Dejan Nickovic, Alexandre Donz, Hisahiro Ito, James Kapinski: Interface-aware signal temporal logic. HSCC 2019: 57-66
-- [4] Thomas A. Henzinger, Zohar Manna, Amir Pnueli: What Good Are Digital Clocks? ICALP 1992: 545-558
+Metadata-Version: 2.1
+Name: rtamt
+Version: 0.3.5
+Summary: Library for specification-based online monitoring.
+Home-page: https://github.com/nickovic/rtamt
+Author: Nickovic Dejan, Tomoya Yamaguchi
+Author-email: dejan.nickovic@ait.ac.at, tomoya.yamaguchi@toyota.com
+License: BSD
+Classifier: License :: OSI Approved :: BSD License
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: C++
+Requires-Python: >=2.7
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
+**Table of Contents**
+
+- [About](#about)
+- [Installation](#installation)
+  - [Install prerequisites for RTAMT installation](#install-prerequisites-for-rtamt-installation)
+  - [Option 1: Install Python package version](#option-1-install-python-package-version)
+  - [Option 2: Build the tool](#option-2-build-the-tool)
+    - [Clone the repository](#clone-the-repository)
+    - [Build CPP libraries](#build-cpp-libraries)
+    - [Install RTAMT](#install-rtamt)
+    - [uninstall RTAMT](#uninstall-rtamt)
+  - [test RTAMT](#test-rtamt)
+- [Theory](#theory)
+  - [Specification Language](#specification-language)
+- [Usage](#usage)
+  - [Example Usage](#example-usage)
+    - [Discrete-time online monitor](#discrete-time-online-monitor)
+    - [Dense-time online monitor](#dense-time-online-monitor)
+  - [Dense-time Offline Monitor](#dense-time-offline-monitor)
+  - [Discrete-time Specifics](#discrete-time-specifics)
+    - [Working with time units and timing assumptions](#working-with-time-units-and-timing-assumptions)
+- [References](#references)
+
+<!-- markdown-toc end -->
+
+# About
+
+RTAMT is a Python (2- and 3-compatible) library for monitoring of Signal Temporal Logic (STL).
+The library implements algorithms offline and online monitoring of discrete-time and dense-time STL.
+The online monitors support the bounded future fragment of STL.
+The online discrete-time part of the library has an optimized C++ back-end.
+
+# Installation
+
+## Install prerequisites for RTAMT installation
+
+```bash
+sudo apt install libboost-all-dev
+sudo apt install python-dev
+sudo apt install python-pip
+```
+
+If your want to extend the specification language, you may need the ANTLR4 parser generator.
+
+```bash
+sudo apt install antlr4
+```
+
+You will also need CMake version 3.12 or higher if you need to build the CPP backend.
+
+```bash
+sudo apt install cmake
+```
+
+In our experience, Ubuntu 16.04, 18.04 don't support the versions in default. You can check [our manual intallation of cmake](README_cmake.md).
+
+## Option 1: Install Python package version
+
+We provide Python package version of RTAMT.
+
+for Python 2
+
+```bash
+sudo pip2 install rtamt
+```
+
+for Python 3
+
+```bash
+sudo pip3 install rtamt
+```
+
+## Option 2: Build the tool
+
+### Clone the repository
+
+```bash
+git clone https://github.com/nickovic/rtamt
+```
+
+### Build CPP libraries
+
+This step is needed only if you want to use the CPP backend and
+can be skipped if you want to use pure Python monitors.
+
+for Python 2
+
+```bash
+cd rtamt/rtamt
+mkdir build
+cd build
+cmake -DPythonVersion=2 ../
+make
+```
+
+for Python 3
+
+```bash
+cd rtamt/rtamt
+mkdir build
+cd build
+cmake -DPythonVersion=3 ../
+make
+```
+
+### Install RTAMT
+
+for Python 2
+
+```bash
+cd rtamt/
+sudo pip2 install .
+```
+
+for Python 3
+
+```bash
+cd rtamt/
+sudo pip3 install .
+```
+
+### uninstall RTAMT
+
+for Python 2
+
+```bash
+sudo pip2 uninstall rtamt
+```
+
+for Python 3
+
+```bash
+sudo pip3 uninstall rtamt
+```
+
+## test RTAMT
+
+for Python 2
+
+```bash
+cd rtamt/
+python2 -m unittest discover tests/
+```
+
+for Python 3
+
+```bash
+cd rtamt/
+python3 -m unittest discover tests/
+```
+
+# Theory
+
+RTAMT is a Python library for offline and online monitoring of (bounded-future)  
+Signal Temporal Logic (STL). The library is inspired by several theoretical and practical  
+works:
+
+- The bounded-future fragment of STL is inspired by [2]
+- The interface-aware interpretation of STL quantitative semantics is inspired by [3]
+- The periodic-sampling interpretation of specifications (even in presence of timestamps that are not prefectly periodic) is inpired by [4]
+- The translation of bounded-future STL to "equirobust" past STL prior to the online monitoring phase is inspired by [2]
+
+## Specification Language
+
+RTAMT supports Signal Temporal Logic (STL) and interface-aware STL (IA-STL).
+
+The library supports a variant of STL with past and future temporal operators as well as basic arithmetic and absolute value operators.  
+Semantics of STL is defined in terms of a robustness degree `rho(phi,w,t)`, a function defined over real numbers extended with `+inf` and `-inf` that takes as input an STL specification `phi`, an input signal `w` and time index `t`, and computes how far is the signal `w` at time `t` from satisfying/violating `phi`. The robustness degree function is defined inductively as follows (`c` is a real constant, `x` is a variable, `w_x(t)` denotes the value of `w` projected to `x` at time `t`, `a,b` are rational constants such that `0 <= a <= b` and `|w|` is the length of `w`):
+
+```txt
+% Constant
+rho(c,w,t) = c
+
+% Variable
+rho(x,w,t) = w_x(t)
+
+% Absolute value, exponentials
+rho(abs(phi),w,t) = |rho(phi,w,t)|
+rho(exp(phi),w,t) = e**rho(phi,w,t)
+rho(pow(phi1, phi2),w,t) = rho(phi1,w,t)**rho(phi2,w,t)
+
+% Arithmetic operators
+rho(phi + psi,w,t) = rho(phi,w,t) + rho(psi,w,t)
+rho(phi - psi,w,t) = rho(phi,w,t) - rho(psi,w,t)
+rho(phi * psi,w,t) = rho(phi,w,t) * rho(psi,w,t)
+rho(phi / psi,w,t) = rho(phi,w,t) / rho(psi,w,t)
+
+% Numeric predicates
+rho(phi <= psi,w,t) = rho(psi,w,t) - rho(phi,w,t) 
+rho(phi < psi,w,t) = rho(psi,w,t) - rho(phi,w,t)
+rho(phi >= psi,w,t) = rho(phi,w,t) - rho(psi,w,t)
+rho(phi > psi,w,t) = rho(phi,w,t) - rho(psi,w,t)
+rho(phi == psi,w,t) = -|rho(phi,w,t) - rho(psi,w,t)|
+rho(phi !== psi,w,t) = |rho(phi,w,t) - rho(psi,w,t)|
+
+% Boolean operators
+rho(not(phi),w,t) = -rho(phi,w,t)
+rho(phi or psi,w,t) = max(rho(phi,w,t),rho(psi,w,t))
+rho(phi and psi,w,t) = min(rho(phi,w,t),rho(psi,w,t))
+rho(phi -> psi,w,t) = max(-rho(phi,w,t),rho(psi,w,t))
+rho(phi <-> psi,w,t) = -|rho(phi,w,t) - rho(psi,w,t)|
+rho(phi xor psi,w,t) = |rho(phi,w,t) - rho(psi,w,t)|
+
+% Events
+rho(rise(phi),w,t) = rho(phi,w,t)                     if t=0
+                     min(-rho(phi,w,t-1),rho(phi,w,t) otherwise
+rho(fall(phi),w,t) = -rho(phi,w,t)                    if t=0
+                     min(rho(phi,w,t-1),-rho(phi,w,t) otherwise
+
+% Past untimed temporal operators
+rho(prev phi,w,t) = -inf            if t<=0
+                    rho(phi,w,t-1) otherwise
+rho(once phi,w,t) = max_{t' in [0,t]} rho(phi,w,t')
+rho(historically phi,w,t) = min_{t' in [0,t]} rho(phi,w,t')
+rho(phi since psi,w,t) = max_{t' in [0,t]}(min(rho(psi,w,t'), min_{t'' in (t',t]} rho(phi,w,t'')))
+
+% Past timed temporal operators
+rho(once[a,b] phi,w,t) = -inf                                                            if t-a < 0
+                         max_{t' in ([0,t] intersect [t-a,t-b])} rho(phi,w,t')           otherwise
+rho(historically[a,b] phi,w,t) = inf                                                     if t-a < 0
+                                 min_{t' in ([0,t] intersect [t-a,t-b])} rho(phi,w,t')   otherwise
+rho(phi since[a,b] psi,w,t) = -inf                                                       if t-a < 0 
+                              max_{t' in ([0,t] intersect [t-a,t-b]} (min(rho(psi,w,t'), 
+                              min_{t'' in (t',t]} rho(phi,w,t'')))          otherwise
+
+% Future untimed temporal operators
+rho(next phi,w,t) = rho(phi,w,t+1)
+rho(eventually phi,w,t) = max_{t' in [t,|w|]} rho(phi,w,t')
+rho(always phi,w,t) = min_{t' in [t, |w|]} rho(phi,w,t')
+rho(phi until psi,w,t) = max_{t' in [t,|w|] min(rho(psi,w,t'), 
+                              min_{t'' in [t,t')}rho(psi,w,t') rho(phi,w,t'')))         otherwise
+
+
+% Future timed temporal operators
+rho(eventually[a,b] phi,w,t) = -inf                                                     if t+a >= |w|
+                               max_{t' in ([0,t] intersect [t+a,t+b])} rho(phi,w,t')    otherwise
+rho(always[a,b] phi,w,t) = inf                                                          if t+a >= |w|
+                           min_{t' in ([0,t] intersect [t+a,t+b])} rho(phi,w,t')        otherwise
+rho(phi until[a,b] psi,w,t) = -inf                                                      if t+a >= |w|
+                              max_{t' in ([0,t] intersect [t+a,t+b]}(min(rho(psi,w,t'), 
+                              min_{t'' in [t,t')}rho(psi,w,t') rho(phi,w,t'')))         otherwise   
+```
+
+We define the robustness degree `rho(phi,w)` as `rho(phi,w,0)`.
+
+There are several important points to note about the above syntax and semantics:
+
+- In the online monitoring mode, the library allows only bounded-future STL specifications, meaning that _unbounded_ future operators `always` `eventually` and `until` cannot appear in the specification.  
+- The `prev` and `next` operators are valid only under the discrete-time interpretation of STL
+- The `unless` operator is added as syntactic sugar - `phi unless[a,b] psi = always[0,b] phi or phi until[a,b] psi
+
+We can see from the semantics of bounded-future STL that the direct evaluation of a formula `phi` at time `t` may depend on inputs at `t'>t` that have not arrived yet.
+The library monitors bounded-future STL formulas with a fixed _delay_. In order to compute `rho(phi,w,t)`, the monitor waits for all inputs required to evaluate `phi` to become available before computing the robustness degree. This delay is fixed and depends on the specification. For instance, the specification `always((req >= 3) -> eventually[0:2]always[0:3](gnt >= 3)`is evaluated with delay `5` - the time needed to capture all inputs required for evaluating bounded `eventually` and `always` operators. We refer the reader to [2] for algorithmic details regarding monitoring with delay.
+
+# Usage
+
+The API provides two monitoring classes:
+
+- `StlDiscreteTimeSpecification` for discrete-time monitors
+- `StlDenseTimeSpecification` for dense-time monitors
+
+Both classes implement online and offline monitors:
+
+- `update` method is used for online evaluation
+. `evaluate` method is used for offline evaluation
+
+## Example Usage
+
+### Discrete-time online monitor
+
+```python
+import sys
+import rtamt
+
+def monitor():
+    # # stl
+    spec = rtamt.StlDiscreteTimeSpecification()
+    spec.declare_var('a', 'float')
+    spec.declare_var('b', 'float')
+    spec.spec = 'eventually[0,1] (a >= b)'
+
+    try:
+        spec.parse()
+        spec.pastify()
+    except rtamt.RTAMTException as err:
+        print('RTAMT Exception: {}'.format(err))
+        sys.exit()
+
+    rob = spec.update(0, [('a', 100.0), ('b', 20.0)])
+    print('time=' + str(0) + ' rob=' + str(rob))
+
+    rob = spec.update(1, [('a', -1.0), ('b', 2.0)])
+    print('time=' + str(0) + ' rob=' + str(rob))
+
+    rob = spec.update(2, [('a', -2.0), ('b', -10.0)])
+    print('time=' + str(0) + ' rob=' + str(rob))
+
+if __name__ == '__main__':
+    monitor()
+```
+
+### Dense-time online monitor
+
+```python
+import sys
+import rtamt
+
+def monitor():
+    a1 = [(0, 3), (3, 2)]
+    b1 = [(0, 2), (2, 5), (4, 1), (7, -7)]
+
+    a2 = [(5, 6), (6, -2), (8, 7), (11, -1)]
+    b2 = [(10, 4)]
+
+    a3 = [(13, -6), (15, 0)]
+    b3 = [(15, 0)]
+
+    # # stl
+    spec = rtamt.StlDenseTimeSpecification()
+    spec.name = 'STL dense-time specification'
+    spec.declare_var('a', 'float')
+    spec.spec = 'a>=2'
+    try:
+        spec.parse()
+    except rtamt.RTAMTException as err:
+        print('RTAMT Exception: {}'.format(err))
+        sys.exit()
+
+    rob = spec.update(['a', a1], ['b', b1])
+    print('rob: ' + str(rob))
+
+    rob = spec.update(['a', a2], ['b', b2])
+    print('rob: ' + str(rob))
+
+    rob = spec.update(['a', a3], ['b', b3])
+    print('rob: ' + str(rob))
+
+if __name__ == '__main__':
+    monitor()
+```
+
+## Dense-time Offline Monitor
+
+```python
+import sys
+import rtamt
+
+def monitor():
+
+    req = [[0.0, 0.0], [3.0, 6.0], [5.0, 0.0], [11.0, 0.0]]
+    gnt = [[0.0, 0.0], [7.0, 6.0], [9.0, 0.0], [11.0, 0.0]]
+    
+    spec = rtamt.StlDenseTimeSpecification()
+    spec.name = 'STL Dense-time Offline Monitor'
+    spec.declare_var('req', 'float')
+    spec.declare_var('gnt', 'float')
+    spec.declare_var('out', 'float')
+    spec.set_var_io_type('req', 'input')
+    spec.set_var_io_type('gnt', 'output')
+    spec.spec = 'out = always((req>=3) implies (eventually[0:5](gnt>=3)))'
+    try:
+        spec.parse()
+    except rtamt.RTAMTException as err:
+        print('RTAMT Exception: {}'.format(err))
+        sys.exit()
+
+    rob = spec.evaluate(['req', req], ['gnt', gnt])
+
+    print('Robustness: {}'.format(rob))
+
+if __name__ == '__main__':
+    # Process arguments
+    monitor()
+```
+
+## Discrete-time Specifics
+
+### Working with time units and timing assumptions
+
+The default unit in RTAMT is seconds, and the default expected period between two consecutive input samples is `1s` with `10%` tolerance.  
+The following program uses these default values to implicitely set up the monitor.  
+The specification intuitively states that whenever the `req` is above `3`, eventually within `5s` `gnt` also goes above `3`.  
+The user feeds the monitor with values timestamped _exactly_ `1s` apart from each other. It follows that the periodic sampling assumption holds.
+
+RTAMT counts how many times the periodic sampling assumption has been violated up to the moment of being invoked via the `sampling_violation_counter` member.  
+In this example, this violation obviously occurs `0` times.
+
+```python
+# examples/documentation/time_units_1.py
+import sys
+import rtamt
+
+def monitor():
+    spec = rtamt.StlDiscreteTimeSpecification()
+    spec.name = 'Bounded-response Request-Grant'
+
+    spec.declare_var('req', 'float')
+    spec.declare_var('gnt', 'float')
+    spec.declare_var('out', 'float')
+
+    spec.spec = 'out = (req>=3) implies (eventually[0:5](gnt>=3))'
+
+    try:
+        spec.parse()
+        spec.update(0, [('req', 0.1), ('gnt', 0.3)])
+        spec.update(1, [('req', 0.45), ('gnt', 0.12)])
+        spec.update(2, [('req', 0.78), ('gnt', 0.18)])
+        nb_violations = spec.sampling_violation_counter // nb_violations = 0
+    except rtamt.RTAMTException as err:
+        print('RTAMT Exception: {}'.format(err))
+        sys.exit()
+
+if __name__ == '__main__':
+    # Process arguments
+    monitor()
+}
+```
+
+The same program, but with slightly different timestamps still reports `0` number of periodic sampling assumption violations. This is because the difference between all consecutive sampling timestamps remains within the (implicitely) specified `10%` tolerance.
+
+```python
+# examples/documentation/time_units_2.py
+    ...
+    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
+    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])
+    spec.update(1.98, [('req', 0.78), ('gnt', 0.18)])
+    nb_violations = spec.sampling_violation_counter // nb_violations = 0
+    ....
+```
+
+On the other hand, the following sequence of inputs results in `1` reported violation of periodic sampling assumption.
+This is because the third input is `1.12s` away from the second sample, which is `12%` above the assumed `1s` period.
+
+```python
+# examples/documentation/time_units_3.py
+    ...
+    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
+    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])
+    spec.update(2.14, [('req', 0.78), ('gnt', 0.18)])
+    nb_violations = spec.sampling_violation_counter // nb_violations = 1
+```
+
+This same sequence of inputs results in `0` reported violation of periodic sampling assumption if we explicitely set the sampling period tolerance value to `20%`.  
+
+```python
+# examples/documentation/time_units_4.py
+    ...
+    spec.set_sampling_period(1, 's', 0.2)
+    ...
+    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
+    spec.update(1.02, [('req', 0.45), ('gnt', 0.12)])
+    spec.update(2.14, [('req', 0.78), ('gnt', 0.18)])
+    nb_violations = spec.sampling_violation_counter // nb_violations = 0
+```
+
+The user can also explicitely set the default unit, as well as the expected period and tolerance. In that case, the user must ensure that the timing bounds declared in the specification are divisible by the sampling period. The following specification is correct, since the sampling period is set to `500ms`, the default unit is set to seconds, and the specification implicitely defines the bound from `0.5s = 500ms` and `1.5s = 1500ms`, i.e. between `1` amd `3` sampling periods.
+
+```python
+# examples/documentation/time_units_5.py
+    ...
+    spec.unit = 's'
+    spec.set_sampling_period(500, 'ms', 0.1)
+    ...
+    spec.spec = 'out = (req>=3) implies (eventually[0.5:1.5](gnt>=3))'
+    ...
+    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
+    spec.update(0.5, [('req', 0.45), ('gnt', 0.12)])
+    spec.update(1, [('req', 0.78), ('gnt', 0.18)])
+    nb_violations = spec.sampling_violation_counter // nb_violations = 0
+}
+```
+
+The following defines the same program, but now with `ms` as the default unit.
+
+```python
+ # examples/documentation/time_units_6.py
+    ...
+    spec.unit = 'ms'
+    spec.set_sampling_period(500, 'ms', 0.1)
+    ...
+    spec.spec = 'out = (req>=3) implies (eventually[500:1500](gnt>=3))'
+    ...
+    spec.update(0, [('req', 0.1), ('gnt', 0.3)])
+    spec.update(500, [('req', 0.45), ('gnt', 0.12)])
+    spec.update(1000, [('req', 0.78), ('gnt', 0.18)])
+    nb_violations = spec.sampling_violation_counter // nb_violations = 0
+}
+```
+
+The following program throws an exception - the temporal bound is defined between `500ms` and `1500ms`, while the sampling period equals to `1s = 1000ms`.
+
+```python
+# examples/documentation/time_units_7.py
+    ...
+    spec.unit = 'ms'
+    spec.set_sampling_period(1, 's', 0.1)
+    ...
+    spec.spec = 'out = always((req>=3) implies (eventually[500:1500](gnt>=3)))'
+    ...
+    spec.parse()
+    ...
+    
+}
+```
+
+Finally, the following program is correct, because the temporal bound is explicitely defined between `500s` and `1500s`, while the sampling period equals to `1s`.
+
+```python
+# examples/documentation/time_units_8.py
+    ...
+    spec.unit = 'ms'
+    spec.set_sampling_period(1, 's', 0.1)
+    ...
+    spec.spec = 'out = always((req>=3) implies (eventually[500s:1500s](gnt>=3)))'
+    ...
+    spec.parse()
+    ...
+```
+
+# References
+
+- [1] Dejan Nickovic, Tomoya Yamaguchi: RTAMT: Online Robustness Monitors from STL. CoRR abs/2005.11827 (2020)
+- [2] Stefan Jaksic, Ezio Bartocci, Radu Grosu, Reinhard Kloibhofer, Thang Nguyen, Dejan Nickovic: From signal temporal logic to FPGA monitors. MEMOCODE 2015: 218-227
+- [3] Thomas Ferrre, Dejan Nickovic, Alexandre Donz, Hisahiro Ito, James Kapinski: Interface-aware signal temporal logic. HSCC 2019: 57-66
+- [4] Thomas A. Henzinger, Zohar Manna, Amir Pnueli: What Good Are Digital Clocks? ICALP 1992: 545-558
```

### Comparing `rtamt-0.3/rtamt/enumerations/comp_op.py` & `rtamt-0.3.5/rtamt/semantics/enumerations/comp_op.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Sun Jul 21 22:39:19 2019
-
-@author: NickovicD
-"""
-from enum import Enum
-
-class StlComparisonOperator(Enum):
-    LESS = 0
-    LEQ = 1
-    EQUAL = 2
-    NEQ = 3
-    GREATER = 4
-    GEQ = 5
-
-    def __str__(self):
-        if self.value == 0:
-            return '<'
-        elif self.value == 1:
-            return '<='
-        elif self.value == 2:
-            return '=='
-        elif self.value == 3:
-            return '!='
-        elif self.value == 4:
-            return '>'
-        else:
+# -*- coding: utf-8 -*-
+"""
+Created on Sun Jul 21 22:39:19 2019
+
+@author: NickovicD
+"""
+from enum import Enum
+
+class StlComparisonOperator(Enum):
+    LESS = 0
+    LEQ = 1
+    EQUAL = 2
+    NEQ = 3
+    GREATER = 4
+    GEQ = 5
+
+    def __str__(self):
+        if self.value == 0:
+            return '<'
+        elif self.value == 1:
+            return '<='
+        elif self.value == 2:
+            return '=='
+        elif self.value == 3:
+            return '!='
+        elif self.value == 4:
+            return '>'
+        else:
             return '>='
```

### Comparing `rtamt-0.3/rtamt/enumerations/options.py` & `rtamt-0.3.5/rtamt/semantics/enumerations/options.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from enum import Enum
-
-class Semantics(Enum):
-    STANDARD = "standard"
-    OUTPUT_ROBUSTNESS = "output-robustness"
-    INPUT_VACUITY = "input-vacuity"
-    INPUT_ROBUSTNESS = "input-robustness"
-    OUTPUT_VACUITY = "output-vacuity"
-
-    def __str__(self):
-        return self.value
-
-class Language(Enum):
-    PYTHON = "python"
-    CPP = "C++"
-    def __str__(self):
-        return self.value
-
-class TimeInterpretation(Enum):
-    DISCRETE = "discrete_time"
-    DENSE = "dense-time"
-    def __str__(self):
+from enum import Enum
+
+class Semantics(Enum):
+    STANDARD = "standard"
+    OUTPUT_ROBUSTNESS = "output-robustness"
+    INPUT_VACUITY = "input-vacuity"
+    INPUT_ROBUSTNESS = "input-robustness"
+    OUTPUT_VACUITY = "output-vacuity"
+
+    def __str__(self):
+        return self.value
+
+class Language(Enum):
+    PYTHON = "python"
+    CPP = "C++"
+    def __str__(self):
+        return self.value
+
+class TimeInterpretation(Enum):
+    DISCRETE = "discrete_time"
+    DENSE = "dense-time"
+    def __str__(self):
         return self.value
```

### Comparing `rtamt-0.3/rtamt/interval/interval.py` & `rtamt-0.3.5/rtamt/semantics/interval/interval.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,46 +1,66 @@
-import logging
-
-class Interval(object):
-    """A class for storing integer intervals
-
-        Attributes
-        --------------
-        begin : int
-            beginning of the interval
-        end : int
-            end of the interval
-
-        Methods
-        --------------
-        begin, end
-            Getter for begin and end
-            The object is immutable - the setter issues a warning message and does nothing
-        """
-    def __init__(self, begin, end):
-        """Constructor for Interval
-        Parameters:
-            begin : int
-                Beginning of the interval
-            end : int
-                End of the interval
-        """
-        self.begin = begin
-        self.end = end
-
-    @property
-    def begin(self):
-        """Getter for begin"""
-        return self.__begin
-
-    @begin.setter
-    def begin(self, begin):
-        self.__begin = begin
-
-    @property
-    def end(self):
-        """Getter for end"""
-        return self.__end
-
-    @end.setter
-    def end(self, end):
-        self.__end = end
+import logging
+
+class Interval(object):
+    """A class for storing integer intervals
+
+        Attributes
+        --------------
+        begin : int
+            beginning of the interval
+        end : int
+            end of the interval
+
+        Methods
+        --------------
+        begin, end
+            Getter for begin and end
+            The object is immutable - the setter issues a warning message and does nothing
+        """
+    def __init__(self, begin, end, begin_unit="", end_unit=""):
+        """Constructor for Interval
+        Parameters:
+            begin : int
+                Beginning of the interval
+            end : int
+                End of the interval
+        """
+        self.begin = begin
+        self.end = end
+        self.begin_unit = begin_unit
+        self.end_unit = end_unit
+
+    @property
+    def begin(self):
+        """Getter for begin"""
+        return self.__begin
+
+    @begin.setter
+    def begin(self, begin):
+        self.__begin = begin
+
+    @property
+    def end(self):
+        """Getter for end"""
+        return self.__end
+
+    @end.setter
+    def end(self, end):
+        self.__end = end
+
+    @property
+    def begin_unit(self):
+        """Getter for begin_unit"""
+        return self.__begin_unit
+
+    @begin_unit.setter
+    def begin_unit(self, begin_unit):
+        self.__begin_unit = begin_unit
+
+    @property
+    def end_unit(self):
+        """Getter for end_unit"""
+        return self.__end_unit
+
+    @end_unit.setter
+    def end_unit(self, end_unit):
+        self.__end_unit = end_unit
```

### Comparing `rtamt-0.3/rtamt/node/arithmetic/abs.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/iff.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,27 +1,23 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Sun Jul 21 22:24:09 2019
-
-@author: NickovicD
-"""
-
-from rtamt.node.unary_node import UnaryNode
-
-class Abs(UnaryNode):
-    """A class for storing STL Neg nodes
-        Inherits Node
-    """
-    def __init__(self, child):
-        """Constructor for Neg node
-
-            Parameters:
-                child : stl.Node
-        """
-        super(Abs, self).__init__(child)
-
-        self.in_vars = child.in_vars
-        self.out_vars = child.out_vars
-
-        self.name = 'abs(' + child.name + ')'
-
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+
+class Iff(BinaryNode):
+    """A class for storing STL Iff nodes
+        Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Iff node
+
+        Parameters:
+            child1 : stl.Node
+            child2 : stl.Node
+        """
+        super(Iff, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')<->(' + child2.name + ')'
+
+
+
```

### Comparing `rtamt-0.3/rtamt/node/arithmetic/addition.py` & `rtamt-0.3.5/rtamt/syntax/node/arithmetic/addition.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Sun Jul 21 22:24:09 2019
-
-@author: NickovicD
-"""
-
-from rtamt.node.binary_node import BinaryNode
-
-
-class Addition(BinaryNode):
-    """A class for storing STL Conjunction nodes
-        Inherits TemporalNode
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Conjunction node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-        super(Addition, self).__init__(child1, child2)
-
-        self.add_child(child1)
-        self.add_child(child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')+(' + child2.name + ')'
-
+# -*- coding: utf-8 -*-
+"""
+Created on Sun Jul 21 22:24:09 2019
+
+@author: NickovicD
+"""
+
+from rtamt.syntax.node.binary_node import BinaryNode
+
+
+class Addition(BinaryNode):
+    """A class for storing STL Conjunction nodes
+        Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Conjunction node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+        """
+        super(Addition, self).__init__(child1, child2)
+
+        self.add_child(child1)
+        self.add_child(child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')+(' + child2.name + ')'
+
```

### Comparing `rtamt-0.3/rtamt/node/arithmetic/division.py` & `rtamt-0.3.5/rtamt/syntax/node/arithmetic/pow.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,22 +1,21 @@
-from rtamt.node.binary_node import BinaryNode
-
-
-class Division(BinaryNode):
-    """A class for storing STL Division nodes
-        Inherits Node
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Division node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-        super(Division, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')/(' + child2.name + ')'
-
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Pow(BinaryNode):
+    """A class for storing Pow nodes
+        Inherits Node
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Pow node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+        """
+        super(Pow, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = 'pow(' + child1.name + ',' + child2.name + ')'
+
+
```

### Comparing `rtamt-0.3/rtamt/node/arithmetic/multiplication.py` & `rtamt-0.3.5/rtamt/syntax/node/arithmetic/multiplication.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Multiplication(BinaryNode):
-    """A class for storing STL Multiplication nodes
-        Inherits Node
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Multiplication node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-        super(Multiplication, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')*(' + child2.name + ')'
-
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Multiplication(BinaryNode):
+    """A class for storing STL Multiplication nodes
+        Inherits Node
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Multiplication node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+        """
+        super(Multiplication, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')*(' + child2.name + ')'
+
+
```

### Comparing `rtamt-0.3/rtamt/node/arithmetic/pow.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/until.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Pow(BinaryNode):
-    """A class for storing Pow nodes
-        Inherits Node
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Pow node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-        super(Pow, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = 'pow(' + child1.name + ',' + child2.name + ')'
-
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Until(BinaryNode):
+    """
+    A class for storing STL Since nodes
+    Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Until node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+                bound : Interval
+        """
+        super(Until, self).__init__(child1, child2)
+
+        self.name = '(' + child1.name + ')until(' + child2.name + ')'
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
```

### Comparing `rtamt-0.3/rtamt/node/arithmetic/subtraction.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/since.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Subtraction(BinaryNode):
-    """A class for storing STL Subtraction nodes
-        Inherits Node
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Subtraction node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-        super(Subtraction, self).__init__(child1, child2)
-
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')-(' + child2.name + ')'
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Since(BinaryNode):
+    """A class for storing STL Since nodes
+                Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Since node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+        """
+
+        super(Since, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+        self.name = '(' + child1.name + ')since(' + child2.name + ')'
+
+
```

### Comparing `rtamt-0.3/rtamt/node/ltl/conjunction.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/implies.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,28 +1,22 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Sun Jul 21 22:24:09 2019
-
-@author: NickovicD
-"""
-
-from rtamt.node.binary_node import BinaryNode
-
-
-class Conjunction(BinaryNode):
-    """A class for storing STL Conjunction nodes
-        Inherits TemporalNode
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Conjunction node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-        super(Conjunction, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')and(' + child2.name + ')'
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Implies(BinaryNode):
+    """A class for storing STL Implies nodes
+        Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Implies node
+
+        Parameters:
+            child1 : stl.Node
+            child2 : stl.Node
+        """
+        super(Implies, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')->(' + child2.name + ')'
+
+
+
```

### Comparing `rtamt-0.3/rtamt/node/ltl/disjunction.py` & `rtamt-0.3.5/rtamt/syntax/node/arithmetic/division.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Disjunction(BinaryNode):
-    """A class for storing STL Or nodes
-        Inherits TemporalNode
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Or node
-
-        Parameters:
-            child1 : stl.Node
-            child2 : stl.Node
-        """
-        super(Disjunction, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')or(' + child2.name + ')'
-
-
-
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+
+class Division(BinaryNode):
+    """A class for storing STL Division nodes
+        Inherits Node
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Division node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+        """
+        super(Division, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')/(' + child2.name + ')'
+
+
```

### Comparing `rtamt-0.3/rtamt/node/ltl/iff.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/disjunction.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from rtamt.node.binary_node import BinaryNode
-
-
-class Iff(BinaryNode):
-    """A class for storing STL Iff nodes
-        Inherits TemporalNode
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Iff node
-
-        Parameters:
-            child1 : stl.Node
-            child2 : stl.Node
-        """
-        super(Iff, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')<->(' + child2.name + ')'
-
-
-
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Disjunction(BinaryNode):
+    """A class for storing STL Or nodes
+        Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Or node
+
+        Parameters:
+            child1 : stl.Node
+            child2 : stl.Node
+        """
+        super(Disjunction, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')or(' + child2.name + ')'
+
+
+
+
```

### Comparing `rtamt-0.3/rtamt/node/ltl/predicate.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/predicate.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Predicate(BinaryNode):
-    """A class for storing STL real-valued Variable nodes
-                Inherits Node
-
-    Attributes:
-        child1 : Node
-        child2 : Node
-        operator : OperatorType (LEQ, GEQ, LESS, GREATER, EQ or NEQ)
-    """
-    def __init__(self, child1, child2, operator):
-        """Constructor for Predicate node
-
-        Parameters:
-            var : String
-            field : String
-            io_type : IOType enumeration (INPUT, OUTPUT or UNKNOWN)
-            operator : OperatorType (LEQ, GEQ, LESS, GREATER, EQ or NEQ)
-        """
-
-        super(Predicate, self).__init__(child1, child2)
-        self.operator = operator
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
-        self.name = '(' + child1.name + ')' + str(self.operator) + '(' + child2.name + ')'
-
-
-        
-    @property
-    def operator(self):
-        """Getter for operator"""
-        return self.__operator
-    
-    @operator.setter
-    def operator(self, operator):
-        """Setter for operator"""
-        self.__operator = operator
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class Predicate(BinaryNode):
+    """A class for storing STL real-valued Variable nodes
+                Inherits Node
+
+    Attributes:
+        child1 : Node
+        child2 : Node
+        operator : OperatorType (LEQ, GEQ, LESS, GREATER, EQ or NEQ)
+    """
+    def __init__(self, child1, child2, operator):
+        """Constructor for Predicate node
+
+        Parameters:
+            var : String
+            field : String
+            io_type : IOType enumeration (INPUT, OUTPUT or UNKNOWN)
+            operator : OperatorType (LEQ, GEQ, LESS, GREATER, EQ or NEQ)
+        """
+
+        super(Predicate, self).__init__(child1, child2)
+        self.operator = operator
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')' + str(self.operator) + '(' + child2.name + ')'
+
+
+        
+    @property
+    def operator(self):
+        """Getter for operator"""
+        return self.__operator
+    
+    @operator.setter
+    def operator(self, operator):
+        """Setter for operator"""
+        self.__operator = operator
```

### Comparing `rtamt-0.3/rtamt/node/ltl/since.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/xor.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,25 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Since(BinaryNode):
-    """A class for storing STL Since nodes
-                Inherits TemporalNode
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Since node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-        """
-
-        super(Since, self).__init__(child1, child2)
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-        self.name = '(' + child1.name + ')since(' + child2.name + ')'
-
-
+# -*- coding: utf-8 -*-
+"""
+Created on Sun Jul 21 22:24:09 2019
+
+@author: NickovicD
+"""
+from rtamt.syntax.node.binary_node import BinaryNode
+
+
+class Xor(BinaryNode):
+    """A class for storing STL Xor nodes
+        Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Xor node
+
+        Parameters:
+            child1 : stl.Node
+            child2 : stl.Node
+        """
+        super(BinaryNode, self).__init__()
+        self.add_child(child1)
+        self.add_child(child2)
+
+        self.name = '(' + child1.name + ')xor(' + child2.name + ')'
```

### Comparing `rtamt-0.3/rtamt/node/ltl/until.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/conjunction.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-from rtamt.node.binary_node import BinaryNode
-
-class Until(BinaryNode):
-    """
-    A class for storing STL Since nodes
-    Inherits TemporalNode
-    """
-    def __init__(self, child1, child2):
-        """Constructor for Until node
-
-            Parameters:
-                child1 : stl.Node
-                child2 : stl.Node
-                bound : Interval
-        """
-        super(Until, self).__init__(child1, child2)
-
-        self.name = '(' + child1.name + ')until(' + child2.name + ')'
-
-        self.in_vars = child1.in_vars + child2.in_vars
-        self.out_vars = child1.out_vars + child2.out_vars
-
+# -*- coding: utf-8 -*-
+"""
+Created on Sun Jul 21 22:24:09 2019
+
+@author: NickovicD
+"""
+
+from rtamt.syntax.node.binary_node import BinaryNode
+
+
+class Conjunction(BinaryNode):
+    """A class for storing STL Conjunction nodes
+        Inherits TemporalNode
+    """
+    def __init__(self, child1, child2):
+        """Constructor for Conjunction node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+        """
+        super(Conjunction, self).__init__(child1, child2)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')and(' + child2.name + ')'
+
```

### Comparing `rtamt-0.3/rtamt/node/node.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/variable.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,74 +1,59 @@
-from rtamt.node.abstract_node import AbstractNode
-
-class Node(AbstractNode):
-    """A class for storing STL nodes
-    Attributes
-    --------------
-    horizon : int
-        integer denoting how much in the future the underlying formula must look
-
-    Methods
-    --------------
-    horizon
-        Getter and setter for horizon
-    """
-
-    def __init__(self):
-        """Constructor for Node"""
-        self.in_vars = []
-        self.out_vars = []
-        self.children = list()
-        self.name = ''
-
-    @property
-    def children(self):
-        return self.__children
-
-    @children.setter
-    def children(self, children):
-        self.__children = children
-
-    @property
-    def in_vars(self):
-        """Getter for the in_vars"""
-        return self.__in_vars
-
-    @in_vars.setter
-    def in_vars(self, in_vars):
-        """Setter for the in_vars"""
-        self.__in_vars = in_vars
-
-    @property
-    def out_vars(self):
-        """Getter for the out_vars"""
-        return self.__out_vars
-
-    @out_vars.setter
-    def out_vars(self, out_vars):
-        """Setter for the out_vars"""
-        self.__out_vars = out_vars
-
-    def add_child(self, child):
-        self.children.append(child)
-
-    def accept(self, visitor):
-        """accept: recursive function needed to implement node visitors
-        Inputs:
-        visitor - Visitor object
-        """
-        for child in self.children:
-            child.accept(visitor)
-
-    @property
-    def name(self):
-        """Getter for the name"""
-        return self.__name
-
-    @name.setter
-    def name(self, name):
-        """Setter for the name"""
-        self.__name = name
-
-    def __repr__(self):
-        '''Returns representation of the object'''
-        return self.__class__.__name__
+from rtamt.syntax.node.leaf_node import LeafNode
+from rtamt.semantics.enumerations.io_type import StlIOType
+class Variable(LeafNode):
+    """A class for storing STL real-valued Variable nodes
+            Inherits Node
+        """
+    def __init__(self, var, field=None, iotype='output'):
+        """Constructor for Variable node
+
+        Parameters:
+            var : String
+            field : String
+        """
+
+        super(Variable, self).__init__()
+        self.var = var
+        self.field = field
+        self.io_type = iotype
+        self.node = None
+
+        if (iotype == 'input'):
+            self.in_vars = [var]
+        else:
+            self.out_vars = [var]
+
+        if not self.field:
+            self.name = self.var
+        else:
+            self.name = self.var + '.' + self.field
+
+    @property
+    def var(self):
+        """Getter for var"""
+        return self.__var
+    
+    @var.setter
+    def var(self, var):
+        """Setter for var"""
+        self.__var = var
+
+    @property
+    def field(self):
+        """Getter for field"""
+        return self.__field
+
+    @field.setter
+    def field(self, field):
+        """Setter for field"""
+        self.__field = field
+
+    @property
+    def io_type(self):
+        """Getter for io_type"""
+        return self.__io_type
+
+    @io_type.setter
+    def io_type(self, io_type):
+        """Setter for io_type"""
+        self.__io_type = io_type
```

### Comparing `rtamt-0.3/rtamt/node/stl/timed_always.py` & `rtamt-0.3.5/rtamt/syntax/node/stl/timed_until.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,33 +1,25 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Sun Jul 21 22:24:09 2019
-
-@author: NickovicD
-"""
-
-from rtamt.node.unary_node import UnaryNode
-from rtamt.node.stl.time_bound import TimeBound
-
-class TimedAlways(UnaryNode, TimeBound):
-    """A class for storing STL Always nodes
-        Inherits TemporalNode
-    """
-
-    def __init__(self, child, begin, end, is_pure_python=True):
-        """Constructor for Always
-
-        Parameters:
-            child : stl.Node
-            bound : Interval
-        """
-        UnaryNode.__init__(self, child)
-        TimeBound.__init__(self, begin, end)
-
-        self.in_vars = child.in_vars
-        self.out_vars = child.out_vars
-
-        self.name = 'always[' + str(self.begin) + ',' + str(self.end) + '](' + child.name + ')'
-
-
-
-
+from rtamt.semantics.interval.interval import Interval
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class TimedUntil(BinaryNode, Interval):
+    """
+    A class for storing STL Since nodes
+    Inherits TemporalNode
+    """
+    def __init__(self, child1, child2, interval, is_pure_python=True):
+        """Constructor for Until node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+                bound : Interval
+        """
+        BinaryNode.__init__(self, child1, child2)
+        Interval.__init__(self, interval.begin, interval.end, interval.begin_unit, interval.end_unit)
+
+        self.name = '(' + child1.name + ')until[' + str(self.begin) + str(self.begin_unit) + ',' + str(
+            self.end) + str(self.end_unit) + '](' + child2.name + ')'
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
```

### Comparing `rtamt-0.3/rtamt/node/stl/timed_eventually.py` & `rtamt-0.3.5/rtamt/syntax/node/ltl/eventually.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,19 +1,18 @@
-from rtamt.node.unary_node import UnaryNode
-from rtamt.node.stl.time_bound import TimeBound
-
-class TimedEventually(UnaryNode, TimeBound):
-    """A class for storing STL Eventually nodes
-            Inherits TemporalNode
-    """
-    def __init__(self, child, begin, end, is_pure_python=True):
-        """Constructor for Eventually node
-
-        Parameters:
-            child : stl.Node
-            bound : Interval
-        """
-        UnaryNode.__init__(self, child)
-        TimeBound.__init__(self, begin, end)
-        self.in_vars = child.in_vars
-        self.out_vars = child.out_vars
-        self.name = 'eventually[' + str(self.begin) + ',' + str(self.end) + '](' + child.name + ')'
+from rtamt.syntax.node.unary_node import UnaryNode
+
+class Eventually(UnaryNode):
+    """A class for storing STL Eventually nodes
+            Inherits TemporalNode
+    """
+    def __init__(self, child):
+        """Constructor for Eventually node
+
+        Parameters:
+            child : stl.Node
+            bound : Interval
+        """
+        super(Eventually, self).__init__(child)
+        self.in_vars = child.in_vars
+        self.out_vars = child.out_vars
+        self.name = 'eventually(' + child.name + ')'
+
```

### Comparing `rtamt-0.3/rtamt/node/stl/timed_once.py` & `rtamt-0.3.5/rtamt/syntax/node/stl/timed_since.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,23 +1,24 @@
-from rtamt.node.unary_node import UnaryNode
-from rtamt.node.stl.time_bound import TimeBound
-
-class TimedOnce(UnaryNode, TimeBound):
-    """A class for storing STL Once nodes
-                Inherits TemporalNode
-    """
-    def __init__(self, child, begin, end, is_pure_python=True):
-        """Constructor for Once node
-
-        Parameters:
-            child : stl.Node
-            bound : Interval
-        """
-
-        UnaryNode.__init__(self, child)
-        TimeBound.__init__(self, begin, end)
-        self.in_vars = child.in_vars
-        self.out_vars = child.out_vars
-
-        self.name = 'once[' + str(self.begin) + ',' + str(self.end) + '](' + child.name + ')'
-
-
+from rtamt.semantics.interval.interval import Interval
+from rtamt.syntax.node.binary_node import BinaryNode
+
+class TimedSince(BinaryNode, Interval):
+    """A class for storing STL Since nodes
+                Inherits TemporalNode
+    """
+    def __init__(self, child1, child2, interval, is_pure_python=True):
+        """Constructor for Since node
+
+            Parameters:
+                child1 : stl.Node
+                child2 : stl.Node
+                bound : Interval
+        """
+
+        BinaryNode.__init__(self, child1, child2)
+        Interval.__init__(self, interval.begin, interval.end, interval.begin_unit, interval.end_unit)
+
+        self.in_vars = child1.in_vars + child2.in_vars
+        self.out_vars = child1.out_vars + child2.out_vars
+
+        self.name = '(' + child1.name + ')since[' + str(self.begin) + str(self.begin_unit) + ',' + str(
+                self.end) + str(self.end_unit) + '](' + child2.name + ')'
```

### Comparing `rtamt-0.3/rtamt/operation/arithmetic/dense_time/online/sqrt_operation.py` & `rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/not_operation.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-import math
-from rtamt.operation.abstract_operation import AbstractOperation
-
-class SqrtOperation(AbstractOperation):
-    def __init__(self):
-        self.input = []
-
-    def update(self, input_list):
-        out = []
-
-        for in_sample in input_list:
-            if in_sample[1] < 0:
-                raise Exception('sqrt: input is smaller than 0.')
-            out_time = in_sample[0]
-            out_value = math.sqrt(in_sample[1])
-            out.append([out_time, out_value])
-
-        return out
-
-    def update_final(self, *args, **kargs):
-        return self.update(args[0])
+from rtamt.semantics.abstract_dense_time_online_operation import AbstractDenseTimeOnlineOperation
+
+class NotOperation(AbstractDenseTimeOnlineOperation):
+    def __init__(self):
+        self.input = []
+
+    def reset(self):
+        pass
+
+    def update(self, sample, *args, **kargs):
+        sample_result = []
+
+        for i in sample:
+            out_time = i[0]
+            out_value = - i[1]
+
+            sample_result.append([out_time, out_value])
+
+        return sample_result
+
+    def update_final(self, sample, *args, **kargs):
+        return self.update(sample, *args, **kargs)
```

### Comparing `rtamt-0.3/rtamt/operation/stl/dense_time/offline/intersection.py` & `rtamt-0.3.5/rtamt/semantics/stl/dense_time/offline/intersection.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,179 +1,197 @@
-import math
-
-def interval_union(a, b, method):
-    out = []
-
-    a_min = a[0]
-    a_max = a[1]
-    b_min = b[0]
-    b_max = b[1]
-
-    lo = max(a_min, b_min)
-    hi = min(a_max, b_max)
-
-    if lo <= hi:
-        val = method(a[2], b[2])
-        out.append((lo, hi, val))
-        out.append((hi, b_max, b[2]))
-    else:
-        out.append(b)
-
-    return b
-
-
-def union(a_list, b):
-    i = len(a_list)
-    out = []
-
-    if not a_list:
-        out = [b]
-
-    while i > 0:
-        a = a_list[i]
-        if b[0] >= a[0]:
-            current = interval_union(a, b)
-            out.append(current)
-            i = i - 1
-        else:
-            i = 0
-    return out;
-
-
-def intersects(x1, x2, y1, y2):
-    if x1 <= y2 and y1 <= x2:
-        return True
-    else:
-        return False
-
-def intersection(a, b, method):
-    ans = []
-    a = list(a)
-    b = list(b)
-    i = j = 1
-
-    hi = None
-
-    prev = float("nan")
-    last = []
-
-    if len(a)==0 or len(b)==0:
-        return ans, last, a, b
-
-    if len(a)==1 and len(b)==1:
-        if a[0][0] == b[0][0]:
-            val = method(a[0][1], b[0][1])
-            ans.append([a[0][0], val])
-        return ans, last, a, b
-
-    if len(a) == 1:
-        i = 0
-        while i < len(b):
-            if i == len(b)-1:
-                if a[0][0] == b[i][0]:
-                    val = method(a[0][1], b[i][1])
-                    ans.append([a[0][0], val])
-            else:
-                t = a[0][0]
-                t1 = b[i][0]
-                t2 = b[i+1][0]
-                if t1 <= t < t2:
-                    val = method(a[0][1], b[i][1])
-                    ans.append([a[0][0], val])
-            i += 1
-        return ans, last, a, b
-
-    if len(b) == 1:
-        i = 0
-        while i < len(a):
-            if i == len(a)-1:
-                if b[0][0] == a[i][0]:
-                    val = method(a[i][1], b[0][1])
-                    ans.append([b[0][0], val])
-            else:
-                t = b[0][0]
-                t1 = a[i][0]
-                t2 = a[i+1][0]
-                if t1 <= t < t2:
-                    val = method(a[i][1], b[0][1])
-                    ans.append([b[0][0], val])
-            i += 1
-        return ans, last, a, b
-
-    while len(a) > 1 and len(b) > 1:
-        a_start = a[i - 1][0]
-        a_end = a[i][0]
-        b_start = b[j - 1][0]
-        b_end = b[j][0]
-
-        a_val = a[i - 1][1]
-        b_val = b[j - 1][1]
-
-        a_val_next = a[i][1]
-        b_val_next = b[j][1]
-
-        if a_end < b_end:
-            last_val = method(a_val_next, b_val)
-            del (a[i - 1])
-        elif a_end > b_end:
-            last_val = method(a_val, b_val_next)
-            del (b[j - 1])
-        else:
-            last_val = method(a_val_next, b_val_next)
-            del (a[i - 1])
-            del (b[j - 1])
-
-        lo = max(a_start, b_start)
-        hi = min(a_end, b_end)
-
-        val = float("nan")
-
-        if lo < hi:
-            val = method(a_val, b_val)
-            if val != prev:
-                ans.append([lo, val])
-            prev = val
-            last = [hi, last_val]
-
-    return ans, last, a, b
-
-
-def disjunction(a, b):
-    return max(a, b)
-
-
-def conjunction(a, b):
-    return min(a, b)
-
-
-def implication(a, b):
-    return max(-a, b)
-
-
-def xor(a, b):
-    return abs(a - b)
-
-
-def iff(a, b):
-    return -abs(a - b)
-
-
-def addition(a, b):
-    return a + b
-
-
-def subtraction(a, b):
-    return a - b
-
-
-def multiplication(a, b):
-    return a * b
-
-
-def division(a, b):
-    return float(a) / float(b)
-
-def power(a, b):
-    return math.pow(a, b)
-
-def split(a, b):
+import math
+
+def interval_union(a, b, method):
+    out = []
+
+    a_min = a[0]
+    a_max = a[1]
+    b_min = b[0]
+    b_max = b[1]
+
+    lo = max(a_min, b_min)
+    hi = min(a_max, b_max)
+
+    if lo <= hi:
+        val = method(a[2], b[2])
+        out.append((lo, hi, val))
+        out.append((hi, b_max, b[2]))
+    else:
+        out.append(b)
+
+    return b
+
+
+def union(a_list, b):
+    i = len(a_list)
+    out = []
+
+    if not a_list:
+        out = [b]
+
+    while i > 0:
+        a = a_list[i]
+        if b[0] >= a[0]:
+            current = interval_union(a, b)
+            out.append(current)
+            i = i - 1
+        else:
+            i = 0
+    return out;
+
+
+def intersects(x1, x2, y1, y2):
+    if x1 <= y2 and y1 <= x2:
+        return True
+    else:
+        return False
+
+def intersection(a, b, method):
+    ans = []
+    a = list(a)
+    b = list(b)
+    i = j = 1
+
+    hi = None
+
+    prev = float("nan")
+    last = []
+
+    if len(a)==0 or len(b)==0:
+        return ans, last, a, b
+
+    if len(a)==1 and len(b)==1:
+        if a[0][0] == b[0][0]:
+            val = method(a[0][1], b[0][1])
+            ans.append([a[0][0], val])
+        return ans, last, a, b
+
+    if len(a) == 1:
+        i = 0
+        while i < len(b):
+            if i == len(b)-1:
+                if a[0][0] == b[i][0]:
+                    val = method(a[0][1], b[i][1])
+                    ans.append([a[0][0], val])
+            else:
+                t = a[0][0]
+                t1 = b[i][0]
+                t2 = b[i+1][0]
+                if t1 <= t < t2:
+                    val = method(a[0][1], b[i][1])
+                    ans.append([a[0][0], val])
+            i += 1
+        return ans, last, a, b
+
+    if len(b) == 1:
+        i = 0
+        while i < len(a):
+            if i == len(a)-1:
+                if b[0][0] == a[i][0]:
+                    val = method(a[i][1], b[0][1])
+                    ans.append([b[0][0], val])
+            else:
+                t = b[0][0]
+                t1 = a[i][0]
+                t2 = a[i+1][0]
+                if t1 <= t < t2:
+                    val = method(a[i][1], b[0][1])
+                    ans.append([b[0][0], val])
+            i += 1
+        return ans, last, a, b
+
+    while len(a) > 1 and len(b) > 1:
+        a_start = a[i - 1][0]
+        a_end = a[i][0]
+        b_start = b[j - 1][0]
+        b_end = b[j][0]
+
+        a_val = a[i - 1][1]
+        b_val = b[j - 1][1]
+
+        a_val_next = a[i][1]
+        b_val_next = b[j][1]
+
+        if a_end < b_end:
+            last_val = method(a_val_next, b_val)
+            del (a[i - 1])
+        elif a_end > b_end:
+            last_val = method(a_val, b_val_next)
+            del (b[j - 1])
+        else:
+            last_val = method(a_val_next, b_val_next)
+            del (a[i - 1])
+            del (b[j - 1])
+
+        lo = max(a_start, b_start)
+        hi = min(a_end, b_end)
+
+        val = float("nan")
+
+        if lo < hi:
+            val = method(a_val, b_val)
+            if val != prev:
+                ans.append([lo, val])
+            prev = val
+            last = [hi, last_val]
+
+    return ans, last, a, b
+
+
+def disjunction(a, b):
+    return max(a, b)
+
+
+def conjunction(a, b):
+    return min(a, b)
+
+
+def implication(a, b):
+    return max(-a, b)
+
+
+def xor(a, b):
+    return abs(a - b)
+
+
+def iff(a, b):
+    return -abs(a - b)
+
+
+def addition(a, b):
+    return a + b
+
+
+def subtraction(a, b):
+    return a - b
+
+
+def multiplication(a, b):
+    return a * b
+
+
+def division(a, b):
+    return float(a) / float(b)
+
+def eq(a, b):
+    return a == b
+
+def neq(a, b):
+    return not a == b
+
+def geq(a, b):
+    return a >= b
+
+def greater(a, b):
+    return a > b
+
+def leq(a, b):
+    return a <= b
+
+def less(a, b):
+    return a < b
+
+def power(a, b):
+    return math.pow(a, b)
+
+def split(a, b):
     return [a,b]
```

### Comparing `rtamt-0.3/rtamt/operation/stl/dense_time/online/intersection.py` & `rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/intersection.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,135 +1,135 @@
-import math
-
-def interval_union(a, b, method):
-    out = []
-
-    a_min = a[0]
-    a_max = a[1]
-    b_min = b[0]
-    b_max = b[1]
-
-    lo = max(a_min, b_min)
-    hi = min(a_max, b_max)
-
-    if lo <= hi:
-        val = method(a[2], b[2])
-        out.append((lo, hi, val))
-        out.append((hi, b_max, b[2]))
-    else:
-        out.append(b)
-
-    return b
-
-
-def union(a_list, b):
-    i = len(a_list)
-    out = []
-
-    if not a_list:
-        out = [b]
-
-    while i > 0:
-        a = a_list[i]
-        if b[0] >= a[0]:
-            current = interval_union(a, b)
-            out.append(current)
-            i = i - 1
-        else:
-            i = 0
-    return out;
-
-
-def intersects(x1, x2, y1, y2):
-    if x1 <= y2 and y1 <= x2:
-        return True
-    else:
-        return False
-
-def intersection(a, b, method):
-    ans = []
-    a = list(a)
-    b = list(b)
-    i = j = 1
-
-    hi = None
-
-    prev = float("nan")
-    last = []
-    while len(a) > 1 and len(b) > 1:
-        a_start = a[i - 1][0]
-        a_end = a[i][0]
-        b_start = b[j - 1][0]
-        b_end = b[j][0]
-
-        a_val = a[i - 1][1]
-        b_val = b[j - 1][1]
-
-        a_val_next = a[i][1]
-        b_val_next = b[j][1]
-
-        if a_end < b_end:
-            last_val = method(a_val_next, b_val)
-            del (a[i - 1])
-        elif a_end > b_end:
-            last_val = method(a_val, b_val_next)
-            del (b[j - 1])
-        else:
-            last_val = method(a_val_next, b_val_next)
-            del (a[i - 1])
-            del (b[j - 1])
-
-        lo = max(a_start, b_start)
-        hi = min(a_end, b_end)
-
-        val = float("nan")
-
-        if lo < hi:
-            val = method(a_val, b_val)
-            if val != prev:
-                ans.append([lo, val])
-            prev = val
-            last = [hi, last_val]
-
-    return ans, last, a, b
-
-
-def disjunction(a, b):
-    return max(a, b)
-
-
-def conjunction(a, b):
-    return min(a, b)
-
-
-def implication(a, b):
-    return max(-a, b)
-
-
-def xor(a, b):
-    return abs(a - b)
-
-
-def iff(a, b):
-    return -abs(a - b)
-
-
-def addition(a, b):
-    return a + b
-
-
-def subtraction(a, b):
-    return a - b
-
-
-def multiplication(a, b):
-    return a * b
-
-def power(a, b):
-    return math.pow(a, b)
-
-
-def division(a, b):
-    return float(a) / float(b)
-
-def split(a, b):
+import math
+
+def interval_union(a, b, method):
+    out = []
+
+    a_min = a[0]
+    a_max = a[1]
+    b_min = b[0]
+    b_max = b[1]
+
+    lo = max(a_min, b_min)
+    hi = min(a_max, b_max)
+
+    if lo <= hi:
+        val = method(a[2], b[2])
+        out.append((lo, hi, val))
+        out.append((hi, b_max, b[2]))
+    else:
+        out.append(b)
+
+    return b
+
+
+def union(a_list, b):
+    i = len(a_list)
+    out = []
+
+    if not a_list:
+        out = [b]
+
+    while i > 0:
+        a = a_list[i]
+        if b[0] >= a[0]:
+            current = interval_union(a, b)
+            out.append(current)
+            i = i - 1
+        else:
+            i = 0
+    return out;
+
+
+def intersects(x1, x2, y1, y2):
+    if x1 <= y2 and y1 <= x2:
+        return True
+    else:
+        return False
+
+def intersection(a, b, method):
+    ans = []
+    a = list(a)
+    b = list(b)
+    i = j = 1
+
+    hi = None
+
+    prev = float("nan")
+    last = []
+    while len(a) > 1 and len(b) > 1:
+        a_start = a[i - 1][0]
+        a_end = a[i][0]
+        b_start = b[j - 1][0]
+        b_end = b[j][0]
+
+        a_val = a[i - 1][1]
+        b_val = b[j - 1][1]
+
+        a_val_next = a[i][1]
+        b_val_next = b[j][1]
+
+        if a_end < b_end:
+            last_val = method(a_val_next, b_val)
+            del (a[i - 1])
+        elif a_end > b_end:
+            last_val = method(a_val, b_val_next)
+            del (b[j - 1])
+        else:
+            last_val = method(a_val_next, b_val_next)
+            del (a[i - 1])
+            del (b[j - 1])
+
+        lo = max(a_start, b_start)
+        hi = min(a_end, b_end)
+
+        val = float("nan")
+
+        if lo < hi:
+            val = method(a_val, b_val)
+            if val != prev:
+                ans.append([lo, val])
+            prev = val
+            last = [hi, last_val]
+
+    return ans, last, a, b
+
+
+def disjunction(a, b):
+    return max(a, b)
+
+
+def conjunction(a, b):
+    return min(a, b)
+
+
+def implication(a, b):
+    return max(-a, b)
+
+
+def xor(a, b):
+    return abs(a - b)
+
+
+def iff(a, b):
+    return -abs(a - b)
+
+
+def addition(a, b):
+    return a + b
+
+
+def subtraction(a, b):
+    return a - b
+
+
+def multiplication(a, b):
+    return a * b
+
+def power(a, b):
+    return math.pow(a, b)
+
+
+def division(a, b):
+    return float(a) / float(b)
+
+def split(a, b):
     return [a,b]
```

### Comparing `rtamt-0.3/rtamt/operation/stl/dense_time/online/predicate_operation.py` & `rtamt-0.3.5/rtamt/semantics/stl/dense_time/online/predicate_operation.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,122 +1,125 @@
-from rtamt.operation.abstract_operation import AbstractOperation
-from rtamt.enumerations.comp_oper import StlComparisonOperator
-from rtamt.operation.arithmetic.dense_time.online.subtraction_operation import SubtractionOperation
-from rtamt.exception.ltl.exception import LTLException
-
-
-class PredicateOperation(AbstractOperation):
-    def __init__(self, op):
-        self.op = op
-        self.sub = SubtractionOperation()
-
-    def update(self, *args, **kargs):
-        out = []
-        input_list_1 = args[0]
-        input_list_2 = args[1]
-
-        input_list = self.sub.update(input_list_1, input_list_2)
-
-        prev = float("nan")
-        for in_sample in input_list:
-            if self.op.value == StlComparisonOperator.EQ.value:
-                out_val = - abs(in_sample[1])
-            elif self.op.value == StlComparisonOperator.NEQ.value:
-                out_val = abs(in_sample[1])
-            elif self.op.value == StlComparisonOperator.LEQ.value or self.op.value == StlComparisonOperator.LESS.value:
-                out_val = - in_sample[1]
-            elif self.op.value == StlComparisonOperator.GEQ.value or self.op.value == StlComparisonOperator.GREATER.value:
-                out_val = in_sample[1]
-            else:
-                out_val = float('nan')
-
-            if out_val != prev:
-                out.append([in_sample[0], out_val])
-            prev = out_val
-
-        return out
-
-    def update_final(self, *args, **kargs):
-        out = []
-        input_list_1 = args[0]
-        input_list_2 = args[1]
-        input_list = self.sub.update_final(input_list_1, input_list_2)
-
-        prev = float("nan")
-        for in_sample in input_list:
-            if self.op.value == StlComparisonOperator.EQ.value:
-                out_val = - abs(in_sample[1])
-            elif self.op.value == StlComparisonOperator.NEQ.value:
-                out_val = abs(in_sample[1])
-            elif self.op.value == StlComparisonOperator.LEQ.value or self.op.value == StlComparisonOperator.LESS.value:
-                out_val = - in_sample[1]
-            elif self.op.value == StlComparisonOperator.GEQ.value or self.op.value == StlComparisonOperator.GREATER.value:
-                out_val = in_sample[1]
-            else:
-                out_val = float('nan')
-
-            if out_val != prev:
-                out.append([in_sample[0], out_val])
-            prev = out_val
-
-        return out
-
-    def sat(self, *args, **kargs):
-        out = []
-        input_list_1 = args[0]
-        input_list_2 = args[1]
-        input_list = self.sub.update(input_list_1, input_list_2)
-
-        prev = float("nan")
-        for i, in_sample in enumerate(input_list):
-            if self.op.value == StlComparisonOperator.EQ.value:
-                out_val = True if in_sample[1] == 0 else False
-                rval = -abs(in_sample[1])
-            elif self.op.value == StlComparisonOperator.NEQ.value:
-                out_val = False if in_sample[1] == 0 else True
-                rval = abs(in_sample[1])
-            elif self.op.value == StlComparisonOperator.LEQ.value:
-                out_val = True if in_sample[1] <= 0 else False
-                rval = - in_sample[1]
-            elif self.op.value == StlComparisonOperator.LESS.value:
-                out_val = True if in_sample[1] < 0 else False
-                rval = - in_sample[1]
-            elif self.op.value == StlComparisonOperator.GEQ.value:
-                out_val = True if in_sample[1] >= 0 else False
-                rval = in_sample[1]
-            elif self.op.value == StlComparisonOperator.GREATER.value:
-                out_val = True if in_sample[1] > 0 else False
-                rval = in_sample[1]
-            else:
-                raise LTLException('Unknown predicate operation')
-
-            if rval != prev or i == len(input_list) - 1:
-                out.append([in_sample[0], out_val])
-            prev = out_val
-
-        return out
-
-    # def offline(self, *args, **kargs):
-    #     out = []
-    #     input_list_1 = args[0]
-    #     input_list_2 = args[1]
-    #     input_list = self.sub.update(input_list_1, input_list_2)
-    #
-    #
-    #     prev = float("nan")
-    #     for i, in_sample in enumerate(input_list):
-    #         if self.op.value == StlComparisonOperator.EQ.value:
-    #             out_val = - abs(in_sample[1])
-    #         elif self.op.value == StlComparisonOperator.NEQ.value:
-    #             out_val = abs(in_sample[1])
-    #         elif self.op.value == StlComparisonOperator.LEQ.value or self.op.value == StlComparisonOperator.LESS.value:
-    #             out_val = - in_sample[1]
-    #         elif self.op.value == StlComparisonOperator.GEQ.value or self.op.value == StlComparisonOperator.GREATER.value:
-    #             out_val = in_sample[1]
-    #         else:
-    #             out_val = float('nan')
-    #
-    #         if out_val != prev or i == len(input_list) - 1:
-    #             out.append([in_sample[0], out_val])
-    #         prev = out_val
-    #
-    #     return out
+from rtamt.semantics.abstract_dense_time_online_operation import AbstractDenseTimeOnlineOperation
+from rtamt.semantics.enumerations.comp_oper import StlComparisonOperator
+from rtamt.semantics.arithmetic.dense_time.online.subtraction_operation import SubtractionOperation
+from rtamt.exception.exception import RTAMTException
+
+
+class PredicateOperation(AbstractDenseTimeOnlineOperation):
+    def __init__(self, comparison_op):
+        self.sub = SubtractionOperation()
+        self.comparison_op = comparison_op
+
+    def reset(self):
+        pass
+
+    def update(self, sample_left, sample_right, *args, **kargs):
+        sample_result = []
+        input_list = self.sub.update(sample_left, sample_right, *args, **kargs)
+
+        prev = float('nan')
+        for i in input_list:
+            if self.comparison_op.value == StlComparisonOperator.EQ.value:
+                out_val = - abs(i[1])
+            elif self.comparison_op.value == StlComparisonOperator.NEQ.value:
+                out_val = abs(i[1])
+            elif self.comparison_op.value == StlComparisonOperator.LEQ.value or self.comparison_op.value == StlComparisonOperator.LESS.value:
+                out_val = - i[1]
+            elif self.comparison_op.value == StlComparisonOperator.GEQ.value or self.comparison_op.value == StlComparisonOperator.GREATER.value:
+                out_val = i[1]
+            else:
+                out_val = float('nan')
+
+            if out_val != prev:
+                sample_result.append([i[0], out_val])
+            prev = out_val
+
+        return sample_result
+
+    def update_final(self, node, sample_left, sample_right, *args, **kargs):
+        sample_result = []
+        input_list = self.sub.update_final(sample_left, sample_right)
+
+        prev = float('nan')
+        for i in input_list:
+            if node.operator.value == StlComparisonOperator.EQ.value:
+                out_val = - abs(i[1])
+            elif node.operator.value == StlComparisonOperator.NEQ.value:
+                out_val = abs(i[1])
+            elif node.operator.value == StlComparisonOperator.LEQ.value or node.operator.value == StlComparisonOperator.LESS.value:
+                out_val = - i[1]
+            elif node.operator.value == StlComparisonOperator.GEQ.value or node.operator.value == StlComparisonOperator.GREATER.value:
+                out_val = i[1]
+            else:
+                out_val = float('nan')
+
+            if out_val != prev:
+                sample_result.append([i[0], out_val])
+            prev = out_val
+
+        return sample_result
+
+    def sat(self, sample_left, sample_right, *args, **kargs):
+        sample_result = []
+        input_list = self.sub.update(sample_left, sample_right)
+
+        prev = float('nan')
+        for i, in_sample in enumerate(input_list):
+            if self.comparison_op.value == StlComparisonOperator.EQ.value:
+                out_val = True if in_sample[1] == 0 else False
+                rval = -abs(in_sample[1])
+            elif self.comparison_op.value == StlComparisonOperator.NEQ.value:
+                out_val = False if in_sample[1] == 0 else True
+                rval = abs(in_sample[1])
+            elif self.comparison_op.value == StlComparisonOperator.LEQ.value:
+                out_val = True if in_sample[1] <= 0 else False
+                rval = - in_sample[1]
+            elif self.comparison_op.value == StlComparisonOperator.LESS.value:
+                out_val = True if in_sample[1] < 0 else False
+                rval = - in_sample[1]
+            elif self.comparison_op.value == StlComparisonOperator.GEQ.value:
+                out_val = True if in_sample[1] >= 0 else False
+                rval = in_sample[1]
+            elif self.comparison_op.value == StlComparisonOperator.GREATER.value:
+                out_val = True if in_sample[1] > 0 else False
+                rval = in_sample[1]
+            else:
+                raise RTAMTException('Unknown predicate operation')
+
+            if rval != prev or i == len(input_list) - 1:
+                sample_result.append([in_sample[0], out_val])
+            prev = out_val
+
+        return sample_result
+
+    def sat_final(self, sample_left, sample_right, *args, **kargs):
+        sample_result = []
+        input_list = self.sub.update_final(sample_left, sample_right)
+
+        prev = float('nan')
+        for i, in_sample in enumerate(input_list):
+            if self.comparison_op.value == StlComparisonOperator.EQ.value:
+                out_val = True if in_sample[1] == 0 else False
+                rval = -abs(in_sample[1])
+            elif self.comparison_op.value == StlComparisonOperator.NEQ.value:
+                out_val = False if in_sample[1] == 0 else True
+                rval = abs(in_sample[1])
+            elif self.comparison_op.value == StlComparisonOperator.LEQ.value:
+                out_val = True if in_sample[1] <= 0 else False
+                rval = - in_sample[1]
+            elif self.comparison_op.value == StlComparisonOperator.LESS.value:
+                out_val = True if in_sample[1] < 0 else False
+                rval = - in_sample[1]
+            elif self.comparison_op.value == StlComparisonOperator.GEQ.value:
+                out_val = True if in_sample[1] >= 0 else False
+                rval = in_sample[1]
+            elif self.comparison_op.value == StlComparisonOperator.GREATER.value:
+                out_val = True if in_sample[1] > 0 else False
+                rval = in_sample[1]
+            else:
+                raise RTAMTException('Unknown predicate operation')
+
+            if rval != prev or i == len(input_list) - 1:
+                sample_result.append([in_sample[0], out_val])
+            prev = out_val
+
+        return sample_result
```

### Comparing `rtamt-0.3/rtamt/operation/stl/discrete_time/offline/since_bounded_operation.py` & `rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/since_timed_operation.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-import collections
-from rtamt.operation.abstract_operation import AbstractOperation
-
-
-class SinceBoundedOperation(AbstractOperation):
-    def __init__(self, begin, end):
-        self.begin = begin
-        self.end = end
-
-    def update(self, left, right):
-        out = []
-        self.buffer_left = collections.deque(maxlen=(self.end + 1))
-        self.buffer_right = collections.deque(maxlen=(self.end + 1))
-
-        for i in range(self.end + 1):
-            s_left = float("inf")
-            s_right = - float("inf")
-            self.buffer_left.append(s_left)
-            self.buffer_right.append(s_right)
-
-        for i in range(len(left)):
-            self.buffer_left.append(left[i])
-            self.buffer_right.append(right[i])
-            out_sample = - float("inf")
-
-            for j in range(self.end-self.begin+1):
-                c_left = float("inf")
-                c_right = self.buffer_right[j]
-                for k in range(j+1, self.end+1):
-                    c_left = min(c_left, self.buffer_left[k])
-                out_sample = max(out_sample, min(c_left, c_right))
-            out.append(out_sample)
-        return out
-
+import collections
+from rtamt.semantics.abstract_online_operation import AbstractOnlineOperation
+
+class SinceTimedOperation(AbstractOnlineOperation):
+    def __init__(self, begin, end):
+        self.begin = begin
+        self.end = end
+
+        self.buffer_sample_left = collections.deque(maxlen=(self.end + 1))
+        self.buffer_sample_right = collections.deque(maxlen=(self.end + 1))
+
+        self.reset()
+
+    def reset(self):
+        for i in range(self.end + 1):
+            s_sample_left = float("inf")
+            s_sample_right = - float("inf")
+            self.buffer_sample_left.append(s_sample_left)
+            self.buffer_sample_right.append(s_sample_right)
+
+    def update(self, sample_left, sample_right):
+        self.buffer_sample_left.append(sample_left)
+        self.buffer_sample_right.append(sample_right)
+        sample_return = - float("inf")
+
+        for i in range(self.end-self.begin+1):
+            sample_left = float("inf")
+            sample_right = self.buffer_sample_right[i]
+            for j in range(i+1,self.end+1):
+                sample_left = min(sample_left, self.buffer_sample_left[j])
+            sample_return = max(sample_return, min(sample_left, sample_right))
+
+        return sample_return
+
```

### Comparing `rtamt-0.3/rtamt/operation/stl/discrete_time/online/since_bounded_operation.py` & `rtamt-0.3.5/rtamt/semantics/stl/discrete_time/online/precedes_timed_operation.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,39 +1,33 @@
-import collections
-from rtamt.operation.abstract_operation import AbstractOperation
-
-
-class SinceBoundedOperation(AbstractOperation):
-    def __init__(self, begin, end):
-        self.begin = begin
-        self.end = end
-
-        self.buffer_left = collections.deque(maxlen=(self.end + 1))
-        self.buffer_right = collections.deque(maxlen=(self.end + 1))
-
-        for i in range(self.end + 1):
-            s_left = float("inf")
-            s_right = - float("inf")
-            self.buffer_left.append(s_left)
-            self.buffer_right.append(s_right)
-
-    def reset(self):
-        for i in range(self.end + 1):
-            s_left = float("inf")
-            s_right = - float("inf")
-            self.buffer_left.append(s_left)
-            self.buffer_right.append(s_right)
-
-    def update(self, left, right):
-        self.buffer_left.append(left)
-        self.buffer_right.append(right)
-        out = - float("inf")
-
-        for i in range(self.end-self.begin+1):
-            left = float("inf")
-            right = self.buffer_right[i]
-            for j in range(i+1,self.end+1):
-                left = min(left, self.buffer_left[j])
-            out = max(out, min(left, right))
-
-        return out
-
+import collections
+from rtamt.semantics.abstract_online_operation import AbstractOnlineOperation
+class PrecedesTimedOperation(AbstractOnlineOperation):
+    def __init__(self, begin, end):
+        self.begin = begin
+        self.end = end
+
+        self.buffer = []
+        self.buffer.append(collections.deque(maxlen=(self.end + 1)))
+        self.buffer.append(collections.deque(maxlen=(self.end + 1)))
+
+        self.reset()
+
+    def reset(self):
+        for i in range(self.end + 1):
+            s_sample_left = float("inf")
+            s_sample_right = - float("inf")
+            self.buffer[0].append(s_sample_left)
+            self.buffer[1].append(s_sample_right)
+
+    def update(self, sample_left, sample_right):
+        self.buffer[0].append(sample_left)
+        self.buffer[1].append(sample_right)
+        sample_return = - float("inf")
+
+        for i in range(self.begin, self.end+1):
+            sample_left = float("inf")
+            sample_right = self.buffer[1][i]
+            for j in range(0, i):
+                sample_left = min(sample_left, self.buffer[0][j])
+            sample_return = max(sample_return, min(sample_left, sample_right))
+
+        return sample_return
```

### Comparing `rtamt-0.3/rtamt/parser/ltl/LtlParser.py` & `rtamt-0.3.5/rtamt/antlr/parser/ltl/LtlParser.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,2546 +1,2565 @@
-# Generated from LtlParser.g4 by ANTLR 4.5.1
-# encoding: utf-8
-from __future__ import print_function
-from antlr4 import *
-from io import StringIO
-
-def serializedATN():
-    with StringIO() as buf:
-        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
-        buf.write(u"K\u00f0\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
-        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
-        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
-        buf.write(u"\23\t\23\3\2\3\2\3\2\3\3\5\3+\n\3\3\3\7\3.\n\3\f\3\16")
-        buf.write(u"\3\61\13\3\3\3\3\3\7\3\65\n\3\f\3\16\38\13\3\3\3\6\3")
-        buf.write(u";\n\3\r\3\16\3<\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\6\3")
-        buf.write(u"\6\5\6I\n\6\3\6\3\6\3\7\3\7\5\7O\n\7\3\b\3\b\3\b\3\t")
-        buf.write(u"\3\t\3\t\3\t\3\t\3\t\3\t\3\n\5\n\\\n\n\3\n\3\n\3\n\5")
-        buf.write(u"\na\n\n\3\13\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f")
-        buf.write(u"\5\fm\n\f\3\r\3\r\3\16\3\16\3\17\3\17\3\17\3\17\3\17")
-        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3")
-        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
-        buf.write(u"\3\17\3\17\3\17\3\17\5\17\u0091\n\17\3\17\3\17\3\17\3")
-        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
-        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3")
-        buf.write(u"\17\3\17\3\17\3\17\7\17\u00af\n\17\f\17\16\17\u00b2\13")
-        buf.write(u"\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20")
-        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3")
-        buf.write(u"\20\3\20\3\20\3\20\3\20\5\20\u00cd\n\20\3\20\3\20\3\20")
-        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\7\20\u00db")
-        buf.write(u"\n\20\f\20\16\20\u00de\13\20\3\21\3\21\3\21\3\21\3\21")
-        buf.write(u"\3\21\5\21\u00e6\n\21\3\22\3\22\3\22\3\22\5\22\u00ec")
-        buf.write(u"\n\22\3\23\3\23\3\23\2\4\34\36\24\2\4\6\b\n\f\16\20\22")
-        buf.write(u"\24\26\30\32\34\36 \"$\2\4\4\2\"%GG\3\2\35\36\u010a\2")
-        buf.write(u"&\3\2\2\2\4*\3\2\2\2\6>\3\2\2\2\bA\3\2\2\2\nH\3\2\2\2")
-        buf.write(u"\fN\3\2\2\2\16P\3\2\2\2\20S\3\2\2\2\22[\3\2\2\2\24b\3")
-        buf.write(u"\2\2\2\26l\3\2\2\2\30n\3\2\2\2\32p\3\2\2\2\34\u0090\3")
-        buf.write(u"\2\2\2\36\u00cc\3\2\2\2 \u00e5\3\2\2\2\"\u00eb\3\2\2")
-        buf.write(u"\2$\u00ed\3\2\2\2&\'\5\4\3\2\'(\7\2\2\3(\3\3\2\2\2)+")
-        buf.write(u"\5\6\4\2*)\3\2\2\2*+\3\2\2\2+/\3\2\2\2,.\5\b\5\2-,\3")
-        buf.write(u"\2\2\2.\61\3\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\66\3\2\2")
-        buf.write(u"\2\61/\3\2\2\2\62\65\5\f\7\2\63\65\5\16\b\2\64\62\3\2")
-        buf.write(u"\2\2\64\63\3\2\2\2\658\3\2\2\2\66\64\3\2\2\2\66\67\3")
-        buf.write(u"\2\2\2\67:\3\2\2\28\66\3\2\2\29;\5\n\6\2:9\3\2\2\2;<")
-        buf.write(u"\3\2\2\2<:\3\2\2\2<=\3\2\2\2=\5\3\2\2\2>?\7(\2\2?@\7")
-        buf.write(u"G\2\2@\7\3\2\2\2AB\7)\2\2BC\7G\2\2CD\7\34\2\2DE\7G\2")
-        buf.write(u"\2E\t\3\2\2\2FG\7G\2\2GI\7A\2\2HF\3\2\2\2HI\3\2\2\2I")
-        buf.write(u"J\3\2\2\2JK\5\34\17\2K\13\3\2\2\2LO\5\22\n\2MO\5\24\13")
-        buf.write(u"\2NL\3\2\2\2NM\3\2\2\2O\r\3\2\2\2PQ\7\21\2\2QR\5\20\t")
-        buf.write(u"\2R\17\3\2\2\2ST\7\33\2\2TU\7\7\2\2UV\7G\2\2VW\7\17\2")
-        buf.write(u"\2WX\7G\2\2XY\7\b\2\2Y\21\3\2\2\2Z\\\5\32\16\2[Z\3\2")
-        buf.write(u"\2\2[\\\3\2\2\2\\]\3\2\2\2]^\5\30\r\2^`\7G\2\2_a\5\26")
-        buf.write(u"\f\2`_\3\2\2\2`a\3\2\2\2a\23\3\2\2\2bc\7 \2\2cd\5\30")
-        buf.write(u"\r\2de\7G\2\2ef\7A\2\2fg\5\"\22\2g\25\3\2\2\2hi\7A\2")
-        buf.write(u"\2im\5\"\22\2jk\7A\2\2km\5\34\17\2lh\3\2\2\2lj\3\2\2")
-        buf.write(u"\2m\27\3\2\2\2no\t\2\2\2o\31\3\2\2\2pq\t\3\2\2q\33\3")
-        buf.write(u"\2\2\2rs\b\17\1\2st\7*\2\2t\u0091\5\34\17\23uv\7\62\2")
-        buf.write(u"\2v\u0091\5\34\17\rwx\7\63\2\2x\u0091\5\34\17\fyz\7\66")
-        buf.write(u"\2\2z\u0091\5\34\17\t{|\7\67\2\2|\u0091\5\34\17\b}~\7")
-        buf.write(u":\2\2~\u0091\5\34\17\4\177\u0080\79\2\2\u0080\u0091\5")
-        buf.write(u"\34\17\3\u0081\u0091\5\36\20\2\u0082\u0083\7\7\2\2\u0083")
-        buf.write(u"\u0084\5\34\17\2\u0084\u0085\7\b\2\2\u0085\u0091\3\2")
-        buf.write(u"\2\2\u0086\u0087\7\60\2\2\u0087\u0088\7\7\2\2\u0088\u0089")
-        buf.write(u"\5\34\17\2\u0089\u008a\7\b\2\2\u008a\u0091\3\2\2\2\u008b")
-        buf.write(u"\u008c\7\61\2\2\u008c\u008d\7\7\2\2\u008d\u008e\5\34")
-        buf.write(u"\17\2\u008e\u008f\7\b\2\2\u008f\u0091\3\2\2\2\u0090r")
-        buf.write(u"\3\2\2\2\u0090u\3\2\2\2\u0090w\3\2\2\2\u0090y\3\2\2\2")
-        buf.write(u"\u0090{\3\2\2\2\u0090}\3\2\2\2\u0090\177\3\2\2\2\u0090")
-        buf.write(u"\u0081\3\2\2\2\u0090\u0082\3\2\2\2\u0090\u0086\3\2\2")
-        buf.write(u"\2\u0090\u008b\3\2\2\2\u0091\u00b0\3\2\2\2\u0092\u0093")
-        buf.write(u"\f\25\2\2\u0093\u0094\5 \21\2\u0094\u0095\5\34\17\26")
-        buf.write(u"\u0095\u00af\3\2\2\2\u0096\u0097\f\22\2\2\u0097\u0098")
-        buf.write(u"\7+\2\2\u0098\u00af\5\34\17\23\u0099\u009a\f\21\2\2\u009a")
-        buf.write(u"\u009b\7,\2\2\u009b\u00af\5\34\17\22\u009c\u009d\f\20")
-        buf.write(u"\2\2\u009d\u009e\7.\2\2\u009e\u00af\5\34\17\21\u009f")
-        buf.write(u"\u00a0\f\17\2\2\u00a0\u00a1\7-\2\2\u00a1\u00af\5\34\17")
-        buf.write(u"\20\u00a2\u00a3\f\16\2\2\u00a3\u00a4\7/\2\2\u00a4\u00af")
-        buf.write(u"\5\34\17\17\u00a5\u00a6\f\13\2\2\u00a6\u00a7\7\64\2\2")
-        buf.write(u"\u00a7\u00af\5\34\17\f\u00a8\u00a9\f\n\2\2\u00a9\u00aa")
-        buf.write(u"\7\65\2\2\u00aa\u00af\5\34\17\13\u00ab\u00ac\f\7\2\2")
-        buf.write(u"\u00ac\u00ad\78\2\2\u00ad\u00af\5\34\17\b\u00ae\u0092")
-        buf.write(u"\3\2\2\2\u00ae\u0096\3\2\2\2\u00ae\u0099\3\2\2\2\u00ae")
-        buf.write(u"\u009c\3\2\2\2\u00ae\u009f\3\2\2\2\u00ae\u00a2\3\2\2")
-        buf.write(u"\2\u00ae\u00a5\3\2\2\2\u00ae\u00a8\3\2\2\2\u00ae\u00ab")
-        buf.write(u"\3\2\2\2\u00af\u00b2\3\2\2\2\u00b0\u00ae\3\2\2\2\u00b0")
-        buf.write(u"\u00b1\3\2\2\2\u00b1\35\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b3")
-        buf.write(u"\u00b4\b\20\1\2\u00b4\u00cd\7G\2\2\u00b5\u00cd\5\"\22")
-        buf.write(u"\2\u00b6\u00b7\7\22\2\2\u00b7\u00b8\7\7\2\2\u00b8\u00b9")
-        buf.write(u"\5\36\20\2\u00b9\u00ba\7\b\2\2\u00ba\u00cd\3\2\2\2\u00bb")
-        buf.write(u"\u00bc\7\23\2\2\u00bc\u00bd\7\7\2\2\u00bd\u00be\5\36")
-        buf.write(u"\20\2\u00be\u00bf\7\b\2\2\u00bf\u00cd\3\2\2\2\u00c0\u00c1")
-        buf.write(u"\7\24\2\2\u00c1\u00c2\7\7\2\2\u00c2\u00c3\5\36\20\2\u00c3")
-        buf.write(u"\u00c4\7\b\2\2\u00c4\u00cd\3\2\2\2\u00c5\u00c6\7\25\2")
-        buf.write(u"\2\u00c6\u00c7\7\7\2\2\u00c7\u00c8\5\36\20\2\u00c8\u00c9")
-        buf.write(u"\7\17\2\2\u00c9\u00ca\5\36\20\2\u00ca\u00cb\7\b\2\2\u00cb")
-        buf.write(u"\u00cd\3\2\2\2\u00cc\u00b3\3\2\2\2\u00cc\u00b5\3\2\2")
-        buf.write(u"\2\u00cc\u00b6\3\2\2\2\u00cc\u00bb\3\2\2\2\u00cc\u00c0")
-        buf.write(u"\3\2\2\2\u00cc\u00c5\3\2\2\2\u00cd\u00dc\3\2\2\2\u00ce")
-        buf.write(u"\u00cf\f\n\2\2\u00cf\u00d0\7\4\2\2\u00d0\u00db\5\36\20")
-        buf.write(u"\13\u00d1\u00d2\f\t\2\2\u00d2\u00d3\7\3\2\2\u00d3\u00db")
-        buf.write(u"\5\36\20\n\u00d4\u00d5\f\b\2\2\u00d5\u00d6\7\5\2\2\u00d6")
-        buf.write(u"\u00db\5\36\20\t\u00d7\u00d8\f\7\2\2\u00d8\u00d9\7\6")
-        buf.write(u"\2\2\u00d9\u00db\5\36\20\b\u00da\u00ce\3\2\2\2\u00da")
-        buf.write(u"\u00d1\3\2\2\2\u00da\u00d4\3\2\2\2\u00da\u00d7\3\2\2")
-        buf.write(u"\2\u00db\u00de\3\2\2\2\u00dc\u00da\3\2\2\2\u00dc\u00dd")
-        buf.write(u"\3\2\2\2\u00dd\37\3\2\2\2\u00de\u00dc\3\2\2\2\u00df\u00e6")
-        buf.write(u"\7>\2\2\u00e0\u00e6\7=\2\2\u00e1\u00e6\7@\2\2\u00e2\u00e6")
-        buf.write(u"\7?\2\2\u00e3\u00e6\7;\2\2\u00e4\u00e6\7<\2\2\u00e5\u00df")
-        buf.write(u"\3\2\2\2\u00e5\u00e0\3\2\2\2\u00e5\u00e1\3\2\2\2\u00e5")
-        buf.write(u"\u00e2\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e5\u00e4\3\2\2")
-        buf.write(u"\2\u00e6!\3\2\2\2\u00e7\u00ec\7E\2\2\u00e8\u00ec\7F\2")
-        buf.write(u"\2\u00e9\u00ea\7\3\2\2\u00ea\u00ec\5\"\22\2\u00eb\u00e7")
-        buf.write(u"\3\2\2\2\u00eb\u00e8\3\2\2\2\u00eb\u00e9\3\2\2\2\u00ec")
-        buf.write(u"#\3\2\2\2\u00ed\u00ee\7G\2\2\u00ee%\3\2\2\2\24*/\64\66")
-        buf.write(u"<HN[`l\u0090\u00ae\u00b0\u00cc\u00da\u00dc\u00e5\u00eb")
-        return buf.getvalue()
-
-
-class LtlParser ( Parser ):
-
-    grammarFileName = "LtlParser.g4"
-
-    atn = ATNDeserializer().deserialize(serializedATN())
-
-    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]
-
-    sharedContextCache = PredictionContextCache()
-
-    literalNames = [ u"<INVALID>", u"'-'", u"'+'", u"'*'", u"'/'", u"'('", 
-                     u"')'", u"'{'", u"'}'", u"'['", u"']'", u"';'", u"':'", 
-                     u"','", u"'.'", u"'@'", u"'abs'", u"'sqrt'", u"'exp'", 
-                     u"'pow'", u"'s'", u"'ms'", u"'us'", u"'ns'", u"'ps'", 
-                     u"'topic'", u"'import'", u"'input'", u"'output'", u"'internal'", 
-                     u"'const'", u"'real'", u"'float'", u"'long'", u"'complex'", 
-                     u"'int'", u"'bool'", u"'assertion'", u"'specification'", 
-                     u"'from'", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"<INVALID>", u"'xor'", u"'rise'", u"'fall'", 
-                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"'=='", u"'!=='", u"'>='", u"'<='", 
-                     u"'>'", u"'<'", u"'='" ]
-
-    symbolicNames = [ u"<INVALID>", u"MINUS", u"PLUS", u"TIMES", u"DIVIDE", 
-                      u"LPAREN", u"RPAREN", u"LBRACE", u"RBRACE", u"LBRACK", 
-                      u"RBRACK", u"SEMICOLON", u"COLON", u"COMMA", u"DOT", 
-                      u"AT", u"ABS", u"SQRT", u"EXP", u"POW", u"SEC", u"MSEC", 
-                      u"USEC", u"NSEC", u"PSEC", u"ROS_Topic", u"Import", 
-                      u"Input", u"Output", u"Internal", u"Constant", u"DomainTypeReal", 
-                      u"DomainTypeFloat", u"DomainTypeLong", u"DomainTypeComplex", 
-                      u"DomainTypeInt", u"DomainTypeBool", u"Assertion", 
-                      u"Specification", u"From", u"NotOperator", u"OrOperator", 
-                      u"AndOperator", u"IffOperator", u"ImpliesOperator", 
-                      u"XorOperator", u"RiseOperator", u"FallOperator", 
-                      u"AlwaysOperator", u"EventuallyOperator", u"UntilOperator", 
-                      u"UnlessOperator", u"HistoricallyOperator", u"OnceOperator", 
-                      u"SinceOperator", u"NextOperator", u"PreviousOperator", 
-                      u"EqualOperator", u"NotEqualOperator", u"GreaterOrEqualOperator", 
-                      u"LesserOrEqualOperator", u"GreaterOperator", u"LesserOperator", 
-                      u"EQUAL", u"BooleanLiteral", u"TRUE", u"FALSE", u"IntegerLiteral", 
-                      u"RealLiteral", u"Identifier", u"LINE_TERMINATOR", 
-                      u"WHITESPACE", u"COMMENT", u"LINE_COMMENT" ]
-
-    RULE_specification_file = 0
-    RULE_specification = 1
-    RULE_spec = 2
-    RULE_modimport = 3
-    RULE_assertion = 4
-    RULE_declaration = 5
-    RULE_annotation = 6
-    RULE_annotation_type = 7
-    RULE_variableDeclaration = 8
-    RULE_constantDeclaration = 9
-    RULE_assignment = 10
-    RULE_domainType = 11
-    RULE_ioType = 12
-    RULE_expression = 13
-    RULE_real_expression = 14
-    RULE_comparisonOp = 15
-    RULE_literal = 16
-    RULE_identifier = 17
-
-    ruleNames =  [ u"specification_file", u"specification", u"spec", u"modimport", 
-                   u"assertion", u"declaration", u"annotation", u"annotation_type", 
-                   u"variableDeclaration", u"constantDeclaration", u"assignment", 
-                   u"domainType", u"ioType", u"expression", u"real_expression", 
-                   u"comparisonOp", u"literal", u"identifier" ]
-
-    EOF = Token.EOF
-    MINUS=1
-    PLUS=2
-    TIMES=3
-    DIVIDE=4
-    LPAREN=5
-    RPAREN=6
-    LBRACE=7
-    RBRACE=8
-    LBRACK=9
-    RBRACK=10
-    SEMICOLON=11
-    COLON=12
-    COMMA=13
-    DOT=14
-    AT=15
-    ABS=16
-    SQRT=17
-    EXP=18
-    POW=19
-    SEC=20
-    MSEC=21
-    USEC=22
-    NSEC=23
-    PSEC=24
-    ROS_Topic=25
-    Import=26
-    Input=27
-    Output=28
-    Internal=29
-    Constant=30
-    DomainTypeReal=31
-    DomainTypeFloat=32
-    DomainTypeLong=33
-    DomainTypeComplex=34
-    DomainTypeInt=35
-    DomainTypeBool=36
-    Assertion=37
-    Specification=38
-    From=39
-    NotOperator=40
-    OrOperator=41
-    AndOperator=42
-    IffOperator=43
-    ImpliesOperator=44
-    XorOperator=45
-    RiseOperator=46
-    FallOperator=47
-    AlwaysOperator=48
-    EventuallyOperator=49
-    UntilOperator=50
-    UnlessOperator=51
-    HistoricallyOperator=52
-    OnceOperator=53
-    SinceOperator=54
-    NextOperator=55
-    PreviousOperator=56
-    EqualOperator=57
-    NotEqualOperator=58
-    GreaterOrEqualOperator=59
-    LesserOrEqualOperator=60
-    GreaterOperator=61
-    LesserOperator=62
-    EQUAL=63
-    BooleanLiteral=64
-    TRUE=65
-    FALSE=66
-    IntegerLiteral=67
-    RealLiteral=68
-    Identifier=69
-    LINE_TERMINATOR=70
-    WHITESPACE=71
-    COMMENT=72
-    LINE_COMMENT=73
-
-    def __init__(self, input):
-        super(LtlParser, self).__init__(input)
-        self.checkVersion("4.5.1")
-        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
-        self._predicates = None
-
-
-
-    class Specification_fileContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.Specification_fileContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def specification(self):
-            return self.getTypedRuleContext(LtlParser.SpecificationContext,0)
-
-
-        def EOF(self):
-            return self.getToken(LtlParser.EOF, 0)
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_specification_file
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitSpecification_file"):
-                return visitor.visitSpecification_file(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def specification_file(self):
-
-        localctx = LtlParser.Specification_fileContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 0, self.RULE_specification_file)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 36
-            self.specification()
-            self.state = 37
-            self.match(LtlParser.EOF)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class SpecificationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.SpecificationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def spec(self):
-            return self.getTypedRuleContext(LtlParser.SpecContext,0)
-
-
-        def modimport(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ModimportContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ModimportContext,i)
-
-
-        def declaration(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.DeclarationContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.DeclarationContext,i)
-
-
-        def annotation(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.AnnotationContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.AnnotationContext,i)
-
-
-        def assertion(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.AssertionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.AssertionContext,i)
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_specification
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitSpecification"):
-                return visitor.visitSpecification(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def specification(self):
-
-        localctx = LtlParser.SpecificationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 2, self.RULE_specification)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 40
-            _la = self._input.LA(1)
-            if _la==LtlParser.Specification:
-                self.state = 39
-                self.spec()
-
-
-            self.state = 45
-            self._errHandler.sync(self)
-            _la = self._input.LA(1)
-            while _la==LtlParser.From:
-                self.state = 42
-                self.modimport()
-                self.state = 47
-                self._errHandler.sync(self)
-                _la = self._input.LA(1)
-
-            self.state = 52
-            self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
-                    self.state = 50
-                    token = self._input.LA(1)
-                    if token in [LtlParser.Input, LtlParser.Output, LtlParser.Constant, LtlParser.DomainTypeFloat, LtlParser.DomainTypeLong, LtlParser.DomainTypeComplex, LtlParser.DomainTypeInt, LtlParser.Identifier]:
-                        self.state = 48
-                        self.declaration()
-
-                    elif token in [LtlParser.AT]:
-                        self.state = 49
-                        self.annotation()
-
-                    else:
-                        raise NoViableAltException(self)
-             
-                self.state = 54
-                self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
-
-            self.state = 56 
-            self._errHandler.sync(self)
-            _la = self._input.LA(1)
-            while True:
-                self.state = 55
-                self.assertion()
-                self.state = 58 
-                self._errHandler.sync(self)
-                _la = self._input.LA(1)
-                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LtlParser.MINUS) | (1 << LtlParser.LPAREN) | (1 << LtlParser.ABS) | (1 << LtlParser.SQRT) | (1 << LtlParser.EXP) | (1 << LtlParser.POW) | (1 << LtlParser.NotOperator) | (1 << LtlParser.RiseOperator) | (1 << LtlParser.FallOperator) | (1 << LtlParser.AlwaysOperator) | (1 << LtlParser.EventuallyOperator) | (1 << LtlParser.HistoricallyOperator) | (1 << LtlParser.OnceOperator) | (1 << LtlParser.NextOperator) | (1 << LtlParser.PreviousOperator))) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (LtlParser.IntegerLiteral - 67)) | (1 << (LtlParser.RealLiteral - 67)) | (1 << (LtlParser.Identifier - 67)))) != 0)):
-                    break
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class SpecContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.SpecContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_spec
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.SpecContext, self).copyFrom(ctx)
-
-
-
-    class SpecificationIdContext(SpecContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.SpecContext)
-            super(LtlParser.SpecificationIdContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Specification(self):
-            return self.getToken(LtlParser.Specification, 0)
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitSpecificationId"):
-                return visitor.visitSpecificationId(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def spec(self):
-
-        localctx = LtlParser.SpecContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 4, self.RULE_spec)
-        try:
-            localctx = LtlParser.SpecificationIdContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 60
-            self.match(LtlParser.Specification)
-            self.state = 61
-            self.match(LtlParser.Identifier)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class ModimportContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.ModimportContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_modimport
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.ModimportContext, self).copyFrom(ctx)
-
-
-
-    class ModImportContext(ModimportContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ModimportContext)
-            super(LtlParser.ModImportContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def From(self):
-            return self.getToken(LtlParser.From, 0)
-        def Identifier(self, i=None):
-            if i is None:
-                return self.getTokens(LtlParser.Identifier)
-            else:
-                return self.getToken(LtlParser.Identifier, i)
-        def Import(self):
-            return self.getToken(LtlParser.Import, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitModImport"):
-                return visitor.visitModImport(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def modimport(self):
-
-        localctx = LtlParser.ModimportContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 6, self.RULE_modimport)
-        try:
-            localctx = LtlParser.ModImportContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 63
-            self.match(LtlParser.From)
-            self.state = 64
-            self.match(LtlParser.Identifier)
-            self.state = 65
-            self.match(LtlParser.Import)
-            self.state = 66
-            self.match(LtlParser.Identifier)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class AssertionContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.AssertionContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def EQUAL(self):
-            return self.getToken(LtlParser.EQUAL, 0)
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_assertion
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAssertion"):
-                return visitor.visitAssertion(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def assertion(self):
-
-        localctx = LtlParser.AssertionContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 8, self.RULE_assertion)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 70
-            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
-            if la_ == 1:
-                self.state = 68
-                self.match(LtlParser.Identifier)
-                self.state = 69
-                self.match(LtlParser.EQUAL)
-
-
-            self.state = 72
-            self.expression(0)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class DeclarationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.DeclarationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_declaration
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.DeclarationContext, self).copyFrom(ctx)
-
-
-
-    class DeclVariableContext(DeclarationContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.DeclarationContext)
-            super(LtlParser.DeclVariableContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def variableDeclaration(self):
-            return self.getTypedRuleContext(LtlParser.VariableDeclarationContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitDeclVariable"):
-                return visitor.visitDeclVariable(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class DeclConstantContext(DeclarationContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.DeclarationContext)
-            super(LtlParser.DeclConstantContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def constantDeclaration(self):
-            return self.getTypedRuleContext(LtlParser.ConstantDeclarationContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitDeclConstant"):
-                return visitor.visitDeclConstant(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def declaration(self):
-
-        localctx = LtlParser.DeclarationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 10, self.RULE_declaration)
-        try:
-            self.state = 76
-            token = self._input.LA(1)
-            if token in [LtlParser.Input, LtlParser.Output, LtlParser.DomainTypeFloat, LtlParser.DomainTypeLong, LtlParser.DomainTypeComplex, LtlParser.DomainTypeInt, LtlParser.Identifier]:
-                localctx = LtlParser.DeclVariableContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 74
-                self.variableDeclaration()
-
-            elif token in [LtlParser.Constant]:
-                localctx = LtlParser.DeclConstantContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 75
-                self.constantDeclaration()
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class AnnotationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.AnnotationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def annotation_type(self):
-            return self.getTypedRuleContext(LtlParser.Annotation_typeContext,0)
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_annotation
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAnnotation"):
-                return visitor.visitAnnotation(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def annotation(self):
-
-        localctx = LtlParser.AnnotationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 12, self.RULE_annotation)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 78
-            self.match(LtlParser.AT)
-            self.state = 79
-            self.annotation_type()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class Annotation_typeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.Annotation_typeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_annotation_type
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.Annotation_typeContext, self).copyFrom(ctx)
-
-
-
-    class RosTopicContext(Annotation_typeContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Annotation_typeContext)
-            super(LtlParser.RosTopicContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def ROS_Topic(self):
-            return self.getToken(LtlParser.ROS_Topic, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def Identifier(self, i=None):
-            if i is None:
-                return self.getTokens(LtlParser.Identifier)
-            else:
-                return self.getToken(LtlParser.Identifier, i)
-        def COMMA(self):
-            return self.getToken(LtlParser.COMMA, 0)
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitRosTopic"):
-                return visitor.visitRosTopic(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def annotation_type(self):
-
-        localctx = LtlParser.Annotation_typeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 14, self.RULE_annotation_type)
-        try:
-            localctx = LtlParser.RosTopicContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 81
-            self.match(LtlParser.ROS_Topic)
-            self.state = 82
-            self.match(LtlParser.LPAREN)
-            self.state = 83
-            self.match(LtlParser.Identifier)
-            self.state = 84
-            self.match(LtlParser.COMMA)
-            self.state = 85
-            self.match(LtlParser.Identifier)
-            self.state = 86
-            self.match(LtlParser.RPAREN)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class VariableDeclarationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.VariableDeclarationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def domainType(self):
-            return self.getTypedRuleContext(LtlParser.DomainTypeContext,0)
-
-
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def ioType(self):
-            return self.getTypedRuleContext(LtlParser.IoTypeContext,0)
-
-
-        def assignment(self):
-            return self.getTypedRuleContext(LtlParser.AssignmentContext,0)
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_variableDeclaration
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitVariableDeclaration"):
-                return visitor.visitVariableDeclaration(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def variableDeclaration(self):
-
-        localctx = LtlParser.VariableDeclarationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 16, self.RULE_variableDeclaration)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 89
-            _la = self._input.LA(1)
-            if _la==LtlParser.Input or _la==LtlParser.Output:
-                self.state = 88
-                self.ioType()
-
-
-            self.state = 91
-            self.domainType()
-            self.state = 92
-            self.match(LtlParser.Identifier)
-            self.state = 94
-            _la = self._input.LA(1)
-            if _la==LtlParser.EQUAL:
-                self.state = 93
-                self.assignment()
-
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class ConstantDeclarationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.ConstantDeclarationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def Constant(self):
-            return self.getToken(LtlParser.Constant, 0)
-
-        def domainType(self):
-            return self.getTypedRuleContext(LtlParser.DomainTypeContext,0)
-
-
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def EQUAL(self):
-            return self.getToken(LtlParser.EQUAL, 0)
-
-        def literal(self):
-            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_constantDeclaration
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitConstantDeclaration"):
-                return visitor.visitConstantDeclaration(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def constantDeclaration(self):
-
-        localctx = LtlParser.ConstantDeclarationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 18, self.RULE_constantDeclaration)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 96
-            self.match(LtlParser.Constant)
-            self.state = 97
-            self.domainType()
-            self.state = 98
-            self.match(LtlParser.Identifier)
-            self.state = 99
-            self.match(LtlParser.EQUAL)
-            self.state = 100
-            self.literal()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class AssignmentContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.AssignmentContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_assignment
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.AssignmentContext, self).copyFrom(ctx)
-
-
-
-    class AsgnExprContext(AssignmentContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.AssignmentContext)
-            super(LtlParser.AsgnExprContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EQUAL(self):
-            return self.getToken(LtlParser.EQUAL, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAsgnExpr"):
-                return visitor.visitAsgnExpr(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class AsgnLiteralContext(AssignmentContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.AssignmentContext)
-            super(LtlParser.AsgnLiteralContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EQUAL(self):
-            return self.getToken(LtlParser.EQUAL, 0)
-        def literal(self):
-            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAsgnLiteral"):
-                return visitor.visitAsgnLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def assignment(self):
-
-        localctx = LtlParser.AssignmentContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 20, self.RULE_assignment)
-        try:
-            self.state = 106
-            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
-            if la_ == 1:
-                localctx = LtlParser.AsgnLiteralContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 102
-                self.match(LtlParser.EQUAL)
-                self.state = 103
-                self.literal()
-                pass
-
-            elif la_ == 2:
-                localctx = LtlParser.AsgnExprContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 104
-                self.match(LtlParser.EQUAL)
-                self.state = 105
-                self.expression(0)
-                pass
-
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class DomainTypeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.DomainTypeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def DomainTypeFloat(self):
-            return self.getToken(LtlParser.DomainTypeFloat, 0)
-
-        def DomainTypeInt(self):
-            return self.getToken(LtlParser.DomainTypeInt, 0)
-
-        def DomainTypeLong(self):
-            return self.getToken(LtlParser.DomainTypeLong, 0)
-
-        def DomainTypeComplex(self):
-            return self.getToken(LtlParser.DomainTypeComplex, 0)
-
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_domainType
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitDomainType"):
-                return visitor.visitDomainType(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def domainType(self):
-
-        localctx = LtlParser.DomainTypeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 22, self.RULE_domainType)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 108
-            _la = self._input.LA(1)
-            if not(((((_la - 32)) & ~0x3f) == 0 and ((1 << (_la - 32)) & ((1 << (LtlParser.DomainTypeFloat - 32)) | (1 << (LtlParser.DomainTypeLong - 32)) | (1 << (LtlParser.DomainTypeComplex - 32)) | (1 << (LtlParser.DomainTypeInt - 32)) | (1 << (LtlParser.Identifier - 32)))) != 0)):
-                self._errHandler.recoverInline(self)
-            else:
-                self.consume()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class IoTypeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.IoTypeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def Input(self):
-            return self.getToken(LtlParser.Input, 0)
-
-        def Output(self):
-            return self.getToken(LtlParser.Output, 0)
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_ioType
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitIoType"):
-                return visitor.visitIoType(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def ioType(self):
-
-        localctx = LtlParser.IoTypeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 24, self.RULE_ioType)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 110
-            _la = self._input.LA(1)
-            if not(_la==LtlParser.Input or _la==LtlParser.Output):
-                self._errHandler.recoverInline(self)
-            else:
-                self.consume()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class ExpressionContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.ExpressionContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_expression
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.ExpressionContext, self).copyFrom(ctx)
-
-
-    class ExprSinceContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprSinceContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def SinceOperator(self):
-            return self.getToken(LtlParser.SinceOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprSince"):
-                return visitor.visitExprSince(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprParenContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprParenContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprParen"):
-                return visitor.visitExprParen(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprIffContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprIffContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def IffOperator(self):
-            return self.getToken(LtlParser.IffOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprIff"):
-                return visitor.visitExprIff(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExpreOnceContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExpreOnceContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def OnceOperator(self):
-            return self.getToken(LtlParser.OnceOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExpreOnce"):
-                return visitor.visitExpreOnce(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprEvContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprEvContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EventuallyOperator(self):
-            return self.getToken(LtlParser.EventuallyOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprEv"):
-                return visitor.visitExprEv(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprImpliesContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprImpliesContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def ImpliesOperator(self):
-            return self.getToken(LtlParser.ImpliesOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprImplies"):
-                return visitor.visitExprImplies(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprUntilContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprUntilContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def UntilOperator(self):
-            return self.getToken(LtlParser.UntilOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprUntil"):
-                return visitor.visitExprUntil(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprNotContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprNotContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def NotOperator(self):
-            return self.getToken(LtlParser.NotOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprNot"):
-                return visitor.visitExprNot(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprNextContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprNextContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def NextOperator(self):
-            return self.getToken(LtlParser.NextOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprNext"):
-                return visitor.visitExprNext(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAndContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprAndContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def AndOperator(self):
-            return self.getToken(LtlParser.AndOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAnd"):
-                return visitor.visitExprAnd(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprUnlessContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprUnlessContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def UnlessOperator(self):
-            return self.getToken(LtlParser.UnlessOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprUnless"):
-                return visitor.visitExprUnless(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprPreviousContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprPreviousContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def PreviousOperator(self):
-            return self.getToken(LtlParser.PreviousOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprPrevious"):
-                return visitor.visitExprPrevious(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprHistContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprHistContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def HistoricallyOperator(self):
-            return self.getToken(LtlParser.HistoricallyOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprHist"):
-                return visitor.visitExprHist(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprFallContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprFallContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def FallOperator(self):
-            return self.getToken(LtlParser.FallOperator, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprFall"):
-                return visitor.visitExprFall(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprPredicateContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprPredicateContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def comparisonOp(self):
-            return self.getTypedRuleContext(LtlParser.ComparisonOpContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprPredicate"):
-                return visitor.visitExprPredicate(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprXorContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprXorContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def XorOperator(self):
-            return self.getToken(LtlParser.XorOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprXor"):
-                return visitor.visitExprXor(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprRiseContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprRiseContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def RiseOperator(self):
-            return self.getToken(LtlParser.RiseOperator, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprRise"):
-                return visitor.visitExprRise(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprOrContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprOrContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
-
-        def OrOperator(self):
-            return self.getToken(LtlParser.OrOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprOr"):
-                return visitor.visitExprOr(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAlwaysContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprAlwaysContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def AlwaysOperator(self):
-            return self.getToken(LtlParser.AlwaysOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAlways"):
-                return visitor.visitExprAlways(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprRealContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
-            super(LtlParser.ExprRealContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self):
-            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprReal"):
-                return visitor.visitExprReal(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def expression(self, _p=0):
-        _parentctx = self._ctx
-        _parentState = self.state
-        localctx = LtlParser.ExpressionContext(self, self._ctx, _parentState)
-        _prevctx = localctx
-        _startState = 26
-        self.enterRecursionRule(localctx, 26, self.RULE_expression, _p)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 142
-            token = self._input.LA(1)
-            if token in [LtlParser.NotOperator]:
-                localctx = LtlParser.ExprNotContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-
-                self.state = 113
-                self.match(LtlParser.NotOperator)
-                self.state = 114
-                self.expression(17)
-
-            elif token in [LtlParser.AlwaysOperator]:
-                localctx = LtlParser.ExprAlwaysContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 115
-                self.match(LtlParser.AlwaysOperator)
-                self.state = 116
-                self.expression(11)
-
-            elif token in [LtlParser.EventuallyOperator]:
-                localctx = LtlParser.ExprEvContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 117
-                self.match(LtlParser.EventuallyOperator)
-                self.state = 118
-                self.expression(10)
-
-            elif token in [LtlParser.HistoricallyOperator]:
-                localctx = LtlParser.ExprHistContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 119
-                self.match(LtlParser.HistoricallyOperator)
-                self.state = 120
-                self.expression(7)
-
-            elif token in [LtlParser.OnceOperator]:
-                localctx = LtlParser.ExpreOnceContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 121
-                self.match(LtlParser.OnceOperator)
-                self.state = 122
-                self.expression(6)
-
-            elif token in [LtlParser.PreviousOperator]:
-                localctx = LtlParser.ExprPreviousContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 123
-                self.match(LtlParser.PreviousOperator)
-                self.state = 124
-                self.expression(2)
-
-            elif token in [LtlParser.NextOperator]:
-                localctx = LtlParser.ExprNextContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 125
-                self.match(LtlParser.NextOperator)
-                self.state = 126
-                self.expression(1)
-
-            elif token in [LtlParser.MINUS, LtlParser.ABS, LtlParser.SQRT, LtlParser.EXP, LtlParser.POW, LtlParser.IntegerLiteral, LtlParser.RealLiteral, LtlParser.Identifier]:
-                localctx = LtlParser.ExprRealContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 127
-                self.real_expression(0)
-
-            elif token in [LtlParser.LPAREN]:
-                localctx = LtlParser.ExprParenContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 128
-                self.match(LtlParser.LPAREN)
-                self.state = 129
-                self.expression(0)
-                self.state = 130
-                self.match(LtlParser.RPAREN)
-
-            elif token in [LtlParser.RiseOperator]:
-                localctx = LtlParser.ExprRiseContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 132
-                self.match(LtlParser.RiseOperator)
-                self.state = 133
-                self.match(LtlParser.LPAREN)
-                self.state = 134
-                self.expression(0)
-                self.state = 135
-                self.match(LtlParser.RPAREN)
-
-            elif token in [LtlParser.FallOperator]:
-                localctx = LtlParser.ExprFallContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 137
-                self.match(LtlParser.FallOperator)
-                self.state = 138
-                self.match(LtlParser.LPAREN)
-                self.state = 139
-                self.expression(0)
-                self.state = 140
-                self.match(LtlParser.RPAREN)
-
-            else:
-                raise NoViableAltException(self)
-
-            self._ctx.stop = self._input.LT(-1)
-            self.state = 174
-            self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
-                    if self._parseListeners is not None:
-                        self.triggerExitRuleEvent()
-                    _prevctx = localctx
-                    self.state = 172
-                    la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
-                    if la_ == 1:
-                        localctx = LtlParser.ExprPredicateContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 144
-                        if not self.precpred(self._ctx, 19):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
-                        self.state = 145
-                        self.comparisonOp()
-                        self.state = 146
-                        self.expression(20)
-                        pass
-
-                    elif la_ == 2:
-                        localctx = LtlParser.ExprOrContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 148
-                        if not self.precpred(self._ctx, 16):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
-                        self.state = 149
-                        self.match(LtlParser.OrOperator)
-                        self.state = 150
-                        self.expression(17)
-                        pass
-
-                    elif la_ == 3:
-                        localctx = LtlParser.ExprAndContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 151
-                        if not self.precpred(self._ctx, 15):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
-                        self.state = 152
-                        self.match(LtlParser.AndOperator)
-                        self.state = 153
-                        self.expression(16)
-                        pass
-
-                    elif la_ == 4:
-                        localctx = LtlParser.ExprImpliesContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 154
-                        if not self.precpred(self._ctx, 14):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
-                        self.state = 155
-                        self.match(LtlParser.ImpliesOperator)
-                        self.state = 156
-                        self.expression(15)
-                        pass
-
-                    elif la_ == 5:
-                        localctx = LtlParser.ExprIffContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 157
-                        if not self.precpred(self._ctx, 13):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
-                        self.state = 158
-                        self.match(LtlParser.IffOperator)
-                        self.state = 159
-                        self.expression(14)
-                        pass
-
-                    elif la_ == 6:
-                        localctx = LtlParser.ExprXorContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 160
-                        if not self.precpred(self._ctx, 12):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
-                        self.state = 161
-                        self.match(LtlParser.XorOperator)
-                        self.state = 162
-                        self.expression(13)
-                        pass
-
-                    elif la_ == 7:
-                        localctx = LtlParser.ExprUntilContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 163
-                        if not self.precpred(self._ctx, 9):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
-                        self.state = 164
-                        self.match(LtlParser.UntilOperator)
-                        self.state = 165
-                        self.expression(10)
-                        pass
-
-                    elif la_ == 8:
-                        localctx = LtlParser.ExprUnlessContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 166
-                        if not self.precpred(self._ctx, 8):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
-                        self.state = 167
-                        self.match(LtlParser.UnlessOperator)
-                        self.state = 168
-                        self.expression(9)
-                        pass
-
-                    elif la_ == 9:
-                        localctx = LtlParser.ExprSinceContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 169
-                        if not self.precpred(self._ctx, 5):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
-                        self.state = 170
-                        self.match(LtlParser.SinceOperator)
-                        self.state = 171
-                        self.expression(6)
-                        pass
-
-             
-                self.state = 176
-                self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.unrollRecursionContexts(_parentctx)
-        return localctx
-
-    class Real_expressionContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.Real_expressionContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_real_expression
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.Real_expressionContext, self).copyFrom(ctx)
-
-
-    class ExprSubtractionContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprSubtractionContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
-
-        def MINUS(self):
-            return self.getToken(LtlParser.MINUS, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprSubtraction"):
-                return visitor.visitExprSubtraction(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprPowContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprPowContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def POW(self):
-            return self.getToken(LtlParser.POW, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
-
-        def COMMA(self):
-            return self.getToken(LtlParser.COMMA, 0)
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprPow"):
-                return visitor.visitExprPow(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprDivisionContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprDivisionContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
-
-        def DIVIDE(self):
-            return self.getToken(LtlParser.DIVIDE, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprDivision"):
-                return visitor.visitExprDivision(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprMultiplicationContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprMultiplicationContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
-
-        def TIMES(self):
-            return self.getToken(LtlParser.TIMES, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprMultiplication"):
-                return visitor.visitExprMultiplication(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprLiteralContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprLiteralContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def literal(self):
-            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprLiteral"):
-                return visitor.visitExprLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprExpContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprExpContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EXP(self):
-            return self.getToken(LtlParser.EXP, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def real_expression(self):
-            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprExp"):
-                return visitor.visitExprExp(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprSqrtContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprSqrtContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def SQRT(self):
-            return self.getToken(LtlParser.SQRT, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def real_expression(self):
-            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprSqrt"):
-                return visitor.visitExprSqrt(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprIdContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprIdContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprId"):
-                return visitor.visitExprId(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAbsContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprAbsContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def ABS(self):
-            return self.getToken(LtlParser.ABS, 0)
-        def LPAREN(self):
-            return self.getToken(LtlParser.LPAREN, 0)
-        def real_expression(self):
-            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(LtlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAbs"):
-                return visitor.visitExprAbs(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAdditionContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
-            super(LtlParser.ExprAdditionContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
-
-        def PLUS(self):
-            return self.getToken(LtlParser.PLUS, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAddition"):
-                return visitor.visitExprAddition(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def real_expression(self, _p=0):
-        _parentctx = self._ctx
-        _parentState = self.state
-        localctx = LtlParser.Real_expressionContext(self, self._ctx, _parentState)
-        _prevctx = localctx
-        _startState = 28
-        self.enterRecursionRule(localctx, 28, self.RULE_real_expression, _p)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 202
-            token = self._input.LA(1)
-            if token in [LtlParser.Identifier]:
-                localctx = LtlParser.ExprIdContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-
-                self.state = 178
-                self.match(LtlParser.Identifier)
-
-            elif token in [LtlParser.MINUS, LtlParser.IntegerLiteral, LtlParser.RealLiteral]:
-                localctx = LtlParser.ExprLiteralContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 179
-                self.literal()
-
-            elif token in [LtlParser.ABS]:
-                localctx = LtlParser.ExprAbsContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 180
-                self.match(LtlParser.ABS)
-                self.state = 181
-                self.match(LtlParser.LPAREN)
-                self.state = 182
-                self.real_expression(0)
-                self.state = 183
-                self.match(LtlParser.RPAREN)
-
-            elif token in [LtlParser.SQRT]:
-                localctx = LtlParser.ExprSqrtContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 185
-                self.match(LtlParser.SQRT)
-                self.state = 186
-                self.match(LtlParser.LPAREN)
-                self.state = 187
-                self.real_expression(0)
-                self.state = 188
-                self.match(LtlParser.RPAREN)
-
-            elif token in [LtlParser.EXP]:
-                localctx = LtlParser.ExprExpContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 190
-                self.match(LtlParser.EXP)
-                self.state = 191
-                self.match(LtlParser.LPAREN)
-                self.state = 192
-                self.real_expression(0)
-                self.state = 193
-                self.match(LtlParser.RPAREN)
-
-            elif token in [LtlParser.POW]:
-                localctx = LtlParser.ExprPowContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 195
-                self.match(LtlParser.POW)
-                self.state = 196
-                self.match(LtlParser.LPAREN)
-                self.state = 197
-                self.real_expression(0)
-                self.state = 198
-                self.match(LtlParser.COMMA)
-                self.state = 199
-                self.real_expression(0)
-                self.state = 200
-                self.match(LtlParser.RPAREN)
-
-            else:
-                raise NoViableAltException(self)
-
-            self._ctx.stop = self._input.LT(-1)
-            self.state = 218
-            self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
-                    if self._parseListeners is not None:
-                        self.triggerExitRuleEvent()
-                    _prevctx = localctx
-                    self.state = 216
-                    la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
-                    if la_ == 1:
-                        localctx = LtlParser.ExprAdditionContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 204
-                        if not self.precpred(self._ctx, 8):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
-                        self.state = 205
-                        self.match(LtlParser.PLUS)
-                        self.state = 206
-                        self.real_expression(9)
-                        pass
-
-                    elif la_ == 2:
-                        localctx = LtlParser.ExprSubtractionContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 207
-                        if not self.precpred(self._ctx, 7):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
-                        self.state = 208
-                        self.match(LtlParser.MINUS)
-                        self.state = 209
-                        self.real_expression(8)
-                        pass
-
-                    elif la_ == 3:
-                        localctx = LtlParser.ExprMultiplicationContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 210
-                        if not self.precpred(self._ctx, 6):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
-                        self.state = 211
-                        self.match(LtlParser.TIMES)
-                        self.state = 212
-                        self.real_expression(7)
-                        pass
-
-                    elif la_ == 4:
-                        localctx = LtlParser.ExprDivisionContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 213
-                        if not self.precpred(self._ctx, 5):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
-                        self.state = 214
-                        self.match(LtlParser.DIVIDE)
-                        self.state = 215
-                        self.real_expression(6)
-                        pass
-
-             
-                self.state = 220
-                self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.unrollRecursionContexts(_parentctx)
-        return localctx
-
-    class ComparisonOpContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.ComparisonOpContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_comparisonOp
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.ComparisonOpContext, self).copyFrom(ctx)
-
-
-
-    class GeqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
-            super(LtlParser.GeqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def GreaterOrEqualOperator(self):
-            return self.getToken(LtlParser.GreaterOrEqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitGeq"):
-                return visitor.visitGeq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class LeqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
-            super(LtlParser.LeqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def LesserOrEqualOperator(self):
-            return self.getToken(LtlParser.LesserOrEqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitLeq"):
-                return visitor.visitLeq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class GreaterContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
-            super(LtlParser.GreaterContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def GreaterOperator(self):
-            return self.getToken(LtlParser.GreaterOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitGreater"):
-                return visitor.visitGreater(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class NeqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
-            super(LtlParser.NeqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def NotEqualOperator(self):
-            return self.getToken(LtlParser.NotEqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitNeq"):
-                return visitor.visitNeq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class EqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
-            super(LtlParser.EqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EqualOperator(self):
-            return self.getToken(LtlParser.EqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitEq"):
-                return visitor.visitEq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class LessContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
-            super(LtlParser.LessContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def LesserOperator(self):
-            return self.getToken(LtlParser.LesserOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitLess"):
-                return visitor.visitLess(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def comparisonOp(self):
-
-        localctx = LtlParser.ComparisonOpContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 30, self.RULE_comparisonOp)
-        try:
-            self.state = 227
-            token = self._input.LA(1)
-            if token in [LtlParser.LesserOrEqualOperator]:
-                localctx = LtlParser.LeqContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 221
-                self.match(LtlParser.LesserOrEqualOperator)
-
-            elif token in [LtlParser.GreaterOrEqualOperator]:
-                localctx = LtlParser.GeqContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 222
-                self.match(LtlParser.GreaterOrEqualOperator)
-
-            elif token in [LtlParser.LesserOperator]:
-                localctx = LtlParser.LessContext(self, localctx)
-                self.enterOuterAlt(localctx, 3)
-                self.state = 223
-                self.match(LtlParser.LesserOperator)
-
-            elif token in [LtlParser.GreaterOperator]:
-                localctx = LtlParser.GreaterContext(self, localctx)
-                self.enterOuterAlt(localctx, 4)
-                self.state = 224
-                self.match(LtlParser.GreaterOperator)
-
-            elif token in [LtlParser.EqualOperator]:
-                localctx = LtlParser.EqContext(self, localctx)
-                self.enterOuterAlt(localctx, 5)
-                self.state = 225
-                self.match(LtlParser.EqualOperator)
-
-            elif token in [LtlParser.NotEqualOperator]:
-                localctx = LtlParser.NeqContext(self, localctx)
-                self.enterOuterAlt(localctx, 6)
-                self.state = 226
-                self.match(LtlParser.NotEqualOperator)
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class LiteralContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.LiteralContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def IntegerLiteral(self):
-            return self.getToken(LtlParser.IntegerLiteral, 0)
-
-        def RealLiteral(self):
-            return self.getToken(LtlParser.RealLiteral, 0)
-
-        def MINUS(self):
-            return self.getToken(LtlParser.MINUS, 0)
-
-        def literal(self):
-            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_literal
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitLiteral"):
-                return visitor.visitLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def literal(self):
-
-        localctx = LtlParser.LiteralContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 32, self.RULE_literal)
-        try:
-            self.state = 233
-            token = self._input.LA(1)
-            if token in [LtlParser.IntegerLiteral]:
-                self.enterOuterAlt(localctx, 1)
-                self.state = 229
-                self.match(LtlParser.IntegerLiteral)
-
-            elif token in [LtlParser.RealLiteral]:
-                self.enterOuterAlt(localctx, 2)
-                self.state = 230
-                self.match(LtlParser.RealLiteral)
-
-            elif token in [LtlParser.MINUS]:
-                self.enterOuterAlt(localctx, 3)
-                self.state = 231
-                self.match(LtlParser.MINUS)
-                self.state = 232
-                self.literal()
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class IdentifierContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(LtlParser.IdentifierContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return LtlParser.RULE_identifier
-
-     
-        def copyFrom(self, ctx):
-            super(LtlParser.IdentifierContext, self).copyFrom(ctx)
-
-
-
-    class IdContext(IdentifierContext):
-
-        def __init__(self, parser, ctx): # actually a LtlParser.IdentifierContext)
-            super(LtlParser.IdContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Identifier(self):
-            return self.getToken(LtlParser.Identifier, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitId"):
-                return visitor.visitId(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def identifier(self):
-
-        localctx = LtlParser.IdentifierContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 34, self.RULE_identifier)
-        try:
-            localctx = LtlParser.IdContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 235
-            self.match(LtlParser.Identifier)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-
-
-    def sempred(self, localctx, ruleIndex, predIndex):
-        if self._predicates == None:
-            self._predicates = dict()
-        self._predicates[13] = self.expression_sempred
-        self._predicates[14] = self.real_expression_sempred
-        pred = self._predicates.get(ruleIndex, None)
-        if pred is None:
-            raise Exception("No predicate with index:" + str(ruleIndex))
-        else:
-            return pred(localctx, predIndex)
-
-    def expression_sempred(self, localctx, predIndex):
-            if predIndex == 0:
-                return self.precpred(self._ctx, 19)
-         
-
-            if predIndex == 1:
-                return self.precpred(self._ctx, 16)
-         
-
-            if predIndex == 2:
-                return self.precpred(self._ctx, 15)
-         
-
-            if predIndex == 3:
-                return self.precpred(self._ctx, 14)
-         
-
-            if predIndex == 4:
-                return self.precpred(self._ctx, 13)
-         
-
-            if predIndex == 5:
-                return self.precpred(self._ctx, 12)
-         
-
-            if predIndex == 6:
-                return self.precpred(self._ctx, 9)
-         
-
-            if predIndex == 7:
-                return self.precpred(self._ctx, 8)
-         
-
-            if predIndex == 8:
-                return self.precpred(self._ctx, 5)
-         
-
-    def real_expression_sempred(self, localctx, predIndex):
-            if predIndex == 9:
-                return self.precpred(self._ctx, 8)
-         
-
-            if predIndex == 10:
-                return self.precpred(self._ctx, 7)
-         
-
-            if predIndex == 11:
-                return self.precpred(self._ctx, 6)
-         
-
-            if predIndex == 12:
-                return self.precpred(self._ctx, 5)
-         
-
-
-
-
+# Generated from LtlParser.g4 by ANTLR 4.7.2
+# encoding: utf-8
+from __future__ import print_function
+from antlr4 import *
+from io import StringIO
+import sys
+
+def serializedATN():
+    with StringIO() as buf:
+        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
+        buf.write(u"K\u00f0\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
+        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
+        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
+        buf.write(u"\23\t\23\3\2\3\2\3\2\3\3\5\3+\n\3\3\3\7\3.\n\3\f\3\16")
+        buf.write(u"\3\61\13\3\3\3\3\3\7\3\65\n\3\f\3\16\38\13\3\3\3\6\3")
+        buf.write(u";\n\3\r\3\16\3<\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\6\3")
+        buf.write(u"\6\5\6I\n\6\3\6\3\6\3\7\3\7\5\7O\n\7\3\b\3\b\3\b\3\t")
+        buf.write(u"\3\t\3\t\3\t\3\t\3\t\3\t\3\n\5\n\\\n\n\3\n\3\n\3\n\5")
+        buf.write(u"\na\n\n\3\13\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f")
+        buf.write(u"\5\fm\n\f\3\r\3\r\3\16\3\16\3\17\3\17\3\17\3\17\3\17")
+        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3")
+        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
+        buf.write(u"\3\17\3\17\3\17\3\17\5\17\u0091\n\17\3\17\3\17\3\17\3")
+        buf.write(u"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17")
+        buf.write(u"\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3")
+        buf.write(u"\17\3\17\3\17\3\17\7\17\u00af\n\17\f\17\16\17\u00b2\13")
+        buf.write(u"\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20")
+        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3")
+        buf.write(u"\20\3\20\3\20\3\20\3\20\5\20\u00cd\n\20\3\20\3\20\3\20")
+        buf.write(u"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\7\20\u00db")
+        buf.write(u"\n\20\f\20\16\20\u00de\13\20\3\21\3\21\3\21\3\21\3\21")
+        buf.write(u"\3\21\5\21\u00e6\n\21\3\22\3\22\3\22\3\22\5\22\u00ec")
+        buf.write(u"\n\22\3\23\3\23\3\23\2\4\34\36\24\2\4\6\b\n\f\16\20\22")
+        buf.write(u"\24\26\30\32\34\36 \"$\2\4\4\2\"%GG\3\2\35\36\2\u010a")
+        buf.write(u"\2&\3\2\2\2\4*\3\2\2\2\6>\3\2\2\2\bA\3\2\2\2\nH\3\2\2")
+        buf.write(u"\2\fN\3\2\2\2\16P\3\2\2\2\20S\3\2\2\2\22[\3\2\2\2\24")
+        buf.write(u"b\3\2\2\2\26l\3\2\2\2\30n\3\2\2\2\32p\3\2\2\2\34\u0090")
+        buf.write(u"\3\2\2\2\36\u00cc\3\2\2\2 \u00e5\3\2\2\2\"\u00eb\3\2")
+        buf.write(u"\2\2$\u00ed\3\2\2\2&\'\5\4\3\2\'(\7\2\2\3(\3\3\2\2\2")
+        buf.write(u")+\5\6\4\2*)\3\2\2\2*+\3\2\2\2+/\3\2\2\2,.\5\b\5\2-,")
+        buf.write(u"\3\2\2\2.\61\3\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\66\3\2")
+        buf.write(u"\2\2\61/\3\2\2\2\62\65\5\f\7\2\63\65\5\16\b\2\64\62\3")
+        buf.write(u"\2\2\2\64\63\3\2\2\2\658\3\2\2\2\66\64\3\2\2\2\66\67")
+        buf.write(u"\3\2\2\2\67:\3\2\2\28\66\3\2\2\29;\5\n\6\2:9\3\2\2\2")
+        buf.write(u";<\3\2\2\2<:\3\2\2\2<=\3\2\2\2=\5\3\2\2\2>?\7(\2\2?@")
+        buf.write(u"\7G\2\2@\7\3\2\2\2AB\7)\2\2BC\7G\2\2CD\7\34\2\2DE\7G")
+        buf.write(u"\2\2E\t\3\2\2\2FG\7G\2\2GI\7A\2\2HF\3\2\2\2HI\3\2\2\2")
+        buf.write(u"IJ\3\2\2\2JK\5\34\17\2K\13\3\2\2\2LO\5\22\n\2MO\5\24")
+        buf.write(u"\13\2NL\3\2\2\2NM\3\2\2\2O\r\3\2\2\2PQ\7\21\2\2QR\5\20")
+        buf.write(u"\t\2R\17\3\2\2\2ST\7\33\2\2TU\7\7\2\2UV\7G\2\2VW\7\17")
+        buf.write(u"\2\2WX\7G\2\2XY\7\b\2\2Y\21\3\2\2\2Z\\\5\32\16\2[Z\3")
+        buf.write(u"\2\2\2[\\\3\2\2\2\\]\3\2\2\2]^\5\30\r\2^`\7G\2\2_a\5")
+        buf.write(u"\26\f\2`_\3\2\2\2`a\3\2\2\2a\23\3\2\2\2bc\7 \2\2cd\5")
+        buf.write(u"\30\r\2de\7G\2\2ef\7A\2\2fg\5\"\22\2g\25\3\2\2\2hi\7")
+        buf.write(u"A\2\2im\5\"\22\2jk\7A\2\2km\5\34\17\2lh\3\2\2\2lj\3\2")
+        buf.write(u"\2\2m\27\3\2\2\2no\t\2\2\2o\31\3\2\2\2pq\t\3\2\2q\33")
+        buf.write(u"\3\2\2\2rs\b\17\1\2s\u0091\5\36\20\2tu\7\7\2\2uv\5\34")
+        buf.write(u"\17\2vw\7\b\2\2w\u0091\3\2\2\2xy\7*\2\2y\u0091\5\34\17")
+        buf.write(u"\23z{\7\62\2\2{\u0091\5\34\17\r|}\7\63\2\2}\u0091\5\34")
+        buf.write(u"\17\f~\177\7\66\2\2\177\u0091\5\34\17\t\u0080\u0081\7")
+        buf.write(u"\67\2\2\u0081\u0091\5\34\17\b\u0082\u0083\7\60\2\2\u0083")
+        buf.write(u"\u0084\7\7\2\2\u0084\u0085\5\34\17\2\u0085\u0086\7\b")
+        buf.write(u"\2\2\u0086\u0091\3\2\2\2\u0087\u0088\7\61\2\2\u0088\u0089")
+        buf.write(u"\7\7\2\2\u0089\u008a\5\34\17\2\u008a\u008b\7\b\2\2\u008b")
+        buf.write(u"\u0091\3\2\2\2\u008c\u008d\7:\2\2\u008d\u0091\5\34\17")
+        buf.write(u"\4\u008e\u008f\79\2\2\u008f\u0091\5\34\17\3\u0090r\3")
+        buf.write(u"\2\2\2\u0090t\3\2\2\2\u0090x\3\2\2\2\u0090z\3\2\2\2\u0090")
+        buf.write(u"|\3\2\2\2\u0090~\3\2\2\2\u0090\u0080\3\2\2\2\u0090\u0082")
+        buf.write(u"\3\2\2\2\u0090\u0087\3\2\2\2\u0090\u008c\3\2\2\2\u0090")
+        buf.write(u"\u008e\3\2\2\2\u0091\u00b0\3\2\2\2\u0092\u0093\f\25\2")
+        buf.write(u"\2\u0093\u0094\5 \21\2\u0094\u0095\5\34\17\26\u0095\u00af")
+        buf.write(u"\3\2\2\2\u0096\u0097\f\22\2\2\u0097\u0098\7+\2\2\u0098")
+        buf.write(u"\u00af\5\34\17\23\u0099\u009a\f\21\2\2\u009a\u009b\7")
+        buf.write(u",\2\2\u009b\u00af\5\34\17\22\u009c\u009d\f\20\2\2\u009d")
+        buf.write(u"\u009e\7.\2\2\u009e\u00af\5\34\17\21\u009f\u00a0\f\17")
+        buf.write(u"\2\2\u00a0\u00a1\7-\2\2\u00a1\u00af\5\34\17\20\u00a2")
+        buf.write(u"\u00a3\f\16\2\2\u00a3\u00a4\7/\2\2\u00a4\u00af\5\34\17")
+        buf.write(u"\17\u00a5\u00a6\f\13\2\2\u00a6\u00a7\7\64\2\2\u00a7\u00af")
+        buf.write(u"\5\34\17\f\u00a8\u00a9\f\n\2\2\u00a9\u00aa\7\65\2\2\u00aa")
+        buf.write(u"\u00af\5\34\17\13\u00ab\u00ac\f\7\2\2\u00ac\u00ad\78")
+        buf.write(u"\2\2\u00ad\u00af\5\34\17\b\u00ae\u0092\3\2\2\2\u00ae")
+        buf.write(u"\u0096\3\2\2\2\u00ae\u0099\3\2\2\2\u00ae\u009c\3\2\2")
+        buf.write(u"\2\u00ae\u009f\3\2\2\2\u00ae\u00a2\3\2\2\2\u00ae\u00a5")
+        buf.write(u"\3\2\2\2\u00ae\u00a8\3\2\2\2\u00ae\u00ab\3\2\2\2\u00af")
+        buf.write(u"\u00b2\3\2\2\2\u00b0\u00ae\3\2\2\2\u00b0\u00b1\3\2\2")
+        buf.write(u"\2\u00b1\35\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b3\u00b4\b")
+        buf.write(u"\20\1\2\u00b4\u00cd\7G\2\2\u00b5\u00cd\5\"\22\2\u00b6")
+        buf.write(u"\u00b7\7\22\2\2\u00b7\u00b8\7\7\2\2\u00b8\u00b9\5\36")
+        buf.write(u"\20\2\u00b9\u00ba\7\b\2\2\u00ba\u00cd\3\2\2\2\u00bb\u00bc")
+        buf.write(u"\7\23\2\2\u00bc\u00bd\7\7\2\2\u00bd\u00be\5\36\20\2\u00be")
+        buf.write(u"\u00bf\7\b\2\2\u00bf\u00cd\3\2\2\2\u00c0\u00c1\7\24\2")
+        buf.write(u"\2\u00c1\u00c2\7\7\2\2\u00c2\u00c3\5\36\20\2\u00c3\u00c4")
+        buf.write(u"\7\b\2\2\u00c4\u00cd\3\2\2\2\u00c5\u00c6\7\25\2\2\u00c6")
+        buf.write(u"\u00c7\7\7\2\2\u00c7\u00c8\5\36\20\2\u00c8\u00c9\7\17")
+        buf.write(u"\2\2\u00c9\u00ca\5\36\20\2\u00ca\u00cb\7\b\2\2\u00cb")
+        buf.write(u"\u00cd\3\2\2\2\u00cc\u00b3\3\2\2\2\u00cc\u00b5\3\2\2")
+        buf.write(u"\2\u00cc\u00b6\3\2\2\2\u00cc\u00bb\3\2\2\2\u00cc\u00c0")
+        buf.write(u"\3\2\2\2\u00cc\u00c5\3\2\2\2\u00cd\u00dc\3\2\2\2\u00ce")
+        buf.write(u"\u00cf\f\n\2\2\u00cf\u00d0\7\4\2\2\u00d0\u00db\5\36\20")
+        buf.write(u"\13\u00d1\u00d2\f\t\2\2\u00d2\u00d3\7\3\2\2\u00d3\u00db")
+        buf.write(u"\5\36\20\n\u00d4\u00d5\f\b\2\2\u00d5\u00d6\7\5\2\2\u00d6")
+        buf.write(u"\u00db\5\36\20\t\u00d7\u00d8\f\7\2\2\u00d8\u00d9\7\6")
+        buf.write(u"\2\2\u00d9\u00db\5\36\20\b\u00da\u00ce\3\2\2\2\u00da")
+        buf.write(u"\u00d1\3\2\2\2\u00da\u00d4\3\2\2\2\u00da\u00d7\3\2\2")
+        buf.write(u"\2\u00db\u00de\3\2\2\2\u00dc\u00da\3\2\2\2\u00dc\u00dd")
+        buf.write(u"\3\2\2\2\u00dd\37\3\2\2\2\u00de\u00dc\3\2\2\2\u00df\u00e6")
+        buf.write(u"\7>\2\2\u00e0\u00e6\7=\2\2\u00e1\u00e6\7@\2\2\u00e2\u00e6")
+        buf.write(u"\7?\2\2\u00e3\u00e6\7;\2\2\u00e4\u00e6\7<\2\2\u00e5\u00df")
+        buf.write(u"\3\2\2\2\u00e5\u00e0\3\2\2\2\u00e5\u00e1\3\2\2\2\u00e5")
+        buf.write(u"\u00e2\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e5\u00e4\3\2\2")
+        buf.write(u"\2\u00e6!\3\2\2\2\u00e7\u00ec\7E\2\2\u00e8\u00ec\7F\2")
+        buf.write(u"\2\u00e9\u00ea\7\3\2\2\u00ea\u00ec\5\"\22\2\u00eb\u00e7")
+        buf.write(u"\3\2\2\2\u00eb\u00e8\3\2\2\2\u00eb\u00e9\3\2\2\2\u00ec")
+        buf.write(u"#\3\2\2\2\u00ed\u00ee\7G\2\2\u00ee%\3\2\2\2\24*/\64\66")
+        buf.write(u"<HN[`l\u0090\u00ae\u00b0\u00cc\u00da\u00dc\u00e5\u00eb")
+        return buf.getvalue()
+
+
+class LtlParser ( Parser ):
+
+    grammarFileName = "LtlParser.g4"
+
+    atn = ATNDeserializer().deserialize(serializedATN())
+
+    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]
+
+    sharedContextCache = PredictionContextCache()
+
+    literalNames = [ u"<INVALID>", u"'-'", u"'+'", u"'*'", u"'/'", u"'('", 
+                     u"')'", u"'{'", u"'}'", u"'['", u"']'", u"';'", u"':'", 
+                     u"','", u"'.'", u"'@'", u"'abs'", u"'sqrt'", u"'exp'", 
+                     u"'pow'", u"'s'", u"'ms'", u"'us'", u"'ns'", u"'ps'", 
+                     u"'topic'", u"'import'", u"'input'", u"'output'", u"'internal'", 
+                     u"'const'", u"'real'", u"'float'", u"'long'", u"'complex'", 
+                     u"'int'", u"'bool'", u"'assertion'", u"'specification'", 
+                     u"'from'", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
+                     u"<INVALID>", u"<INVALID>", u"'xor'", u"'rise'", u"'fall'", 
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
+                     u"<INVALID>", u"'=='", u"'!=='", u"'>='", u"'<='", 
+                     u"'>'", u"'<'", u"'='" ]
+
+    symbolicNames = [ u"<INVALID>", u"MINUS", u"PLUS", u"TIMES", u"DIVIDE", 
+                      u"LPAREN", u"RPAREN", u"LBRACE", u"RBRACE", u"LBRACK", 
+                      u"RBRACK", u"SEMICOLON", u"COLON", u"COMMA", u"DOT", 
+                      u"AT", u"ABS", u"SQRT", u"EXP", u"POW", u"SEC", u"MSEC", 
+                      u"USEC", u"NSEC", u"PSEC", u"ROS_Topic", u"Import", 
+                      u"Input", u"Output", u"Internal", u"Constant", u"DomainTypeReal", 
+                      u"DomainTypeFloat", u"DomainTypeLong", u"DomainTypeComplex", 
+                      u"DomainTypeInt", u"DomainTypeBool", u"Assertion", 
+                      u"Specification", u"From", u"NotOperator", u"OrOperator", 
+                      u"AndOperator", u"IffOperator", u"ImpliesOperator", 
+                      u"XorOperator", u"RiseOperator", u"FallOperator", 
+                      u"AlwaysOperator", u"EventuallyOperator", u"UntilOperator", 
+                      u"UnlessOperator", u"HistoricallyOperator", u"OnceOperator", 
+                      u"SinceOperator", u"NextOperator", u"PreviousOperator", 
+                      u"EqualOperator", u"NotEqualOperator", u"GreaterOrEqualOperator", 
+                      u"LesserOrEqualOperator", u"GreaterOperator", u"LesserOperator", 
+                      u"EQUAL", u"BooleanLiteral", u"TRUE", u"FALSE", u"IntegerLiteral", 
+                      u"RealLiteral", u"Identifier", u"LINE_TERMINATOR", 
+                      u"WHITESPACE", u"COMMENT", u"LINE_COMMENT" ]
+
+    RULE_specification_file = 0
+    RULE_specification = 1
+    RULE_spec = 2
+    RULE_modimport = 3
+    RULE_assertion = 4
+    RULE_declaration = 5
+    RULE_annotation = 6
+    RULE_annotation_type = 7
+    RULE_variableDeclaration = 8
+    RULE_constantDeclaration = 9
+    RULE_assignment = 10
+    RULE_domainType = 11
+    RULE_ioType = 12
+    RULE_expression = 13
+    RULE_real_expression = 14
+    RULE_comparisonOp = 15
+    RULE_literal = 16
+    RULE_identifier = 17
+
+    ruleNames =  [ u"specification_file", u"specification", u"spec", u"modimport", 
+                   u"assertion", u"declaration", u"annotation", u"annotation_type", 
+                   u"variableDeclaration", u"constantDeclaration", u"assignment", 
+                   u"domainType", u"ioType", u"expression", u"real_expression", 
+                   u"comparisonOp", u"literal", u"identifier" ]
+
+    EOF = Token.EOF
+    MINUS=1
+    PLUS=2
+    TIMES=3
+    DIVIDE=4
+    LPAREN=5
+    RPAREN=6
+    LBRACE=7
+    RBRACE=8
+    LBRACK=9
+    RBRACK=10
+    SEMICOLON=11
+    COLON=12
+    COMMA=13
+    DOT=14
+    AT=15
+    ABS=16
+    SQRT=17
+    EXP=18
+    POW=19
+    SEC=20
+    MSEC=21
+    USEC=22
+    NSEC=23
+    PSEC=24
+    ROS_Topic=25
+    Import=26
+    Input=27
+    Output=28
+    Internal=29
+    Constant=30
+    DomainTypeReal=31
+    DomainTypeFloat=32
+    DomainTypeLong=33
+    DomainTypeComplex=34
+    DomainTypeInt=35
+    DomainTypeBool=36
+    Assertion=37
+    Specification=38
+    From=39
+    NotOperator=40
+    OrOperator=41
+    AndOperator=42
+    IffOperator=43
+    ImpliesOperator=44
+    XorOperator=45
+    RiseOperator=46
+    FallOperator=47
+    AlwaysOperator=48
+    EventuallyOperator=49
+    UntilOperator=50
+    UnlessOperator=51
+    HistoricallyOperator=52
+    OnceOperator=53
+    SinceOperator=54
+    NextOperator=55
+    PreviousOperator=56
+    EqualOperator=57
+    NotEqualOperator=58
+    GreaterOrEqualOperator=59
+    LesserOrEqualOperator=60
+    GreaterOperator=61
+    LesserOperator=62
+    EQUAL=63
+    BooleanLiteral=64
+    TRUE=65
+    FALSE=66
+    IntegerLiteral=67
+    RealLiteral=68
+    Identifier=69
+    LINE_TERMINATOR=70
+    WHITESPACE=71
+    COMMENT=72
+    LINE_COMMENT=73
+
+    def __init__(self, input, output=sys.stdout):
+        super(LtlParser, self).__init__(input, output=output)
+        self.checkVersion("4.7.2")
+        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
+        self._predicates = None
+
+
+
+    class Specification_fileContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.Specification_fileContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def specification(self):
+            return self.getTypedRuleContext(LtlParser.SpecificationContext,0)
+
+
+        def EOF(self):
+            return self.getToken(LtlParser.EOF, 0)
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_specification_file
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitSpecification_file"):
+                return visitor.visitSpecification_file(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def specification_file(self):
+
+        localctx = LtlParser.Specification_fileContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 0, self.RULE_specification_file)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 36
+            self.specification()
+            self.state = 37
+            self.match(LtlParser.EOF)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class SpecificationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.SpecificationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def spec(self):
+            return self.getTypedRuleContext(LtlParser.SpecContext,0)
+
+
+        def modimport(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ModimportContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ModimportContext,i)
+
+
+        def declaration(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.DeclarationContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.DeclarationContext,i)
+
+
+        def annotation(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.AnnotationContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.AnnotationContext,i)
+
+
+        def assertion(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.AssertionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.AssertionContext,i)
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_specification
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitSpecification"):
+                return visitor.visitSpecification(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def specification(self):
+
+        localctx = LtlParser.SpecificationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 2, self.RULE_specification)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 40
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            if _la==LtlParser.Specification:
+                self.state = 39
+                self.spec()
+
+
+            self.state = 45
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            while _la==LtlParser.From:
+                self.state = 42
+                self.modimport()
+                self.state = 47
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+
+            self.state = 52
+            self._errHandler.sync(self)
+            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
+            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                if _alt==1:
+                    self.state = 50
+                    self._errHandler.sync(self)
+                    token = self._input.LA(1)
+                    if token in [LtlParser.Input, LtlParser.Output, LtlParser.Constant, LtlParser.DomainTypeFloat, LtlParser.DomainTypeLong, LtlParser.DomainTypeComplex, LtlParser.DomainTypeInt, LtlParser.Identifier]:
+                        self.state = 48
+                        self.declaration()
+                        pass
+                    elif token in [LtlParser.AT]:
+                        self.state = 49
+                        self.annotation()
+                        pass
+                    else:
+                        raise NoViableAltException(self)
+             
+                self.state = 54
+                self._errHandler.sync(self)
+                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
+
+            self.state = 56 
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            while True:
+                self.state = 55
+                self.assertion()
+                self.state = 58 
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << LtlParser.MINUS) | (1 << LtlParser.LPAREN) | (1 << LtlParser.ABS) | (1 << LtlParser.SQRT) | (1 << LtlParser.EXP) | (1 << LtlParser.POW) | (1 << LtlParser.NotOperator) | (1 << LtlParser.RiseOperator) | (1 << LtlParser.FallOperator) | (1 << LtlParser.AlwaysOperator) | (1 << LtlParser.EventuallyOperator) | (1 << LtlParser.HistoricallyOperator) | (1 << LtlParser.OnceOperator) | (1 << LtlParser.NextOperator) | (1 << LtlParser.PreviousOperator))) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (LtlParser.IntegerLiteral - 67)) | (1 << (LtlParser.RealLiteral - 67)) | (1 << (LtlParser.Identifier - 67)))) != 0)):
+                    break
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class SpecContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.SpecContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_spec
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.SpecContext, self).copyFrom(ctx)
+
+
+
+    class SpecificationIdContext(SpecContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.SpecContext)
+            super(LtlParser.SpecificationIdContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Specification(self):
+            return self.getToken(LtlParser.Specification, 0)
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitSpecificationId"):
+                return visitor.visitSpecificationId(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def spec(self):
+
+        localctx = LtlParser.SpecContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 4, self.RULE_spec)
+        try:
+            localctx = LtlParser.SpecificationIdContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 60
+            self.match(LtlParser.Specification)
+            self.state = 61
+            self.match(LtlParser.Identifier)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class ModimportContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.ModimportContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_modimport
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.ModimportContext, self).copyFrom(ctx)
+
+
+
+    class ModImportContext(ModimportContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ModimportContext)
+            super(LtlParser.ModImportContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def From(self):
+            return self.getToken(LtlParser.From, 0)
+        def Identifier(self, i=None):
+            if i is None:
+                return self.getTokens(LtlParser.Identifier)
+            else:
+                return self.getToken(LtlParser.Identifier, i)
+        def Import(self):
+            return self.getToken(LtlParser.Import, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitModImport"):
+                return visitor.visitModImport(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def modimport(self):
+
+        localctx = LtlParser.ModimportContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 6, self.RULE_modimport)
+        try:
+            localctx = LtlParser.ModImportContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 63
+            self.match(LtlParser.From)
+            self.state = 64
+            self.match(LtlParser.Identifier)
+            self.state = 65
+            self.match(LtlParser.Import)
+            self.state = 66
+            self.match(LtlParser.Identifier)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class AssertionContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.AssertionContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def EQUAL(self):
+            return self.getToken(LtlParser.EQUAL, 0)
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_assertion
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAssertion"):
+                return visitor.visitAssertion(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def assertion(self):
+
+        localctx = LtlParser.AssertionContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 8, self.RULE_assertion)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 70
+            self._errHandler.sync(self)
+            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
+            if la_ == 1:
+                self.state = 68
+                self.match(LtlParser.Identifier)
+                self.state = 69
+                self.match(LtlParser.EQUAL)
+
+
+            self.state = 72
+            self.expression(0)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class DeclarationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.DeclarationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_declaration
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.DeclarationContext, self).copyFrom(ctx)
+
+
+
+    class DeclVariableContext(DeclarationContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.DeclarationContext)
+            super(LtlParser.DeclVariableContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def variableDeclaration(self):
+            return self.getTypedRuleContext(LtlParser.VariableDeclarationContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitDeclVariable"):
+                return visitor.visitDeclVariable(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class DeclConstantContext(DeclarationContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.DeclarationContext)
+            super(LtlParser.DeclConstantContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def constantDeclaration(self):
+            return self.getTypedRuleContext(LtlParser.ConstantDeclarationContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitDeclConstant"):
+                return visitor.visitDeclConstant(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def declaration(self):
+
+        localctx = LtlParser.DeclarationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 10, self.RULE_declaration)
+        try:
+            self.state = 76
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [LtlParser.Input, LtlParser.Output, LtlParser.DomainTypeFloat, LtlParser.DomainTypeLong, LtlParser.DomainTypeComplex, LtlParser.DomainTypeInt, LtlParser.Identifier]:
+                localctx = LtlParser.DeclVariableContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 74
+                self.variableDeclaration()
+                pass
+            elif token in [LtlParser.Constant]:
+                localctx = LtlParser.DeclConstantContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 75
+                self.constantDeclaration()
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class AnnotationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.AnnotationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def AT(self):
+            return self.getToken(LtlParser.AT, 0)
+
+        def annotation_type(self):
+            return self.getTypedRuleContext(LtlParser.Annotation_typeContext,0)
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_annotation
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAnnotation"):
+                return visitor.visitAnnotation(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def annotation(self):
+
+        localctx = LtlParser.AnnotationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 12, self.RULE_annotation)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 78
+            self.match(LtlParser.AT)
+            self.state = 79
+            self.annotation_type()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class Annotation_typeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.Annotation_typeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_annotation_type
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.Annotation_typeContext, self).copyFrom(ctx)
+
+
+
+    class RosTopicContext(Annotation_typeContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Annotation_typeContext)
+            super(LtlParser.RosTopicContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def ROS_Topic(self):
+            return self.getToken(LtlParser.ROS_Topic, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def Identifier(self, i=None):
+            if i is None:
+                return self.getTokens(LtlParser.Identifier)
+            else:
+                return self.getToken(LtlParser.Identifier, i)
+        def COMMA(self):
+            return self.getToken(LtlParser.COMMA, 0)
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitRosTopic"):
+                return visitor.visitRosTopic(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def annotation_type(self):
+
+        localctx = LtlParser.Annotation_typeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 14, self.RULE_annotation_type)
+        try:
+            localctx = LtlParser.RosTopicContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 81
+            self.match(LtlParser.ROS_Topic)
+            self.state = 82
+            self.match(LtlParser.LPAREN)
+            self.state = 83
+            self.match(LtlParser.Identifier)
+            self.state = 84
+            self.match(LtlParser.COMMA)
+            self.state = 85
+            self.match(LtlParser.Identifier)
+            self.state = 86
+            self.match(LtlParser.RPAREN)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class VariableDeclarationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.VariableDeclarationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def domainType(self):
+            return self.getTypedRuleContext(LtlParser.DomainTypeContext,0)
+
+
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def ioType(self):
+            return self.getTypedRuleContext(LtlParser.IoTypeContext,0)
+
+
+        def assignment(self):
+            return self.getTypedRuleContext(LtlParser.AssignmentContext,0)
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_variableDeclaration
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitVariableDeclaration"):
+                return visitor.visitVariableDeclaration(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def variableDeclaration(self):
+
+        localctx = LtlParser.VariableDeclarationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 16, self.RULE_variableDeclaration)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 89
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            if _la==LtlParser.Input or _la==LtlParser.Output:
+                self.state = 88
+                self.ioType()
+
+
+            self.state = 91
+            self.domainType()
+            self.state = 92
+            self.match(LtlParser.Identifier)
+            self.state = 94
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            if _la==LtlParser.EQUAL:
+                self.state = 93
+                self.assignment()
+
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class ConstantDeclarationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.ConstantDeclarationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def Constant(self):
+            return self.getToken(LtlParser.Constant, 0)
+
+        def domainType(self):
+            return self.getTypedRuleContext(LtlParser.DomainTypeContext,0)
+
+
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def EQUAL(self):
+            return self.getToken(LtlParser.EQUAL, 0)
+
+        def literal(self):
+            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_constantDeclaration
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitConstantDeclaration"):
+                return visitor.visitConstantDeclaration(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def constantDeclaration(self):
+
+        localctx = LtlParser.ConstantDeclarationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 18, self.RULE_constantDeclaration)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 96
+            self.match(LtlParser.Constant)
+            self.state = 97
+            self.domainType()
+            self.state = 98
+            self.match(LtlParser.Identifier)
+            self.state = 99
+            self.match(LtlParser.EQUAL)
+            self.state = 100
+            self.literal()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class AssignmentContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.AssignmentContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_assignment
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.AssignmentContext, self).copyFrom(ctx)
+
+
+
+    class AsgnExprContext(AssignmentContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.AssignmentContext)
+            super(LtlParser.AsgnExprContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EQUAL(self):
+            return self.getToken(LtlParser.EQUAL, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAsgnExpr"):
+                return visitor.visitAsgnExpr(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class AsgnLiteralContext(AssignmentContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.AssignmentContext)
+            super(LtlParser.AsgnLiteralContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EQUAL(self):
+            return self.getToken(LtlParser.EQUAL, 0)
+        def literal(self):
+            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAsgnLiteral"):
+                return visitor.visitAsgnLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def assignment(self):
+
+        localctx = LtlParser.AssignmentContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 20, self.RULE_assignment)
+        try:
+            self.state = 106
+            self._errHandler.sync(self)
+            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
+            if la_ == 1:
+                localctx = LtlParser.AsgnLiteralContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 102
+                self.match(LtlParser.EQUAL)
+                self.state = 103
+                self.literal()
+                pass
+
+            elif la_ == 2:
+                localctx = LtlParser.AsgnExprContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 104
+                self.match(LtlParser.EQUAL)
+                self.state = 105
+                self.expression(0)
+                pass
+
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class DomainTypeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.DomainTypeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def DomainTypeFloat(self):
+            return self.getToken(LtlParser.DomainTypeFloat, 0)
+
+        def DomainTypeInt(self):
+            return self.getToken(LtlParser.DomainTypeInt, 0)
+
+        def DomainTypeLong(self):
+            return self.getToken(LtlParser.DomainTypeLong, 0)
+
+        def DomainTypeComplex(self):
+            return self.getToken(LtlParser.DomainTypeComplex, 0)
+
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_domainType
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitDomainType"):
+                return visitor.visitDomainType(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def domainType(self):
+
+        localctx = LtlParser.DomainTypeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 22, self.RULE_domainType)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 108
+            _la = self._input.LA(1)
+            if not(((((_la - 32)) & ~0x3f) == 0 and ((1 << (_la - 32)) & ((1 << (LtlParser.DomainTypeFloat - 32)) | (1 << (LtlParser.DomainTypeLong - 32)) | (1 << (LtlParser.DomainTypeComplex - 32)) | (1 << (LtlParser.DomainTypeInt - 32)) | (1 << (LtlParser.Identifier - 32)))) != 0)):
+                self._errHandler.recoverInline(self)
+            else:
+                self._errHandler.reportMatch(self)
+                self.consume()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class IoTypeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.IoTypeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def Input(self):
+            return self.getToken(LtlParser.Input, 0)
+
+        def Output(self):
+            return self.getToken(LtlParser.Output, 0)
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_ioType
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitIoType"):
+                return visitor.visitIoType(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def ioType(self):
+
+        localctx = LtlParser.IoTypeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 24, self.RULE_ioType)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 110
+            _la = self._input.LA(1)
+            if not(_la==LtlParser.Input or _la==LtlParser.Output):
+                self._errHandler.recoverInline(self)
+            else:
+                self._errHandler.reportMatch(self)
+                self.consume()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class ExpressionContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.ExpressionContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_expression
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.ExpressionContext, self).copyFrom(ctx)
+
+
+    class ExprSinceContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprSinceContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def SinceOperator(self):
+            return self.getToken(LtlParser.SinceOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprSince"):
+                return visitor.visitExprSince(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprParenContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprParenContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprParen"):
+                return visitor.visitExprParen(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprIffContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprIffContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def IffOperator(self):
+            return self.getToken(LtlParser.IffOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprIff"):
+                return visitor.visitExprIff(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExpreOnceContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExpreOnceContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def OnceOperator(self):
+            return self.getToken(LtlParser.OnceOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExpreOnce"):
+                return visitor.visitExpreOnce(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprEvContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprEvContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EventuallyOperator(self):
+            return self.getToken(LtlParser.EventuallyOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprEv"):
+                return visitor.visitExprEv(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprImpliesContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprImpliesContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def ImpliesOperator(self):
+            return self.getToken(LtlParser.ImpliesOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprImplies"):
+                return visitor.visitExprImplies(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprUntilContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprUntilContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def UntilOperator(self):
+            return self.getToken(LtlParser.UntilOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprUntil"):
+                return visitor.visitExprUntil(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprNotContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprNotContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def NotOperator(self):
+            return self.getToken(LtlParser.NotOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprNot"):
+                return visitor.visitExprNot(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprNextContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprNextContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def NextOperator(self):
+            return self.getToken(LtlParser.NextOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprNext"):
+                return visitor.visitExprNext(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAndContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprAndContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def AndOperator(self):
+            return self.getToken(LtlParser.AndOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAnd"):
+                return visitor.visitExprAnd(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprUnlessContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprUnlessContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def UnlessOperator(self):
+            return self.getToken(LtlParser.UnlessOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprUnless"):
+                return visitor.visitExprUnless(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprPreviousContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprPreviousContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def PreviousOperator(self):
+            return self.getToken(LtlParser.PreviousOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprPrevious"):
+                return visitor.visitExprPrevious(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprHistContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprHistContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def HistoricallyOperator(self):
+            return self.getToken(LtlParser.HistoricallyOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprHist"):
+                return visitor.visitExprHist(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprFallContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprFallContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def FallOperator(self):
+            return self.getToken(LtlParser.FallOperator, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprFall"):
+                return visitor.visitExprFall(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprPredicateContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprPredicateContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def comparisonOp(self):
+            return self.getTypedRuleContext(LtlParser.ComparisonOpContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprPredicate"):
+                return visitor.visitExprPredicate(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprXorContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprXorContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def XorOperator(self):
+            return self.getToken(LtlParser.XorOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprXor"):
+                return visitor.visitExprXor(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprRiseContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprRiseContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def RiseOperator(self):
+            return self.getToken(LtlParser.RiseOperator, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprRise"):
+                return visitor.visitExprRise(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprOrContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprOrContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.ExpressionContext,i)
+
+        def OrOperator(self):
+            return self.getToken(LtlParser.OrOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprOr"):
+                return visitor.visitExprOr(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAlwaysContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprAlwaysContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def AlwaysOperator(self):
+            return self.getToken(LtlParser.AlwaysOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(LtlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAlways"):
+                return visitor.visitExprAlways(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprRealContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ExpressionContext)
+            super(LtlParser.ExprRealContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self):
+            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprReal"):
+                return visitor.visitExprReal(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def expression(self, _p=0):
+        _parentctx = self._ctx
+        _parentState = self.state
+        localctx = LtlParser.ExpressionContext(self, self._ctx, _parentState)
+        _prevctx = localctx
+        _startState = 26
+        self.enterRecursionRule(localctx, 26, self.RULE_expression, _p)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 142
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [LtlParser.MINUS, LtlParser.ABS, LtlParser.SQRT, LtlParser.EXP, LtlParser.POW, LtlParser.IntegerLiteral, LtlParser.RealLiteral, LtlParser.Identifier]:
+                localctx = LtlParser.ExprRealContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+
+                self.state = 113
+                self.real_expression(0)
+                pass
+            elif token in [LtlParser.LPAREN]:
+                localctx = LtlParser.ExprParenContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 114
+                self.match(LtlParser.LPAREN)
+                self.state = 115
+                self.expression(0)
+                self.state = 116
+                self.match(LtlParser.RPAREN)
+                pass
+            elif token in [LtlParser.NotOperator]:
+                localctx = LtlParser.ExprNotContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 118
+                self.match(LtlParser.NotOperator)
+                self.state = 119
+                self.expression(17)
+                pass
+            elif token in [LtlParser.AlwaysOperator]:
+                localctx = LtlParser.ExprAlwaysContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 120
+                self.match(LtlParser.AlwaysOperator)
+                self.state = 121
+                self.expression(11)
+                pass
+            elif token in [LtlParser.EventuallyOperator]:
+                localctx = LtlParser.ExprEvContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 122
+                self.match(LtlParser.EventuallyOperator)
+                self.state = 123
+                self.expression(10)
+                pass
+            elif token in [LtlParser.HistoricallyOperator]:
+                localctx = LtlParser.ExprHistContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 124
+                self.match(LtlParser.HistoricallyOperator)
+                self.state = 125
+                self.expression(7)
+                pass
+            elif token in [LtlParser.OnceOperator]:
+                localctx = LtlParser.ExpreOnceContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 126
+                self.match(LtlParser.OnceOperator)
+                self.state = 127
+                self.expression(6)
+                pass
+            elif token in [LtlParser.RiseOperator]:
+                localctx = LtlParser.ExprRiseContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 128
+                self.match(LtlParser.RiseOperator)
+                self.state = 129
+                self.match(LtlParser.LPAREN)
+                self.state = 130
+                self.expression(0)
+                self.state = 131
+                self.match(LtlParser.RPAREN)
+                pass
+            elif token in [LtlParser.FallOperator]:
+                localctx = LtlParser.ExprFallContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 133
+                self.match(LtlParser.FallOperator)
+                self.state = 134
+                self.match(LtlParser.LPAREN)
+                self.state = 135
+                self.expression(0)
+                self.state = 136
+                self.match(LtlParser.RPAREN)
+                pass
+            elif token in [LtlParser.PreviousOperator]:
+                localctx = LtlParser.ExprPreviousContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 138
+                self.match(LtlParser.PreviousOperator)
+                self.state = 139
+                self.expression(2)
+                pass
+            elif token in [LtlParser.NextOperator]:
+                localctx = LtlParser.ExprNextContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 140
+                self.match(LtlParser.NextOperator)
+                self.state = 141
+                self.expression(1)
+                pass
+            else:
+                raise NoViableAltException(self)
+
+            self._ctx.stop = self._input.LT(-1)
+            self.state = 174
+            self._errHandler.sync(self)
+            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
+            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                if _alt==1:
+                    if self._parseListeners is not None:
+                        self.triggerExitRuleEvent()
+                    _prevctx = localctx
+                    self.state = 172
+                    self._errHandler.sync(self)
+                    la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
+                    if la_ == 1:
+                        localctx = LtlParser.ExprPredicateContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 144
+                        if not self.precpred(self._ctx, 19):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
+                        self.state = 145
+                        self.comparisonOp()
+                        self.state = 146
+                        self.expression(20)
+                        pass
+
+                    elif la_ == 2:
+                        localctx = LtlParser.ExprOrContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 148
+                        if not self.precpred(self._ctx, 16):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
+                        self.state = 149
+                        self.match(LtlParser.OrOperator)
+                        self.state = 150
+                        self.expression(17)
+                        pass
+
+                    elif la_ == 3:
+                        localctx = LtlParser.ExprAndContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 151
+                        if not self.precpred(self._ctx, 15):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
+                        self.state = 152
+                        self.match(LtlParser.AndOperator)
+                        self.state = 153
+                        self.expression(16)
+                        pass
+
+                    elif la_ == 4:
+                        localctx = LtlParser.ExprImpliesContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 154
+                        if not self.precpred(self._ctx, 14):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
+                        self.state = 155
+                        self.match(LtlParser.ImpliesOperator)
+                        self.state = 156
+                        self.expression(15)
+                        pass
+
+                    elif la_ == 5:
+                        localctx = LtlParser.ExprIffContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 157
+                        if not self.precpred(self._ctx, 13):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
+                        self.state = 158
+                        self.match(LtlParser.IffOperator)
+                        self.state = 159
+                        self.expression(14)
+                        pass
+
+                    elif la_ == 6:
+                        localctx = LtlParser.ExprXorContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 160
+                        if not self.precpred(self._ctx, 12):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
+                        self.state = 161
+                        self.match(LtlParser.XorOperator)
+                        self.state = 162
+                        self.expression(13)
+                        pass
+
+                    elif la_ == 7:
+                        localctx = LtlParser.ExprUntilContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 163
+                        if not self.precpred(self._ctx, 9):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
+                        self.state = 164
+                        self.match(LtlParser.UntilOperator)
+                        self.state = 165
+                        self.expression(10)
+                        pass
+
+                    elif la_ == 8:
+                        localctx = LtlParser.ExprUnlessContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 166
+                        if not self.precpred(self._ctx, 8):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
+                        self.state = 167
+                        self.match(LtlParser.UnlessOperator)
+                        self.state = 168
+                        self.expression(9)
+                        pass
+
+                    elif la_ == 9:
+                        localctx = LtlParser.ExprSinceContext(self, LtlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 169
+                        if not self.precpred(self._ctx, 5):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
+                        self.state = 170
+                        self.match(LtlParser.SinceOperator)
+                        self.state = 171
+                        self.expression(6)
+                        pass
+
+             
+                self.state = 176
+                self._errHandler.sync(self)
+                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.unrollRecursionContexts(_parentctx)
+        return localctx
+
+    class Real_expressionContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.Real_expressionContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_real_expression
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.Real_expressionContext, self).copyFrom(ctx)
+
+
+    class ExprSubtractionContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprSubtractionContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
+
+        def MINUS(self):
+            return self.getToken(LtlParser.MINUS, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprSubtraction"):
+                return visitor.visitExprSubtraction(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprPowContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprPowContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def POW(self):
+            return self.getToken(LtlParser.POW, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
+
+        def COMMA(self):
+            return self.getToken(LtlParser.COMMA, 0)
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprPow"):
+                return visitor.visitExprPow(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprDivisionContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprDivisionContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
+
+        def DIVIDE(self):
+            return self.getToken(LtlParser.DIVIDE, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprDivision"):
+                return visitor.visitExprDivision(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprMultiplicationContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprMultiplicationContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
+
+        def TIMES(self):
+            return self.getToken(LtlParser.TIMES, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprMultiplication"):
+                return visitor.visitExprMultiplication(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprLiteralContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprLiteralContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def literal(self):
+            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprLiteral"):
+                return visitor.visitExprLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprExpContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprExpContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EXP(self):
+            return self.getToken(LtlParser.EXP, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def real_expression(self):
+            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprExp"):
+                return visitor.visitExprExp(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprSqrtContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprSqrtContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def SQRT(self):
+            return self.getToken(LtlParser.SQRT, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def real_expression(self):
+            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprSqrt"):
+                return visitor.visitExprSqrt(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprIdContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprIdContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprId"):
+                return visitor.visitExprId(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAbsContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprAbsContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def ABS(self):
+            return self.getToken(LtlParser.ABS, 0)
+        def LPAREN(self):
+            return self.getToken(LtlParser.LPAREN, 0)
+        def real_expression(self):
+            return self.getTypedRuleContext(LtlParser.Real_expressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(LtlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAbs"):
+                return visitor.visitExprAbs(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAdditionContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.Real_expressionContext)
+            super(LtlParser.ExprAdditionContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(LtlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(LtlParser.Real_expressionContext,i)
+
+        def PLUS(self):
+            return self.getToken(LtlParser.PLUS, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAddition"):
+                return visitor.visitExprAddition(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def real_expression(self, _p=0):
+        _parentctx = self._ctx
+        _parentState = self.state
+        localctx = LtlParser.Real_expressionContext(self, self._ctx, _parentState)
+        _prevctx = localctx
+        _startState = 28
+        self.enterRecursionRule(localctx, 28, self.RULE_real_expression, _p)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 202
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [LtlParser.Identifier]:
+                localctx = LtlParser.ExprIdContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+
+                self.state = 178
+                self.match(LtlParser.Identifier)
+                pass
+            elif token in [LtlParser.MINUS, LtlParser.IntegerLiteral, LtlParser.RealLiteral]:
+                localctx = LtlParser.ExprLiteralContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 179
+                self.literal()
+                pass
+            elif token in [LtlParser.ABS]:
+                localctx = LtlParser.ExprAbsContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 180
+                self.match(LtlParser.ABS)
+                self.state = 181
+                self.match(LtlParser.LPAREN)
+                self.state = 182
+                self.real_expression(0)
+                self.state = 183
+                self.match(LtlParser.RPAREN)
+                pass
+            elif token in [LtlParser.SQRT]:
+                localctx = LtlParser.ExprSqrtContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 185
+                self.match(LtlParser.SQRT)
+                self.state = 186
+                self.match(LtlParser.LPAREN)
+                self.state = 187
+                self.real_expression(0)
+                self.state = 188
+                self.match(LtlParser.RPAREN)
+                pass
+            elif token in [LtlParser.EXP]:
+                localctx = LtlParser.ExprExpContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 190
+                self.match(LtlParser.EXP)
+                self.state = 191
+                self.match(LtlParser.LPAREN)
+                self.state = 192
+                self.real_expression(0)
+                self.state = 193
+                self.match(LtlParser.RPAREN)
+                pass
+            elif token in [LtlParser.POW]:
+                localctx = LtlParser.ExprPowContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 195
+                self.match(LtlParser.POW)
+                self.state = 196
+                self.match(LtlParser.LPAREN)
+                self.state = 197
+                self.real_expression(0)
+                self.state = 198
+                self.match(LtlParser.COMMA)
+                self.state = 199
+                self.real_expression(0)
+                self.state = 200
+                self.match(LtlParser.RPAREN)
+                pass
+            else:
+                raise NoViableAltException(self)
+
+            self._ctx.stop = self._input.LT(-1)
+            self.state = 218
+            self._errHandler.sync(self)
+            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
+            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                if _alt==1:
+                    if self._parseListeners is not None:
+                        self.triggerExitRuleEvent()
+                    _prevctx = localctx
+                    self.state = 216
+                    self._errHandler.sync(self)
+                    la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
+                    if la_ == 1:
+                        localctx = LtlParser.ExprAdditionContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 204
+                        if not self.precpred(self._ctx, 8):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
+                        self.state = 205
+                        self.match(LtlParser.PLUS)
+                        self.state = 206
+                        self.real_expression(9)
+                        pass
+
+                    elif la_ == 2:
+                        localctx = LtlParser.ExprSubtractionContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 207
+                        if not self.precpred(self._ctx, 7):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
+                        self.state = 208
+                        self.match(LtlParser.MINUS)
+                        self.state = 209
+                        self.real_expression(8)
+                        pass
+
+                    elif la_ == 3:
+                        localctx = LtlParser.ExprMultiplicationContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 210
+                        if not self.precpred(self._ctx, 6):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
+                        self.state = 211
+                        self.match(LtlParser.TIMES)
+                        self.state = 212
+                        self.real_expression(7)
+                        pass
+
+                    elif la_ == 4:
+                        localctx = LtlParser.ExprDivisionContext(self, LtlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 213
+                        if not self.precpred(self._ctx, 5):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
+                        self.state = 214
+                        self.match(LtlParser.DIVIDE)
+                        self.state = 215
+                        self.real_expression(6)
+                        pass
+
+             
+                self.state = 220
+                self._errHandler.sync(self)
+                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.unrollRecursionContexts(_parentctx)
+        return localctx
+
+    class ComparisonOpContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.ComparisonOpContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_comparisonOp
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.ComparisonOpContext, self).copyFrom(ctx)
+
+
+
+    class GeqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
+            super(LtlParser.GeqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def GreaterOrEqualOperator(self):
+            return self.getToken(LtlParser.GreaterOrEqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitGeq"):
+                return visitor.visitGeq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class LeqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
+            super(LtlParser.LeqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def LesserOrEqualOperator(self):
+            return self.getToken(LtlParser.LesserOrEqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitLeq"):
+                return visitor.visitLeq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class GreaterContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
+            super(LtlParser.GreaterContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def GreaterOperator(self):
+            return self.getToken(LtlParser.GreaterOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitGreater"):
+                return visitor.visitGreater(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class NeqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
+            super(LtlParser.NeqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def NotEqualOperator(self):
+            return self.getToken(LtlParser.NotEqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitNeq"):
+                return visitor.visitNeq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class EqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
+            super(LtlParser.EqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EqualOperator(self):
+            return self.getToken(LtlParser.EqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitEq"):
+                return visitor.visitEq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class LessContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.ComparisonOpContext)
+            super(LtlParser.LessContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def LesserOperator(self):
+            return self.getToken(LtlParser.LesserOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitLess"):
+                return visitor.visitLess(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def comparisonOp(self):
+
+        localctx = LtlParser.ComparisonOpContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 30, self.RULE_comparisonOp)
+        try:
+            self.state = 227
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [LtlParser.LesserOrEqualOperator]:
+                localctx = LtlParser.LeqContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 221
+                self.match(LtlParser.LesserOrEqualOperator)
+                pass
+            elif token in [LtlParser.GreaterOrEqualOperator]:
+                localctx = LtlParser.GeqContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 222
+                self.match(LtlParser.GreaterOrEqualOperator)
+                pass
+            elif token in [LtlParser.LesserOperator]:
+                localctx = LtlParser.LessContext(self, localctx)
+                self.enterOuterAlt(localctx, 3)
+                self.state = 223
+                self.match(LtlParser.LesserOperator)
+                pass
+            elif token in [LtlParser.GreaterOperator]:
+                localctx = LtlParser.GreaterContext(self, localctx)
+                self.enterOuterAlt(localctx, 4)
+                self.state = 224
+                self.match(LtlParser.GreaterOperator)
+                pass
+            elif token in [LtlParser.EqualOperator]:
+                localctx = LtlParser.EqContext(self, localctx)
+                self.enterOuterAlt(localctx, 5)
+                self.state = 225
+                self.match(LtlParser.EqualOperator)
+                pass
+            elif token in [LtlParser.NotEqualOperator]:
+                localctx = LtlParser.NeqContext(self, localctx)
+                self.enterOuterAlt(localctx, 6)
+                self.state = 226
+                self.match(LtlParser.NotEqualOperator)
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class LiteralContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.LiteralContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def IntegerLiteral(self):
+            return self.getToken(LtlParser.IntegerLiteral, 0)
+
+        def RealLiteral(self):
+            return self.getToken(LtlParser.RealLiteral, 0)
+
+        def MINUS(self):
+            return self.getToken(LtlParser.MINUS, 0)
+
+        def literal(self):
+            return self.getTypedRuleContext(LtlParser.LiteralContext,0)
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_literal
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitLiteral"):
+                return visitor.visitLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def literal(self):
+
+        localctx = LtlParser.LiteralContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 32, self.RULE_literal)
+        try:
+            self.state = 233
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [LtlParser.IntegerLiteral]:
+                self.enterOuterAlt(localctx, 1)
+                self.state = 229
+                self.match(LtlParser.IntegerLiteral)
+                pass
+            elif token in [LtlParser.RealLiteral]:
+                self.enterOuterAlt(localctx, 2)
+                self.state = 230
+                self.match(LtlParser.RealLiteral)
+                pass
+            elif token in [LtlParser.MINUS]:
+                self.enterOuterAlt(localctx, 3)
+                self.state = 231
+                self.match(LtlParser.MINUS)
+                self.state = 232
+                self.literal()
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class IdentifierContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(LtlParser.IdentifierContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return LtlParser.RULE_identifier
+
+     
+        def copyFrom(self, ctx):
+            super(LtlParser.IdentifierContext, self).copyFrom(ctx)
+
+
+
+    class IdContext(IdentifierContext):
+
+        def __init__(self, parser, ctx): # actually a LtlParser.IdentifierContext)
+            super(LtlParser.IdContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Identifier(self):
+            return self.getToken(LtlParser.Identifier, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitId"):
+                return visitor.visitId(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def identifier(self):
+
+        localctx = LtlParser.IdentifierContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 34, self.RULE_identifier)
+        try:
+            localctx = LtlParser.IdContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 235
+            self.match(LtlParser.Identifier)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+
+
+    def sempred(self, localctx, ruleIndex, predIndex):
+        if self._predicates == None:
+            self._predicates = dict()
+        self._predicates[13] = self.expression_sempred
+        self._predicates[14] = self.real_expression_sempred
+        pred = self._predicates.get(ruleIndex, None)
+        if pred is None:
+            raise Exception("No predicate with index:" + str(ruleIndex))
+        else:
+            return pred(localctx, predIndex)
+
+    def expression_sempred(self, localctx, predIndex):
+            if predIndex == 0:
+                return self.precpred(self._ctx, 19)
+         
+
+            if predIndex == 1:
+                return self.precpred(self._ctx, 16)
+         
+
+            if predIndex == 2:
+                return self.precpred(self._ctx, 15)
+         
+
+            if predIndex == 3:
+                return self.precpred(self._ctx, 14)
+         
+
+            if predIndex == 4:
+                return self.precpred(self._ctx, 13)
+         
+
+            if predIndex == 5:
+                return self.precpred(self._ctx, 12)
+         
+
+            if predIndex == 6:
+                return self.precpred(self._ctx, 9)
+         
+
+            if predIndex == 7:
+                return self.precpred(self._ctx, 8)
+         
+
+            if predIndex == 8:
+                return self.precpred(self._ctx, 5)
+         
+
+    def real_expression_sempred(self, localctx, predIndex):
+            if predIndex == 9:
+                return self.precpred(self._ctx, 8)
+         
+
+            if predIndex == 10:
+                return self.precpred(self._ctx, 7)
+         
+
+            if predIndex == 11:
+                return self.precpred(self._ctx, 6)
+         
+
+            if predIndex == 12:
+                return self.precpred(self._ctx, 5)
+         
+
+
+
+
```

### Comparing `rtamt-0.3/rtamt/parser/ltl/LtlParserVisitor.py` & `rtamt-0.3.5/rtamt/antlr/parser/ltl/LtlParserVisitor.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,272 +1,272 @@
-# Generated from LtlParser.g4 by ANTLR 4.5.1
-from antlr4 import *
-
-# This class defines a complete generic visitor for a parse tree produced by LtlParser.
-
-class LtlParserVisitor(ParseTreeVisitor):
-
-    # Visit a parse tree produced by LtlParser#specification_file.
-    def visitSpecification_file(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#specification.
-    def visitSpecification(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#SpecificationId.
-    def visitSpecificationId(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#modImport.
-    def visitModImport(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#assertion.
-    def visitAssertion(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#declVariable.
-    def visitDeclVariable(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#declConstant.
-    def visitDeclConstant(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#annotation.
-    def visitAnnotation(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#rosTopic.
-    def visitRosTopic(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#variableDeclaration.
-    def visitVariableDeclaration(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#constantDeclaration.
-    def visitConstantDeclaration(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#AsgnLiteral.
-    def visitAsgnLiteral(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#AsgnExpr.
-    def visitAsgnExpr(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#domainType.
-    def visitDomainType(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ioType.
-    def visitIoType(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprSince.
-    def visitExprSince(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprParen.
-    def visitExprParen(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprIff.
-    def visitExprIff(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExpreOnce.
-    def visitExpreOnce(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprEv.
-    def visitExprEv(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprImplies.
-    def visitExprImplies(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprUntil.
-    def visitExprUntil(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprNot.
-    def visitExprNot(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprNext.
-    def visitExprNext(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprAnd.
-    def visitExprAnd(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprUnless.
-    def visitExprUnless(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprPrevious.
-    def visitExprPrevious(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprHist.
-    def visitExprHist(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprFall.
-    def visitExprFall(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprPredicate.
-    def visitExprPredicate(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprXor.
-    def visitExprXor(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprRise.
-    def visitExprRise(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprOr.
-    def visitExprOr(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprAlways.
-    def visitExprAlways(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprReal.
-    def visitExprReal(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprSubtraction.
-    def visitExprSubtraction(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprPow.
-    def visitExprPow(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprDivision.
-    def visitExprDivision(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprMultiplication.
-    def visitExprMultiplication(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprLiteral.
-    def visitExprLiteral(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprExp.
-    def visitExprExp(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprSqrt.
-    def visitExprSqrt(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprId.
-    def visitExprId(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprAbs.
-    def visitExprAbs(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#ExprAddition.
-    def visitExprAddition(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Leq.
-    def visitLeq(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Geq.
-    def visitGeq(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Less.
-    def visitLess(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Greater.
-    def visitGreater(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Eq.
-    def visitEq(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Neq.
-    def visitNeq(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#literal.
-    def visitLiteral(self, ctx):
-        return self.visitChildren(ctx)
-
-
-    # Visit a parse tree produced by LtlParser#Id.
-    def visitId(self, ctx):
-        return self.visitChildren(ctx)
-
-
+# Generated from LtlParser.g4 by ANTLR 4.7.2
+from antlr4 import *
+
+# This class defines a complete generic visitor for a parse tree produced by LtlParser.
+
+class LtlParserVisitor(ParseTreeVisitor):
+
+    # Visit a parse tree produced by LtlParser#specification_file.
+    def visitSpecification_file(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#specification.
+    def visitSpecification(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#SpecificationId.
+    def visitSpecificationId(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#modImport.
+    def visitModImport(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#assertion.
+    def visitAssertion(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#declVariable.
+    def visitDeclVariable(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#declConstant.
+    def visitDeclConstant(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#annotation.
+    def visitAnnotation(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#rosTopic.
+    def visitRosTopic(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#variableDeclaration.
+    def visitVariableDeclaration(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#constantDeclaration.
+    def visitConstantDeclaration(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#AsgnLiteral.
+    def visitAsgnLiteral(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#AsgnExpr.
+    def visitAsgnExpr(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#domainType.
+    def visitDomainType(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ioType.
+    def visitIoType(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprSince.
+    def visitExprSince(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprParen.
+    def visitExprParen(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprIff.
+    def visitExprIff(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExpreOnce.
+    def visitExpreOnce(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprEv.
+    def visitExprEv(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprImplies.
+    def visitExprImplies(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprUntil.
+    def visitExprUntil(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprNot.
+    def visitExprNot(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprNext.
+    def visitExprNext(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprAnd.
+    def visitExprAnd(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprUnless.
+    def visitExprUnless(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprPrevious.
+    def visitExprPrevious(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprHist.
+    def visitExprHist(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprFall.
+    def visitExprFall(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprPredicate.
+    def visitExprPredicate(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprXor.
+    def visitExprXor(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprRise.
+    def visitExprRise(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprOr.
+    def visitExprOr(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprAlways.
+    def visitExprAlways(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprReal.
+    def visitExprReal(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprSubtraction.
+    def visitExprSubtraction(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprPow.
+    def visitExprPow(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprDivision.
+    def visitExprDivision(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprMultiplication.
+    def visitExprMultiplication(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprLiteral.
+    def visitExprLiteral(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprExp.
+    def visitExprExp(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprSqrt.
+    def visitExprSqrt(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprId.
+    def visitExprId(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprAbs.
+    def visitExprAbs(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#ExprAddition.
+    def visitExprAddition(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Leq.
+    def visitLeq(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Geq.
+    def visitGeq(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Less.
+    def visitLess(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Greater.
+    def visitGreater(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Eq.
+    def visitEq(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Neq.
+    def visitNeq(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#literal.
+    def visitLiteral(self, ctx):
+        return self.visitChildren(ctx)
+
+
+    # Visit a parse tree produced by LtlParser#Id.
+    def visitId(self, ctx):
+        return self.visitChildren(ctx)
+
+
```

### Comparing `rtamt-0.3/rtamt/parser/stl/StlParser.py` & `rtamt-0.3.5/rtamt/antlr/parser/stl/StlParser.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,2863 +1,2894 @@
-# Generated from StlParser.g4 by ANTLR 4.5.1
-# encoding: utf-8
-from __future__ import print_function
-from antlr4 import *
-from io import StringIO
-
-def serializedATN():
-    with StringIO() as buf:
-        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
-        buf.write(u"K\u011d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
-        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
-        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
-        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\3\2\3\2\3\2\3")
-        buf.write(u"\2\3\2\3\2\3\3\3\3\5\3\65\n\3\3\3\3\3\5\39\n\3\5\3;\n")
-        buf.write(u"\3\3\4\3\4\3\5\3\5\3\5\3\5\3\5\5\5D\n\5\3\5\3\5\3\5\5")
-        buf.write(u"\5I\n\5\3\5\3\5\3\5\5\5N\n\5\3\5\3\5\3\5\5\5S\n\5\3\5")
-        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
-        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\5\5i\n\5\3\5\3\5\3\5\3\5\3\5")
-        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
-        buf.write(u"\3\5\3\5\3\5\3\5\5\5\u0081\n\5\3\5\3\5\3\5\3\5\5\5\u0087")
-        buf.write(u"\n\5\3\5\3\5\3\5\3\5\5\5\u008d\n\5\3\5\7\5\u0090\n\5")
-        buf.write(u"\f\5\16\5\u0093\13\5\3\6\3\6\3\6\3\7\5\7\u0099\n\7\3")
-        buf.write(u"\7\7\7\u009c\n\7\f\7\16\7\u009f\13\7\3\7\3\7\7\7\u00a3")
-        buf.write(u"\n\7\f\7\16\7\u00a6\13\7\3\7\6\7\u00a9\n\7\r\7\16\7\u00aa")
-        buf.write(u"\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\n\3\n\5\n\u00b7\n")
-        buf.write(u"\n\3\n\3\n\3\13\3\13\5\13\u00bd\n\13\3\f\3\f\3\f\3\r")
-        buf.write(u"\3\r\3\r\3\r\3\r\3\r\3\r\3\16\5\16\u00ca\n\16\3\16\3")
-        buf.write(u"\16\3\16\5\16\u00cf\n\16\3\17\3\17\3\17\3\17\3\17\3\17")
-        buf.write(u"\3\20\3\20\3\20\3\20\5\20\u00db\n\20\3\21\3\21\3\22\3")
-        buf.write(u"\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
-        buf.write(u"\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3")
-        buf.write(u"\23\3\23\3\23\3\23\3\23\5\23\u00fa\n\23\3\23\3\23\3\23")
-        buf.write(u"\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\7\23\u0108")
-        buf.write(u"\n\23\f\23\16\23\u010b\13\23\3\24\3\24\3\24\3\24\3\24")
-        buf.write(u"\3\24\5\24\u0113\n\24\3\25\3\25\3\25\3\25\5\25\u0119")
-        buf.write(u"\n\25\3\26\3\26\3\26\2\4\b$\27\2\4\6\b\n\f\16\20\22\24")
-        buf.write(u"\26\30\32\34\36 \"$&(*\2\6\3\2\16\17\3\2\26\31\4\2\"")
-        buf.write(u"%GG\3\2\35\36\u013e\2,\3\2\2\2\4:\3\2\2\2\6<\3\2\2\2")
-        buf.write(u"\bh\3\2\2\2\n\u0094\3\2\2\2\f\u0098\3\2\2\2\16\u00ac")
-        buf.write(u"\3\2\2\2\20\u00af\3\2\2\2\22\u00b6\3\2\2\2\24\u00bc\3")
-        buf.write(u"\2\2\2\26\u00be\3\2\2\2\30\u00c1\3\2\2\2\32\u00c9\3\2")
-        buf.write(u"\2\2\34\u00d0\3\2\2\2\36\u00da\3\2\2\2 \u00dc\3\2\2\2")
-        buf.write(u"\"\u00de\3\2\2\2$\u00f9\3\2\2\2&\u0112\3\2\2\2(\u0118")
-        buf.write(u"\3\2\2\2*\u011a\3\2\2\2,-\7\13\2\2-.\5\4\3\2./\t\2\2")
-        buf.write(u"\2/\60\5\4\3\2\60\61\7\f\2\2\61\3\3\2\2\2\62\64\5(\25")
-        buf.write(u"\2\63\65\5\6\4\2\64\63\3\2\2\2\64\65\3\2\2\2\65;\3\2")
-        buf.write(u"\2\2\668\7G\2\2\679\5\6\4\28\67\3\2\2\289\3\2\2\29;\3")
-        buf.write(u"\2\2\2:\62\3\2\2\2:\66\3\2\2\2;\5\3\2\2\2<=\t\3\2\2=")
-        buf.write(u"\7\3\2\2\2>?\b\5\1\2?@\7*\2\2@i\5\b\5\23AC\7\62\2\2B")
-        buf.write(u"D\5\2\2\2CB\3\2\2\2CD\3\2\2\2DE\3\2\2\2Ei\5\b\5\rFH\7")
-        buf.write(u"\63\2\2GI\5\2\2\2HG\3\2\2\2HI\3\2\2\2IJ\3\2\2\2Ji\5\b")
-        buf.write(u"\5\fKM\7\66\2\2LN\5\2\2\2ML\3\2\2\2MN\3\2\2\2NO\3\2\2")
-        buf.write(u"\2Oi\5\b\5\tPR\7\67\2\2QS\5\2\2\2RQ\3\2\2\2RS\3\2\2\2")
-        buf.write(u"ST\3\2\2\2Ti\5\b\5\bUV\7:\2\2Vi\5\b\5\4WX\79\2\2Xi\5")
-        buf.write(u"\b\5\3Yi\5$\23\2Z[\7\7\2\2[\\\5\b\5\2\\]\7\b\2\2]i\3")
-        buf.write(u"\2\2\2^_\7\60\2\2_`\7\7\2\2`a\5\b\5\2ab\7\b\2\2bi\3\2")
-        buf.write(u"\2\2cd\7\61\2\2de\7\7\2\2ef\5\b\5\2fg\7\b\2\2gi\3\2\2")
-        buf.write(u"\2h>\3\2\2\2hA\3\2\2\2hF\3\2\2\2hK\3\2\2\2hP\3\2\2\2")
-        buf.write(u"hU\3\2\2\2hW\3\2\2\2hY\3\2\2\2hZ\3\2\2\2h^\3\2\2\2hc")
-        buf.write(u"\3\2\2\2i\u0091\3\2\2\2jk\f\25\2\2kl\5&\24\2lm\5\b\5")
-        buf.write(u"\26m\u0090\3\2\2\2no\f\22\2\2op\7+\2\2p\u0090\5\b\5\23")
-        buf.write(u"qr\f\21\2\2rs\7,\2\2s\u0090\5\b\5\22tu\f\20\2\2uv\7.")
-        buf.write(u"\2\2v\u0090\5\b\5\21wx\f\17\2\2xy\7-\2\2y\u0090\5\b\5")
-        buf.write(u"\20z{\f\16\2\2{|\7/\2\2|\u0090\5\b\5\17}~\f\13\2\2~\u0080")
-        buf.write(u"\7\64\2\2\177\u0081\5\2\2\2\u0080\177\3\2\2\2\u0080\u0081")
-        buf.write(u"\3\2\2\2\u0081\u0082\3\2\2\2\u0082\u0090\5\b\5\f\u0083")
-        buf.write(u"\u0084\f\n\2\2\u0084\u0086\7\65\2\2\u0085\u0087\5\2\2")
-        buf.write(u"\2\u0086\u0085\3\2\2\2\u0086\u0087\3\2\2\2\u0087\u0088")
-        buf.write(u"\3\2\2\2\u0088\u0090\5\b\5\13\u0089\u008a\f\7\2\2\u008a")
-        buf.write(u"\u008c\78\2\2\u008b\u008d\5\2\2\2\u008c\u008b\3\2\2\2")
-        buf.write(u"\u008c\u008d\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u0090")
-        buf.write(u"\5\b\5\b\u008fj\3\2\2\2\u008fn\3\2\2\2\u008fq\3\2\2\2")
-        buf.write(u"\u008ft\3\2\2\2\u008fw\3\2\2\2\u008fz\3\2\2\2\u008f}")
-        buf.write(u"\3\2\2\2\u008f\u0083\3\2\2\2\u008f\u0089\3\2\2\2\u0090")
-        buf.write(u"\u0093\3\2\2\2\u0091\u008f\3\2\2\2\u0091\u0092\3\2\2")
-        buf.write(u"\2\u0092\t\3\2\2\2\u0093\u0091\3\2\2\2\u0094\u0095\5")
-        buf.write(u"\f\7\2\u0095\u0096\7\2\2\3\u0096\13\3\2\2\2\u0097\u0099")
-        buf.write(u"\5\16\b\2\u0098\u0097\3\2\2\2\u0098\u0099\3\2\2\2\u0099")
-        buf.write(u"\u009d\3\2\2\2\u009a\u009c\5\20\t\2\u009b\u009a\3\2\2")
-        buf.write(u"\2\u009c\u009f\3\2\2\2\u009d\u009b\3\2\2\2\u009d\u009e")
-        buf.write(u"\3\2\2\2\u009e\u00a4\3\2\2\2\u009f\u009d\3\2\2\2\u00a0")
-        buf.write(u"\u00a3\5\24\13\2\u00a1\u00a3\5\26\f\2\u00a2\u00a0\3\2")
-        buf.write(u"\2\2\u00a2\u00a1\3\2\2\2\u00a3\u00a6\3\2\2\2\u00a4\u00a2")
-        buf.write(u"\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a8\3\2\2\2\u00a6")
-        buf.write(u"\u00a4\3\2\2\2\u00a7\u00a9\5\22\n\2\u00a8\u00a7\3\2\2")
-        buf.write(u"\2\u00a9\u00aa\3\2\2\2\u00aa\u00a8\3\2\2\2\u00aa\u00ab")
-        buf.write(u"\3\2\2\2\u00ab\r\3\2\2\2\u00ac\u00ad\7(\2\2\u00ad\u00ae")
-        buf.write(u"\7G\2\2\u00ae\17\3\2\2\2\u00af\u00b0\7)\2\2\u00b0\u00b1")
-        buf.write(u"\7G\2\2\u00b1\u00b2\7\34\2\2\u00b2\u00b3\7G\2\2\u00b3")
-        buf.write(u"\21\3\2\2\2\u00b4\u00b5\7G\2\2\u00b5\u00b7\7A\2\2\u00b6")
-        buf.write(u"\u00b4\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\u00b8\3\2\2")
-        buf.write(u"\2\u00b8\u00b9\5\b\5\2\u00b9\23\3\2\2\2\u00ba\u00bd\5")
-        buf.write(u"\32\16\2\u00bb\u00bd\5\34\17\2\u00bc\u00ba\3\2\2\2\u00bc")
-        buf.write(u"\u00bb\3\2\2\2\u00bd\25\3\2\2\2\u00be\u00bf\7\21\2\2")
-        buf.write(u"\u00bf\u00c0\5\30\r\2\u00c0\27\3\2\2\2\u00c1\u00c2\7")
-        buf.write(u"\33\2\2\u00c2\u00c3\7\7\2\2\u00c3\u00c4\7G\2\2\u00c4")
-        buf.write(u"\u00c5\7\17\2\2\u00c5\u00c6\7G\2\2\u00c6\u00c7\7\b\2")
-        buf.write(u"\2\u00c7\31\3\2\2\2\u00c8\u00ca\5\"\22\2\u00c9\u00c8")
-        buf.write(u"\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca\u00cb\3\2\2\2\u00cb")
-        buf.write(u"\u00cc\5 \21\2\u00cc\u00ce\7G\2\2\u00cd\u00cf\5\36\20")
-        buf.write(u"\2\u00ce\u00cd\3\2\2\2\u00ce\u00cf\3\2\2\2\u00cf\33\3")
-        buf.write(u"\2\2\2\u00d0\u00d1\7 \2\2\u00d1\u00d2\5 \21\2\u00d2\u00d3")
-        buf.write(u"\7G\2\2\u00d3\u00d4\7A\2\2\u00d4\u00d5\5(\25\2\u00d5")
-        buf.write(u"\35\3\2\2\2\u00d6\u00d7\7A\2\2\u00d7\u00db\5(\25\2\u00d8")
-        buf.write(u"\u00d9\7A\2\2\u00d9\u00db\5\b\5\2\u00da\u00d6\3\2\2\2")
-        buf.write(u"\u00da\u00d8\3\2\2\2\u00db\37\3\2\2\2\u00dc\u00dd\t\4")
-        buf.write(u"\2\2\u00dd!\3\2\2\2\u00de\u00df\t\5\2\2\u00df#\3\2\2")
-        buf.write(u"\2\u00e0\u00e1\b\23\1\2\u00e1\u00fa\7G\2\2\u00e2\u00fa")
-        buf.write(u"\5(\25\2\u00e3\u00e4\7\22\2\2\u00e4\u00e5\7\7\2\2\u00e5")
-        buf.write(u"\u00e6\5$\23\2\u00e6\u00e7\7\b\2\2\u00e7\u00fa\3\2\2")
-        buf.write(u"\2\u00e8\u00e9\7\23\2\2\u00e9\u00ea\7\7\2\2\u00ea\u00eb")
-        buf.write(u"\5$\23\2\u00eb\u00ec\7\b\2\2\u00ec\u00fa\3\2\2\2\u00ed")
-        buf.write(u"\u00ee\7\24\2\2\u00ee\u00ef\7\7\2\2\u00ef\u00f0\5$\23")
-        buf.write(u"\2\u00f0\u00f1\7\b\2\2\u00f1\u00fa\3\2\2\2\u00f2\u00f3")
-        buf.write(u"\7\25\2\2\u00f3\u00f4\7\7\2\2\u00f4\u00f5\5$\23\2\u00f5")
-        buf.write(u"\u00f6\7\17\2\2\u00f6\u00f7\5$\23\2\u00f7\u00f8\7\b\2")
-        buf.write(u"\2\u00f8\u00fa\3\2\2\2\u00f9\u00e0\3\2\2\2\u00f9\u00e2")
-        buf.write(u"\3\2\2\2\u00f9\u00e3\3\2\2\2\u00f9\u00e8\3\2\2\2\u00f9")
-        buf.write(u"\u00ed\3\2\2\2\u00f9\u00f2\3\2\2\2\u00fa\u0109\3\2\2")
-        buf.write(u"\2\u00fb\u00fc\f\n\2\2\u00fc\u00fd\7\4\2\2\u00fd\u0108")
-        buf.write(u"\5$\23\13\u00fe\u00ff\f\t\2\2\u00ff\u0100\7\3\2\2\u0100")
-        buf.write(u"\u0108\5$\23\n\u0101\u0102\f\b\2\2\u0102\u0103\7\5\2")
-        buf.write(u"\2\u0103\u0108\5$\23\t\u0104\u0105\f\7\2\2\u0105\u0106")
-        buf.write(u"\7\6\2\2\u0106\u0108\5$\23\b\u0107\u00fb\3\2\2\2\u0107")
-        buf.write(u"\u00fe\3\2\2\2\u0107\u0101\3\2\2\2\u0107\u0104\3\2\2")
-        buf.write(u"\2\u0108\u010b\3\2\2\2\u0109\u0107\3\2\2\2\u0109\u010a")
-        buf.write(u"\3\2\2\2\u010a%\3\2\2\2\u010b\u0109\3\2\2\2\u010c\u0113")
-        buf.write(u"\7>\2\2\u010d\u0113\7=\2\2\u010e\u0113\7@\2\2\u010f\u0113")
-        buf.write(u"\7?\2\2\u0110\u0113\7;\2\2\u0111\u0113\7<\2\2\u0112\u010c")
-        buf.write(u"\3\2\2\2\u0112\u010d\3\2\2\2\u0112\u010e\3\2\2\2\u0112")
-        buf.write(u"\u010f\3\2\2\2\u0112\u0110\3\2\2\2\u0112\u0111\3\2\2")
-        buf.write(u"\2\u0113\'\3\2\2\2\u0114\u0119\7E\2\2\u0115\u0119\7F")
-        buf.write(u"\2\2\u0116\u0117\7\3\2\2\u0117\u0119\5(\25\2\u0118\u0114")
-        buf.write(u"\3\2\2\2\u0118\u0115\3\2\2\2\u0118\u0116\3\2\2\2\u0119")
-        buf.write(u")\3\2\2\2\u011a\u011b\7G\2\2\u011b+\3\2\2\2\36\648:C")
-        buf.write(u"HMRh\u0080\u0086\u008c\u008f\u0091\u0098\u009d\u00a2")
-        buf.write(u"\u00a4\u00aa\u00b6\u00bc\u00c9\u00ce\u00da\u00f9\u0107")
-        buf.write(u"\u0109\u0112\u0118")
-        return buf.getvalue()
-
-
-class StlParser ( Parser ):
-
-    grammarFileName = "StlParser.g4"
-
-    atn = ATNDeserializer().deserialize(serializedATN())
-
-    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]
-
-    sharedContextCache = PredictionContextCache()
-
-    literalNames = [ u"<INVALID>", u"'-'", u"'+'", u"'*'", u"'/'", u"'('", 
-                     u"')'", u"'{'", u"'}'", u"'['", u"']'", u"';'", u"':'", 
-                     u"','", u"'.'", u"'@'", u"'abs'", u"'sqrt'", u"'exp'", 
-                     u"'pow'", u"'s'", u"'ms'", u"'us'", u"'ns'", u"'ps'", 
-                     u"'topic'", u"'import'", u"'input'", u"'output'", u"'internal'", 
-                     u"'const'", u"'real'", u"'float'", u"'long'", u"'complex'", 
-                     u"'int'", u"'bool'", u"'assertion'", u"'specification'", 
-                     u"'from'", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"<INVALID>", u"'xor'", u"'rise'", u"'fall'", 
-                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"'=='", u"'!=='", u"'>='", u"'<='", 
-                     u"'>'", u"'<'", u"'='" ]
-
-    symbolicNames = [ u"<INVALID>", u"MINUS", u"PLUS", u"TIMES", u"DIVIDE", 
-                      u"LPAREN", u"RPAREN", u"LBRACE", u"RBRACE", u"LBRACK", 
-                      u"RBRACK", u"SEMICOLON", u"COLON", u"COMMA", u"DOT", 
-                      u"AT", u"ABS", u"SQRT", u"EXP", u"POW", u"SEC", u"MSEC", 
-                      u"USEC", u"NSEC", u"PSEC", u"ROS_Topic", u"Import", 
-                      u"Input", u"Output", u"Internal", u"Constant", u"DomainTypeReal", 
-                      u"DomainTypeFloat", u"DomainTypeLong", u"DomainTypeComplex", 
-                      u"DomainTypeInt", u"DomainTypeBool", u"Assertion", 
-                      u"Specification", u"From", u"NotOperator", u"OrOperator", 
-                      u"AndOperator", u"IffOperator", u"ImpliesOperator", 
-                      u"XorOperator", u"RiseOperator", u"FallOperator", 
-                      u"AlwaysOperator", u"EventuallyOperator", u"UntilOperator", 
-                      u"UnlessOperator", u"HistoricallyOperator", u"OnceOperator", 
-                      u"SinceOperator", u"NextOperator", u"PreviousOperator", 
-                      u"EqualOperator", u"NotEqualOperator", u"GreaterOrEqualOperator", 
-                      u"LesserOrEqualOperator", u"GreaterOperator", u"LesserOperator", 
-                      u"EQUAL", u"BooleanLiteral", u"TRUE", u"FALSE", u"IntegerLiteral", 
-                      u"RealLiteral", u"Identifier", u"LINE_TERMINATOR", 
-                      u"WHITESPACE", u"COMMENT", u"LINE_COMMENT" ]
-
-    RULE_interval = 0
-    RULE_intervalTime = 1
-    RULE_unit = 2
-    RULE_expression = 3
-    RULE_specification_file = 4
-    RULE_specification = 5
-    RULE_spec = 6
-    RULE_modimport = 7
-    RULE_assertion = 8
-    RULE_declaration = 9
-    RULE_annotation = 10
-    RULE_annotation_type = 11
-    RULE_variableDeclaration = 12
-    RULE_constantDeclaration = 13
-    RULE_assignment = 14
-    RULE_domainType = 15
-    RULE_ioType = 16
-    RULE_real_expression = 17
-    RULE_comparisonOp = 18
-    RULE_literal = 19
-    RULE_identifier = 20
-
-    ruleNames =  [ u"interval", u"intervalTime", u"unit", u"expression", 
-                   u"specification_file", u"specification", u"spec", u"modimport", 
-                   u"assertion", u"declaration", u"annotation", u"annotation_type", 
-                   u"variableDeclaration", u"constantDeclaration", u"assignment", 
-                   u"domainType", u"ioType", u"real_expression", u"comparisonOp", 
-                   u"literal", u"identifier" ]
-
-    EOF = Token.EOF
-    MINUS=1
-    PLUS=2
-    TIMES=3
-    DIVIDE=4
-    LPAREN=5
-    RPAREN=6
-    LBRACE=7
-    RBRACE=8
-    LBRACK=9
-    RBRACK=10
-    SEMICOLON=11
-    COLON=12
-    COMMA=13
-    DOT=14
-    AT=15
-    ABS=16
-    SQRT=17
-    EXP=18
-    POW=19
-    SEC=20
-    MSEC=21
-    USEC=22
-    NSEC=23
-    PSEC=24
-    ROS_Topic=25
-    Import=26
-    Input=27
-    Output=28
-    Internal=29
-    Constant=30
-    DomainTypeReal=31
-    DomainTypeFloat=32
-    DomainTypeLong=33
-    DomainTypeComplex=34
-    DomainTypeInt=35
-    DomainTypeBool=36
-    Assertion=37
-    Specification=38
-    From=39
-    NotOperator=40
-    OrOperator=41
-    AndOperator=42
-    IffOperator=43
-    ImpliesOperator=44
-    XorOperator=45
-    RiseOperator=46
-    FallOperator=47
-    AlwaysOperator=48
-    EventuallyOperator=49
-    UntilOperator=50
-    UnlessOperator=51
-    HistoricallyOperator=52
-    OnceOperator=53
-    SinceOperator=54
-    NextOperator=55
-    PreviousOperator=56
-    EqualOperator=57
-    NotEqualOperator=58
-    GreaterOrEqualOperator=59
-    LesserOrEqualOperator=60
-    GreaterOperator=61
-    LesserOperator=62
-    EQUAL=63
-    BooleanLiteral=64
-    TRUE=65
-    FALSE=66
-    IntegerLiteral=67
-    RealLiteral=68
-    Identifier=69
-    LINE_TERMINATOR=70
-    WHITESPACE=71
-    COMMENT=72
-    LINE_COMMENT=73
-
-    def __init__(self, input):
-        super(StlParser, self).__init__(input)
-        self.checkVersion("4.5.1")
-        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
-        self._predicates = None
-
-
-
-    class IntervalContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.IntervalContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def LBRACK(self):
-            return self.getToken(StlParser.LBRACK, 0)
-
-        def intervalTime(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.IntervalTimeContext)
-            else:
-                return self.getTypedRuleContext(StlParser.IntervalTimeContext,i)
-
-
-        def RBRACK(self):
-            return self.getToken(StlParser.RBRACK, 0)
-
-        def COLON(self):
-            return self.getToken(StlParser.COLON, 0)
-
-        def COMMA(self):
-            return self.getToken(StlParser.COMMA, 0)
-
-        def getRuleIndex(self):
-            return StlParser.RULE_interval
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitInterval"):
-                return visitor.visitInterval(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def interval(self):
-
-        localctx = StlParser.IntervalContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 0, self.RULE_interval)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 42
-            self.match(StlParser.LBRACK)
-            self.state = 43
-            self.intervalTime()
-            self.state = 44
-            _la = self._input.LA(1)
-            if not(_la==StlParser.COLON or _la==StlParser.COMMA):
-                self._errHandler.recoverInline(self)
-            else:
-                self.consume()
-            self.state = 45
-            self.intervalTime()
-            self.state = 46
-            self.match(StlParser.RBRACK)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class IntervalTimeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.IntervalTimeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_intervalTime
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.IntervalTimeContext, self).copyFrom(ctx)
-
-
-
-    class IntervalTimeLiteralContext(IntervalTimeContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.IntervalTimeContext)
-            super(StlParser.IntervalTimeLiteralContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def literal(self):
-            return self.getTypedRuleContext(StlParser.LiteralContext,0)
-
-        def unit(self):
-            return self.getTypedRuleContext(StlParser.UnitContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitIntervalTimeLiteral"):
-                return visitor.visitIntervalTimeLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ConstantTimeLiteralContext(IntervalTimeContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.IntervalTimeContext)
-            super(StlParser.ConstantTimeLiteralContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-        def unit(self):
-            return self.getTypedRuleContext(StlParser.UnitContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitConstantTimeLiteral"):
-                return visitor.visitConstantTimeLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def intervalTime(self):
-
-        localctx = StlParser.IntervalTimeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 2, self.RULE_intervalTime)
-        self._la = 0 # Token type
-        try:
-            self.state = 56
-            token = self._input.LA(1)
-            if token in [StlParser.MINUS, StlParser.IntegerLiteral, StlParser.RealLiteral]:
-                localctx = StlParser.IntervalTimeLiteralContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 48
-                self.literal()
-                self.state = 50
-                _la = self._input.LA(1)
-                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.SEC) | (1 << StlParser.MSEC) | (1 << StlParser.USEC) | (1 << StlParser.NSEC))) != 0):
-                    self.state = 49
-                    self.unit()
-
-
-
-            elif token in [StlParser.Identifier]:
-                localctx = StlParser.ConstantTimeLiteralContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 52
-                self.match(StlParser.Identifier)
-                self.state = 54
-                _la = self._input.LA(1)
-                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.SEC) | (1 << StlParser.MSEC) | (1 << StlParser.USEC) | (1 << StlParser.NSEC))) != 0):
-                    self.state = 53
-                    self.unit()
-
-
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class UnitContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.UnitContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def SEC(self):
-            return self.getToken(StlParser.SEC, 0)
-
-        def MSEC(self):
-            return self.getToken(StlParser.MSEC, 0)
-
-        def USEC(self):
-            return self.getToken(StlParser.USEC, 0)
-
-        def NSEC(self):
-            return self.getToken(StlParser.NSEC, 0)
-
-        def getRuleIndex(self):
-            return StlParser.RULE_unit
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitUnit"):
-                return visitor.visitUnit(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def unit(self):
-
-        localctx = StlParser.UnitContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 4, self.RULE_unit)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 58
-            _la = self._input.LA(1)
-            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.SEC) | (1 << StlParser.MSEC) | (1 << StlParser.USEC) | (1 << StlParser.NSEC))) != 0)):
-                self._errHandler.recoverInline(self)
-            else:
-                self.consume()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class ExpressionContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.ExpressionContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_expression
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.ExpressionContext, self).copyFrom(ctx)
-
-
-    class ExprSinceContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprSinceContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def SinceOperator(self):
-            return self.getToken(StlParser.SinceOperator, 0)
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprSince"):
-                return visitor.visitExprSince(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprParenContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprParenContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprParen"):
-                return visitor.visitExprParen(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprIffContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprIffContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def IffOperator(self):
-            return self.getToken(StlParser.IffOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprIff"):
-                return visitor.visitExprIff(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExpreOnceContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExpreOnceContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def OnceOperator(self):
-            return self.getToken(StlParser.OnceOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExpreOnce"):
-                return visitor.visitExpreOnce(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprEvContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprEvContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EventuallyOperator(self):
-            return self.getToken(StlParser.EventuallyOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprEv"):
-                return visitor.visitExprEv(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprImpliesContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprImpliesContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def ImpliesOperator(self):
-            return self.getToken(StlParser.ImpliesOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprImplies"):
-                return visitor.visitExprImplies(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprUntilContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprUntilContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def UntilOperator(self):
-            return self.getToken(StlParser.UntilOperator, 0)
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprUntil"):
-                return visitor.visitExprUntil(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprNotContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprNotContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def NotOperator(self):
-            return self.getToken(StlParser.NotOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprNot"):
-                return visitor.visitExprNot(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprNextContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprNextContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def NextOperator(self):
-            return self.getToken(StlParser.NextOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprNext"):
-                return visitor.visitExprNext(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAndContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprAndContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def AndOperator(self):
-            return self.getToken(StlParser.AndOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAnd"):
-                return visitor.visitExprAnd(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprUnlessContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprUnlessContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def UnlessOperator(self):
-            return self.getToken(StlParser.UnlessOperator, 0)
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprUnless"):
-                return visitor.visitExprUnless(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprPreviousContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprPreviousContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def PreviousOperator(self):
-            return self.getToken(StlParser.PreviousOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprPrevious"):
-                return visitor.visitExprPrevious(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprHistContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprHistContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def HistoricallyOperator(self):
-            return self.getToken(StlParser.HistoricallyOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprHist"):
-                return visitor.visitExprHist(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprFallContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprFallContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def FallOperator(self):
-            return self.getToken(StlParser.FallOperator, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprFall"):
-                return visitor.visitExprFall(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprPredicateContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprPredicateContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def comparisonOp(self):
-            return self.getTypedRuleContext(StlParser.ComparisonOpContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprPredicate"):
-                return visitor.visitExprPredicate(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprXorContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprXorContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def XorOperator(self):
-            return self.getToken(StlParser.XorOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprXor"):
-                return visitor.visitExprXor(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprRiseContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprRiseContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def RiseOperator(self):
-            return self.getToken(StlParser.RiseOperator, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprRise"):
-                return visitor.visitExprRise(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprOrContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprOrContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ExpressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
-
-        def OrOperator(self):
-            return self.getToken(StlParser.OrOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprOr"):
-                return visitor.visitExprOr(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAlwaysContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprAlwaysContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def AlwaysOperator(self):
-            return self.getToken(StlParser.AlwaysOperator, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-        def interval(self):
-            return self.getTypedRuleContext(StlParser.IntervalContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAlways"):
-                return visitor.visitExprAlways(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprRealContext(ExpressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
-            super(StlParser.ExprRealContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self):
-            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprReal"):
-                return visitor.visitExprReal(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def expression(self, _p=0):
-        _parentctx = self._ctx
-        _parentState = self.state
-        localctx = StlParser.ExpressionContext(self, self._ctx, _parentState)
-        _prevctx = localctx
-        _startState = 6
-        self.enterRecursionRule(localctx, 6, self.RULE_expression, _p)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 102
-            token = self._input.LA(1)
-            if token in [StlParser.NotOperator]:
-                localctx = StlParser.ExprNotContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-
-                self.state = 61
-                self.match(StlParser.NotOperator)
-                self.state = 62
-                self.expression(17)
-
-            elif token in [StlParser.AlwaysOperator]:
-                localctx = StlParser.ExprAlwaysContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 63
-                self.match(StlParser.AlwaysOperator)
-                self.state = 65
-                _la = self._input.LA(1)
-                if _la==StlParser.LBRACK:
-                    self.state = 64
-                    self.interval()
-
-
-                self.state = 67
-                self.expression(11)
-
-            elif token in [StlParser.EventuallyOperator]:
-                localctx = StlParser.ExprEvContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 68
-                self.match(StlParser.EventuallyOperator)
-                self.state = 70
-                _la = self._input.LA(1)
-                if _la==StlParser.LBRACK:
-                    self.state = 69
-                    self.interval()
-
-
-                self.state = 72
-                self.expression(10)
-
-            elif token in [StlParser.HistoricallyOperator]:
-                localctx = StlParser.ExprHistContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 73
-                self.match(StlParser.HistoricallyOperator)
-                self.state = 75
-                _la = self._input.LA(1)
-                if _la==StlParser.LBRACK:
-                    self.state = 74
-                    self.interval()
-
-
-                self.state = 77
-                self.expression(7)
-
-            elif token in [StlParser.OnceOperator]:
-                localctx = StlParser.ExpreOnceContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 78
-                self.match(StlParser.OnceOperator)
-                self.state = 80
-                _la = self._input.LA(1)
-                if _la==StlParser.LBRACK:
-                    self.state = 79
-                    self.interval()
-
-
-                self.state = 82
-                self.expression(6)
-
-            elif token in [StlParser.PreviousOperator]:
-                localctx = StlParser.ExprPreviousContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 83
-                self.match(StlParser.PreviousOperator)
-                self.state = 84
-                self.expression(2)
-
-            elif token in [StlParser.NextOperator]:
-                localctx = StlParser.ExprNextContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 85
-                self.match(StlParser.NextOperator)
-                self.state = 86
-                self.expression(1)
-
-            elif token in [StlParser.MINUS, StlParser.ABS, StlParser.SQRT, StlParser.EXP, StlParser.POW, StlParser.IntegerLiteral, StlParser.RealLiteral, StlParser.Identifier]:
-                localctx = StlParser.ExprRealContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 87
-                self.real_expression(0)
-
-            elif token in [StlParser.LPAREN]:
-                localctx = StlParser.ExprParenContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 88
-                self.match(StlParser.LPAREN)
-                self.state = 89
-                self.expression(0)
-                self.state = 90
-                self.match(StlParser.RPAREN)
-
-            elif token in [StlParser.RiseOperator]:
-                localctx = StlParser.ExprRiseContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 92
-                self.match(StlParser.RiseOperator)
-                self.state = 93
-                self.match(StlParser.LPAREN)
-                self.state = 94
-                self.expression(0)
-                self.state = 95
-                self.match(StlParser.RPAREN)
-
-            elif token in [StlParser.FallOperator]:
-                localctx = StlParser.ExprFallContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 97
-                self.match(StlParser.FallOperator)
-                self.state = 98
-                self.match(StlParser.LPAREN)
-                self.state = 99
-                self.expression(0)
-                self.state = 100
-                self.match(StlParser.RPAREN)
-
-            else:
-                raise NoViableAltException(self)
-
-            self._ctx.stop = self._input.LT(-1)
-            self.state = 143
-            self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
-                    if self._parseListeners is not None:
-                        self.triggerExitRuleEvent()
-                    _prevctx = localctx
-                    self.state = 141
-                    la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
-                    if la_ == 1:
-                        localctx = StlParser.ExprPredicateContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 104
-                        if not self.precpred(self._ctx, 19):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
-                        self.state = 105
-                        self.comparisonOp()
-                        self.state = 106
-                        self.expression(20)
-                        pass
-
-                    elif la_ == 2:
-                        localctx = StlParser.ExprOrContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 108
-                        if not self.precpred(self._ctx, 16):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
-                        self.state = 109
-                        self.match(StlParser.OrOperator)
-                        self.state = 110
-                        self.expression(17)
-                        pass
-
-                    elif la_ == 3:
-                        localctx = StlParser.ExprAndContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 111
-                        if not self.precpred(self._ctx, 15):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
-                        self.state = 112
-                        self.match(StlParser.AndOperator)
-                        self.state = 113
-                        self.expression(16)
-                        pass
-
-                    elif la_ == 4:
-                        localctx = StlParser.ExprImpliesContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 114
-                        if not self.precpred(self._ctx, 14):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
-                        self.state = 115
-                        self.match(StlParser.ImpliesOperator)
-                        self.state = 116
-                        self.expression(15)
-                        pass
-
-                    elif la_ == 5:
-                        localctx = StlParser.ExprIffContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 117
-                        if not self.precpred(self._ctx, 13):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
-                        self.state = 118
-                        self.match(StlParser.IffOperator)
-                        self.state = 119
-                        self.expression(14)
-                        pass
-
-                    elif la_ == 6:
-                        localctx = StlParser.ExprXorContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 120
-                        if not self.precpred(self._ctx, 12):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
-                        self.state = 121
-                        self.match(StlParser.XorOperator)
-                        self.state = 122
-                        self.expression(13)
-                        pass
-
-                    elif la_ == 7:
-                        localctx = StlParser.ExprUntilContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 123
-                        if not self.precpred(self._ctx, 9):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
-                        self.state = 124
-                        self.match(StlParser.UntilOperator)
-                        self.state = 126
-                        _la = self._input.LA(1)
-                        if _la==StlParser.LBRACK:
-                            self.state = 125
-                            self.interval()
-
-
-                        self.state = 128
-                        self.expression(10)
-                        pass
-
-                    elif la_ == 8:
-                        localctx = StlParser.ExprUnlessContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 129
-                        if not self.precpred(self._ctx, 8):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
-                        self.state = 130
-                        self.match(StlParser.UnlessOperator)
-                        self.state = 132
-                        _la = self._input.LA(1)
-                        if _la==StlParser.LBRACK:
-                            self.state = 131
-                            self.interval()
-
-
-                        self.state = 134
-                        self.expression(9)
-                        pass
-
-                    elif la_ == 9:
-                        localctx = StlParser.ExprSinceContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
-                        self.state = 135
-                        if not self.precpred(self._ctx, 5):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
-                        self.state = 136
-                        self.match(StlParser.SinceOperator)
-                        self.state = 138
-                        _la = self._input.LA(1)
-                        if _la==StlParser.LBRACK:
-                            self.state = 137
-                            self.interval()
-
-
-                        self.state = 140
-                        self.expression(6)
-                        pass
-
-             
-                self.state = 145
-                self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.unrollRecursionContexts(_parentctx)
-        return localctx
-
-    class Specification_fileContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.Specification_fileContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def specification(self):
-            return self.getTypedRuleContext(StlParser.SpecificationContext,0)
-
-
-        def EOF(self):
-            return self.getToken(StlParser.EOF, 0)
-
-        def getRuleIndex(self):
-            return StlParser.RULE_specification_file
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitSpecification_file"):
-                return visitor.visitSpecification_file(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def specification_file(self):
-
-        localctx = StlParser.Specification_fileContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 8, self.RULE_specification_file)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 146
-            self.specification()
-            self.state = 147
-            self.match(StlParser.EOF)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class SpecificationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.SpecificationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def spec(self):
-            return self.getTypedRuleContext(StlParser.SpecContext,0)
-
-
-        def modimport(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.ModimportContext)
-            else:
-                return self.getTypedRuleContext(StlParser.ModimportContext,i)
-
-
-        def declaration(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.DeclarationContext)
-            else:
-                return self.getTypedRuleContext(StlParser.DeclarationContext,i)
-
-
-        def annotation(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.AnnotationContext)
-            else:
-                return self.getTypedRuleContext(StlParser.AnnotationContext,i)
-
-
-        def assertion(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.AssertionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.AssertionContext,i)
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_specification
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitSpecification"):
-                return visitor.visitSpecification(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def specification(self):
-
-        localctx = StlParser.SpecificationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 10, self.RULE_specification)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 150
-            _la = self._input.LA(1)
-            if _la==StlParser.Specification:
-                self.state = 149
-                self.spec()
-
-
-            self.state = 155
-            self._errHandler.sync(self)
-            _la = self._input.LA(1)
-            while _la==StlParser.From:
-                self.state = 152
-                self.modimport()
-                self.state = 157
-                self._errHandler.sync(self)
-                _la = self._input.LA(1)
-
-            self.state = 162
-            self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
-                    self.state = 160
-                    token = self._input.LA(1)
-                    if token in [StlParser.Input, StlParser.Output, StlParser.Constant, StlParser.DomainTypeFloat, StlParser.DomainTypeLong, StlParser.DomainTypeComplex, StlParser.DomainTypeInt, StlParser.Identifier]:
-                        self.state = 158
-                        self.declaration()
-
-                    elif token in [StlParser.AT]:
-                        self.state = 159
-                        self.annotation()
-
-                    else:
-                        raise NoViableAltException(self)
-             
-                self.state = 164
-                self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
-
-            self.state = 166 
-            self._errHandler.sync(self)
-            _la = self._input.LA(1)
-            while True:
-                self.state = 165
-                self.assertion()
-                self.state = 168 
-                self._errHandler.sync(self)
-                _la = self._input.LA(1)
-                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.MINUS) | (1 << StlParser.LPAREN) | (1 << StlParser.ABS) | (1 << StlParser.SQRT) | (1 << StlParser.EXP) | (1 << StlParser.POW) | (1 << StlParser.NotOperator) | (1 << StlParser.RiseOperator) | (1 << StlParser.FallOperator) | (1 << StlParser.AlwaysOperator) | (1 << StlParser.EventuallyOperator) | (1 << StlParser.HistoricallyOperator) | (1 << StlParser.OnceOperator) | (1 << StlParser.NextOperator) | (1 << StlParser.PreviousOperator))) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (StlParser.IntegerLiteral - 67)) | (1 << (StlParser.RealLiteral - 67)) | (1 << (StlParser.Identifier - 67)))) != 0)):
-                    break
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class SpecContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.SpecContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_spec
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.SpecContext, self).copyFrom(ctx)
-
-
-
-    class SpecificationIdContext(SpecContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.SpecContext)
-            super(StlParser.SpecificationIdContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Specification(self):
-            return self.getToken(StlParser.Specification, 0)
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitSpecificationId"):
-                return visitor.visitSpecificationId(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def spec(self):
-
-        localctx = StlParser.SpecContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 12, self.RULE_spec)
-        try:
-            localctx = StlParser.SpecificationIdContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 170
-            self.match(StlParser.Specification)
-            self.state = 171
-            self.match(StlParser.Identifier)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class ModimportContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.ModimportContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_modimport
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.ModimportContext, self).copyFrom(ctx)
-
-
-
-    class ModImportContext(ModimportContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ModimportContext)
-            super(StlParser.ModImportContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def From(self):
-            return self.getToken(StlParser.From, 0)
-        def Identifier(self, i=None):
-            if i is None:
-                return self.getTokens(StlParser.Identifier)
-            else:
-                return self.getToken(StlParser.Identifier, i)
-        def Import(self):
-            return self.getToken(StlParser.Import, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitModImport"):
-                return visitor.visitModImport(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def modimport(self):
-
-        localctx = StlParser.ModimportContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 14, self.RULE_modimport)
-        try:
-            localctx = StlParser.ModImportContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 173
-            self.match(StlParser.From)
-            self.state = 174
-            self.match(StlParser.Identifier)
-            self.state = 175
-            self.match(StlParser.Import)
-            self.state = 176
-            self.match(StlParser.Identifier)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class AssertionContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.AssertionContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def EQUAL(self):
-            return self.getToken(StlParser.EQUAL, 0)
-
-        def getRuleIndex(self):
-            return StlParser.RULE_assertion
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAssertion"):
-                return visitor.visitAssertion(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def assertion(self):
-
-        localctx = StlParser.AssertionContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 16, self.RULE_assertion)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 180
-            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
-            if la_ == 1:
-                self.state = 178
-                self.match(StlParser.Identifier)
-                self.state = 179
-                self.match(StlParser.EQUAL)
-
-
-            self.state = 182
-            self.expression(0)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class DeclarationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.DeclarationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_declaration
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.DeclarationContext, self).copyFrom(ctx)
-
-
-
-    class DeclVariableContext(DeclarationContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.DeclarationContext)
-            super(StlParser.DeclVariableContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def variableDeclaration(self):
-            return self.getTypedRuleContext(StlParser.VariableDeclarationContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitDeclVariable"):
-                return visitor.visitDeclVariable(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class DeclConstantContext(DeclarationContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.DeclarationContext)
-            super(StlParser.DeclConstantContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def constantDeclaration(self):
-            return self.getTypedRuleContext(StlParser.ConstantDeclarationContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitDeclConstant"):
-                return visitor.visitDeclConstant(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def declaration(self):
-
-        localctx = StlParser.DeclarationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 18, self.RULE_declaration)
-        try:
-            self.state = 186
-            token = self._input.LA(1)
-            if token in [StlParser.Input, StlParser.Output, StlParser.DomainTypeFloat, StlParser.DomainTypeLong, StlParser.DomainTypeComplex, StlParser.DomainTypeInt, StlParser.Identifier]:
-                localctx = StlParser.DeclVariableContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 184
-                self.variableDeclaration()
-
-            elif token in [StlParser.Constant]:
-                localctx = StlParser.DeclConstantContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 185
-                self.constantDeclaration()
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class AnnotationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.AnnotationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def annotation_type(self):
-            return self.getTypedRuleContext(StlParser.Annotation_typeContext,0)
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_annotation
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAnnotation"):
-                return visitor.visitAnnotation(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def annotation(self):
-
-        localctx = StlParser.AnnotationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 20, self.RULE_annotation)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 188
-            self.match(StlParser.AT)
-            self.state = 189
-            self.annotation_type()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class Annotation_typeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.Annotation_typeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_annotation_type
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.Annotation_typeContext, self).copyFrom(ctx)
-
-
-
-    class RosTopicContext(Annotation_typeContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Annotation_typeContext)
-            super(StlParser.RosTopicContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def ROS_Topic(self):
-            return self.getToken(StlParser.ROS_Topic, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def Identifier(self, i=None):
-            if i is None:
-                return self.getTokens(StlParser.Identifier)
-            else:
-                return self.getToken(StlParser.Identifier, i)
-        def COMMA(self):
-            return self.getToken(StlParser.COMMA, 0)
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitRosTopic"):
-                return visitor.visitRosTopic(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def annotation_type(self):
-
-        localctx = StlParser.Annotation_typeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 22, self.RULE_annotation_type)
-        try:
-            localctx = StlParser.RosTopicContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 191
-            self.match(StlParser.ROS_Topic)
-            self.state = 192
-            self.match(StlParser.LPAREN)
-            self.state = 193
-            self.match(StlParser.Identifier)
-            self.state = 194
-            self.match(StlParser.COMMA)
-            self.state = 195
-            self.match(StlParser.Identifier)
-            self.state = 196
-            self.match(StlParser.RPAREN)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class VariableDeclarationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.VariableDeclarationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def domainType(self):
-            return self.getTypedRuleContext(StlParser.DomainTypeContext,0)
-
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def ioType(self):
-            return self.getTypedRuleContext(StlParser.IoTypeContext,0)
-
-
-        def assignment(self):
-            return self.getTypedRuleContext(StlParser.AssignmentContext,0)
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_variableDeclaration
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitVariableDeclaration"):
-                return visitor.visitVariableDeclaration(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def variableDeclaration(self):
-
-        localctx = StlParser.VariableDeclarationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 24, self.RULE_variableDeclaration)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 199
-            _la = self._input.LA(1)
-            if _la==StlParser.Input or _la==StlParser.Output:
-                self.state = 198
-                self.ioType()
-
-
-            self.state = 201
-            self.domainType()
-            self.state = 202
-            self.match(StlParser.Identifier)
-            self.state = 204
-            _la = self._input.LA(1)
-            if _la==StlParser.EQUAL:
-                self.state = 203
-                self.assignment()
-
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class ConstantDeclarationContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.ConstantDeclarationContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def Constant(self):
-            return self.getToken(StlParser.Constant, 0)
-
-        def domainType(self):
-            return self.getTypedRuleContext(StlParser.DomainTypeContext,0)
-
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def EQUAL(self):
-            return self.getToken(StlParser.EQUAL, 0)
-
-        def literal(self):
-            return self.getTypedRuleContext(StlParser.LiteralContext,0)
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_constantDeclaration
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitConstantDeclaration"):
-                return visitor.visitConstantDeclaration(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def constantDeclaration(self):
-
-        localctx = StlParser.ConstantDeclarationContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 26, self.RULE_constantDeclaration)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 206
-            self.match(StlParser.Constant)
-            self.state = 207
-            self.domainType()
-            self.state = 208
-            self.match(StlParser.Identifier)
-            self.state = 209
-            self.match(StlParser.EQUAL)
-            self.state = 210
-            self.literal()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class AssignmentContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.AssignmentContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_assignment
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.AssignmentContext, self).copyFrom(ctx)
-
-
-
-    class AsgnExprContext(AssignmentContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.AssignmentContext)
-            super(StlParser.AsgnExprContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EQUAL(self):
-            return self.getToken(StlParser.EQUAL, 0)
-        def expression(self):
-            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAsgnExpr"):
-                return visitor.visitAsgnExpr(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class AsgnLiteralContext(AssignmentContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.AssignmentContext)
-            super(StlParser.AsgnLiteralContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EQUAL(self):
-            return self.getToken(StlParser.EQUAL, 0)
-        def literal(self):
-            return self.getTypedRuleContext(StlParser.LiteralContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitAsgnLiteral"):
-                return visitor.visitAsgnLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def assignment(self):
-
-        localctx = StlParser.AssignmentContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 28, self.RULE_assignment)
-        try:
-            self.state = 216
-            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
-            if la_ == 1:
-                localctx = StlParser.AsgnLiteralContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 212
-                self.match(StlParser.EQUAL)
-                self.state = 213
-                self.literal()
-                pass
-
-            elif la_ == 2:
-                localctx = StlParser.AsgnExprContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 214
-                self.match(StlParser.EQUAL)
-                self.state = 215
-                self.expression(0)
-                pass
-
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class DomainTypeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.DomainTypeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def DomainTypeFloat(self):
-            return self.getToken(StlParser.DomainTypeFloat, 0)
-
-        def DomainTypeInt(self):
-            return self.getToken(StlParser.DomainTypeInt, 0)
-
-        def DomainTypeLong(self):
-            return self.getToken(StlParser.DomainTypeLong, 0)
-
-        def DomainTypeComplex(self):
-            return self.getToken(StlParser.DomainTypeComplex, 0)
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def getRuleIndex(self):
-            return StlParser.RULE_domainType
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitDomainType"):
-                return visitor.visitDomainType(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def domainType(self):
-
-        localctx = StlParser.DomainTypeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 30, self.RULE_domainType)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 218
-            _la = self._input.LA(1)
-            if not(((((_la - 32)) & ~0x3f) == 0 and ((1 << (_la - 32)) & ((1 << (StlParser.DomainTypeFloat - 32)) | (1 << (StlParser.DomainTypeLong - 32)) | (1 << (StlParser.DomainTypeComplex - 32)) | (1 << (StlParser.DomainTypeInt - 32)) | (1 << (StlParser.Identifier - 32)))) != 0)):
-                self._errHandler.recoverInline(self)
-            else:
-                self.consume()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class IoTypeContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.IoTypeContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def Input(self):
-            return self.getToken(StlParser.Input, 0)
-
-        def Output(self):
-            return self.getToken(StlParser.Output, 0)
-
-        def getRuleIndex(self):
-            return StlParser.RULE_ioType
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitIoType"):
-                return visitor.visitIoType(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def ioType(self):
-
-        localctx = StlParser.IoTypeContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 32, self.RULE_ioType)
-        self._la = 0 # Token type
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 220
-            _la = self._input.LA(1)
-            if not(_la==StlParser.Input or _la==StlParser.Output):
-                self._errHandler.recoverInline(self)
-            else:
-                self.consume()
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class Real_expressionContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.Real_expressionContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_real_expression
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.Real_expressionContext, self).copyFrom(ctx)
-
-
-    class ExprSubtractionContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprSubtractionContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
-
-        def MINUS(self):
-            return self.getToken(StlParser.MINUS, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprSubtraction"):
-                return visitor.visitExprSubtraction(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprPowContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprPowContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def POW(self):
-            return self.getToken(StlParser.POW, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
-
-        def COMMA(self):
-            return self.getToken(StlParser.COMMA, 0)
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprPow"):
-                return visitor.visitExprPow(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprDivisionContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprDivisionContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
-
-        def DIVIDE(self):
-            return self.getToken(StlParser.DIVIDE, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprDivision"):
-                return visitor.visitExprDivision(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprMultiplicationContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprMultiplicationContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
-
-        def TIMES(self):
-            return self.getToken(StlParser.TIMES, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprMultiplication"):
-                return visitor.visitExprMultiplication(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprLiteralContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprLiteralContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def literal(self):
-            return self.getTypedRuleContext(StlParser.LiteralContext,0)
-
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprLiteral"):
-                return visitor.visitExprLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprExpContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprExpContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EXP(self):
-            return self.getToken(StlParser.EXP, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def real_expression(self):
-            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprExp"):
-                return visitor.visitExprExp(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprSqrtContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprSqrtContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def SQRT(self):
-            return self.getToken(StlParser.SQRT, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def real_expression(self):
-            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprSqrt"):
-                return visitor.visitExprSqrt(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprIdContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprIdContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprId"):
-                return visitor.visitExprId(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAbsContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprAbsContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def ABS(self):
-            return self.getToken(StlParser.ABS, 0)
-        def LPAREN(self):
-            return self.getToken(StlParser.LPAREN, 0)
-        def real_expression(self):
-            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
-
-        def RPAREN(self):
-            return self.getToken(StlParser.RPAREN, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAbs"):
-                return visitor.visitExprAbs(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class ExprAdditionContext(Real_expressionContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
-            super(StlParser.ExprAdditionContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def real_expression(self, i=None):
-            if i is None:
-                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
-            else:
-                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
-
-        def PLUS(self):
-            return self.getToken(StlParser.PLUS, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitExprAddition"):
-                return visitor.visitExprAddition(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def real_expression(self, _p=0):
-        _parentctx = self._ctx
-        _parentState = self.state
-        localctx = StlParser.Real_expressionContext(self, self._ctx, _parentState)
-        _prevctx = localctx
-        _startState = 34
-        self.enterRecursionRule(localctx, 34, self.RULE_real_expression, _p)
-        try:
-            self.enterOuterAlt(localctx, 1)
-            self.state = 247
-            token = self._input.LA(1)
-            if token in [StlParser.Identifier]:
-                localctx = StlParser.ExprIdContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-
-                self.state = 223
-                self.match(StlParser.Identifier)
-
-            elif token in [StlParser.MINUS, StlParser.IntegerLiteral, StlParser.RealLiteral]:
-                localctx = StlParser.ExprLiteralContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 224
-                self.literal()
-
-            elif token in [StlParser.ABS]:
-                localctx = StlParser.ExprAbsContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 225
-                self.match(StlParser.ABS)
-                self.state = 226
-                self.match(StlParser.LPAREN)
-                self.state = 227
-                self.real_expression(0)
-                self.state = 228
-                self.match(StlParser.RPAREN)
-
-            elif token in [StlParser.SQRT]:
-                localctx = StlParser.ExprSqrtContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 230
-                self.match(StlParser.SQRT)
-                self.state = 231
-                self.match(StlParser.LPAREN)
-                self.state = 232
-                self.real_expression(0)
-                self.state = 233
-                self.match(StlParser.RPAREN)
-
-            elif token in [StlParser.EXP]:
-                localctx = StlParser.ExprExpContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 235
-                self.match(StlParser.EXP)
-                self.state = 236
-                self.match(StlParser.LPAREN)
-                self.state = 237
-                self.real_expression(0)
-                self.state = 238
-                self.match(StlParser.RPAREN)
-
-            elif token in [StlParser.POW]:
-                localctx = StlParser.ExprPowContext(self, localctx)
-                self._ctx = localctx
-                _prevctx = localctx
-                self.state = 240
-                self.match(StlParser.POW)
-                self.state = 241
-                self.match(StlParser.LPAREN)
-                self.state = 242
-                self.real_expression(0)
-                self.state = 243
-                self.match(StlParser.COMMA)
-                self.state = 244
-                self.real_expression(0)
-                self.state = 245
-                self.match(StlParser.RPAREN)
-
-            else:
-                raise NoViableAltException(self)
-
-            self._ctx.stop = self._input.LT(-1)
-            self.state = 263
-            self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
-                    if self._parseListeners is not None:
-                        self.triggerExitRuleEvent()
-                    _prevctx = localctx
-                    self.state = 261
-                    la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
-                    if la_ == 1:
-                        localctx = StlParser.ExprAdditionContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 249
-                        if not self.precpred(self._ctx, 8):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
-                        self.state = 250
-                        self.match(StlParser.PLUS)
-                        self.state = 251
-                        self.real_expression(9)
-                        pass
-
-                    elif la_ == 2:
-                        localctx = StlParser.ExprSubtractionContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 252
-                        if not self.precpred(self._ctx, 7):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
-                        self.state = 253
-                        self.match(StlParser.MINUS)
-                        self.state = 254
-                        self.real_expression(8)
-                        pass
-
-                    elif la_ == 3:
-                        localctx = StlParser.ExprMultiplicationContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 255
-                        if not self.precpred(self._ctx, 6):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
-                        self.state = 256
-                        self.match(StlParser.TIMES)
-                        self.state = 257
-                        self.real_expression(7)
-                        pass
-
-                    elif la_ == 4:
-                        localctx = StlParser.ExprDivisionContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
-                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
-                        self.state = 258
-                        if not self.precpred(self._ctx, 5):
-                            from antlr4.error.Errors import FailedPredicateException
-                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
-                        self.state = 259
-                        self.match(StlParser.DIVIDE)
-                        self.state = 260
-                        self.real_expression(6)
-                        pass
-
-             
-                self.state = 265
-                self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.unrollRecursionContexts(_parentctx)
-        return localctx
-
-    class ComparisonOpContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.ComparisonOpContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_comparisonOp
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.ComparisonOpContext, self).copyFrom(ctx)
-
-
-
-    class GeqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
-            super(StlParser.GeqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def GreaterOrEqualOperator(self):
-            return self.getToken(StlParser.GreaterOrEqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitGeq"):
-                return visitor.visitGeq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class LeqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
-            super(StlParser.LeqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def LesserOrEqualOperator(self):
-            return self.getToken(StlParser.LesserOrEqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitLeq"):
-                return visitor.visitLeq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class GreaterContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
-            super(StlParser.GreaterContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def GreaterOperator(self):
-            return self.getToken(StlParser.GreaterOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitGreater"):
-                return visitor.visitGreater(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class NeqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
-            super(StlParser.NeqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def NotEqualOperator(self):
-            return self.getToken(StlParser.NotEqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitNeq"):
-                return visitor.visitNeq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class EqContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
-            super(StlParser.EqContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def EqualOperator(self):
-            return self.getToken(StlParser.EqualOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitEq"):
-                return visitor.visitEq(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-    class LessContext(ComparisonOpContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
-            super(StlParser.LessContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def LesserOperator(self):
-            return self.getToken(StlParser.LesserOperator, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitLess"):
-                return visitor.visitLess(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def comparisonOp(self):
-
-        localctx = StlParser.ComparisonOpContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 36, self.RULE_comparisonOp)
-        try:
-            self.state = 272
-            token = self._input.LA(1)
-            if token in [StlParser.LesserOrEqualOperator]:
-                localctx = StlParser.LeqContext(self, localctx)
-                self.enterOuterAlt(localctx, 1)
-                self.state = 266
-                self.match(StlParser.LesserOrEqualOperator)
-
-            elif token in [StlParser.GreaterOrEqualOperator]:
-                localctx = StlParser.GeqContext(self, localctx)
-                self.enterOuterAlt(localctx, 2)
-                self.state = 267
-                self.match(StlParser.GreaterOrEqualOperator)
-
-            elif token in [StlParser.LesserOperator]:
-                localctx = StlParser.LessContext(self, localctx)
-                self.enterOuterAlt(localctx, 3)
-                self.state = 268
-                self.match(StlParser.LesserOperator)
-
-            elif token in [StlParser.GreaterOperator]:
-                localctx = StlParser.GreaterContext(self, localctx)
-                self.enterOuterAlt(localctx, 4)
-                self.state = 269
-                self.match(StlParser.GreaterOperator)
-
-            elif token in [StlParser.EqualOperator]:
-                localctx = StlParser.EqContext(self, localctx)
-                self.enterOuterAlt(localctx, 5)
-                self.state = 270
-                self.match(StlParser.EqualOperator)
-
-            elif token in [StlParser.NotEqualOperator]:
-                localctx = StlParser.NeqContext(self, localctx)
-                self.enterOuterAlt(localctx, 6)
-                self.state = 271
-                self.match(StlParser.NotEqualOperator)
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class LiteralContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.LiteralContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-        def IntegerLiteral(self):
-            return self.getToken(StlParser.IntegerLiteral, 0)
-
-        def RealLiteral(self):
-            return self.getToken(StlParser.RealLiteral, 0)
-
-        def MINUS(self):
-            return self.getToken(StlParser.MINUS, 0)
-
-        def literal(self):
-            return self.getTypedRuleContext(StlParser.LiteralContext,0)
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_literal
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitLiteral"):
-                return visitor.visitLiteral(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-
-    def literal(self):
-
-        localctx = StlParser.LiteralContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 38, self.RULE_literal)
-        try:
-            self.state = 278
-            token = self._input.LA(1)
-            if token in [StlParser.IntegerLiteral]:
-                self.enterOuterAlt(localctx, 1)
-                self.state = 274
-                self.match(StlParser.IntegerLiteral)
-
-            elif token in [StlParser.RealLiteral]:
-                self.enterOuterAlt(localctx, 2)
-                self.state = 275
-                self.match(StlParser.RealLiteral)
-
-            elif token in [StlParser.MINUS]:
-                self.enterOuterAlt(localctx, 3)
-                self.state = 276
-                self.match(StlParser.MINUS)
-                self.state = 277
-                self.literal()
-
-            else:
-                raise NoViableAltException(self)
-
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-    class IdentifierContext(ParserRuleContext):
-
-        def __init__(self, parser, parent=None, invokingState=-1):
-            super(StlParser.IdentifierContext, self).__init__(parent, invokingState)
-            self.parser = parser
-
-
-        def getRuleIndex(self):
-            return StlParser.RULE_identifier
-
-     
-        def copyFrom(self, ctx):
-            super(StlParser.IdentifierContext, self).copyFrom(ctx)
-
-
-
-    class IdContext(IdentifierContext):
-
-        def __init__(self, parser, ctx): # actually a StlParser.IdentifierContext)
-            super(StlParser.IdContext, self).__init__(parser)
-            self.copyFrom(ctx)
-
-        def Identifier(self):
-            return self.getToken(StlParser.Identifier, 0)
-
-        def accept(self, visitor):
-            if hasattr(visitor, "visitId"):
-                return visitor.visitId(self)
-            else:
-                return visitor.visitChildren(self)
-
-
-
-    def identifier(self):
-
-        localctx = StlParser.IdentifierContext(self, self._ctx, self.state)
-        self.enterRule(localctx, 40, self.RULE_identifier)
-        try:
-            localctx = StlParser.IdContext(self, localctx)
-            self.enterOuterAlt(localctx, 1)
-            self.state = 280
-            self.match(StlParser.Identifier)
-        except RecognitionException as re:
-            localctx.exception = re
-            self._errHandler.reportError(self, re)
-            self._errHandler.recover(self, re)
-        finally:
-            self.exitRule()
-        return localctx
-
-
-
-    def sempred(self, localctx, ruleIndex, predIndex):
-        if self._predicates == None:
-            self._predicates = dict()
-        self._predicates[3] = self.expression_sempred
-        self._predicates[17] = self.real_expression_sempred
-        pred = self._predicates.get(ruleIndex, None)
-        if pred is None:
-            raise Exception("No predicate with index:" + str(ruleIndex))
-        else:
-            return pred(localctx, predIndex)
-
-    def expression_sempred(self, localctx, predIndex):
-            if predIndex == 0:
-                return self.precpred(self._ctx, 19)
-         
-
-            if predIndex == 1:
-                return self.precpred(self._ctx, 16)
-         
-
-            if predIndex == 2:
-                return self.precpred(self._ctx, 15)
-         
-
-            if predIndex == 3:
-                return self.precpred(self._ctx, 14)
-         
-
-            if predIndex == 4:
-                return self.precpred(self._ctx, 13)
-         
-
-            if predIndex == 5:
-                return self.precpred(self._ctx, 12)
-         
-
-            if predIndex == 6:
-                return self.precpred(self._ctx, 9)
-         
-
-            if predIndex == 7:
-                return self.precpred(self._ctx, 8)
-         
-
-            if predIndex == 8:
-                return self.precpred(self._ctx, 5)
-         
-
-    def real_expression_sempred(self, localctx, predIndex):
-            if predIndex == 9:
-                return self.precpred(self._ctx, 8)
-         
-
-            if predIndex == 10:
-                return self.precpred(self._ctx, 7)
-         
-
-            if predIndex == 11:
-                return self.precpred(self._ctx, 6)
-         
-
-            if predIndex == 12:
-                return self.precpred(self._ctx, 5)
-         
-
-
-
-
+# Generated from StlParser.g4 by ANTLR 4.7.2
+# encoding: utf-8
+from __future__ import print_function
+from antlr4 import *
+from io import StringIO
+import sys
+
+def serializedATN():
+    with StringIO() as buf:
+        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
+        buf.write(u"K\u011d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
+        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
+        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
+        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\3\2\3\2\3\2\3")
+        buf.write(u"\2\3\2\3\2\3\3\3\3\5\3\65\n\3\3\3\3\3\5\39\n\3\5\3;\n")
+        buf.write(u"\3\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5")
+        buf.write(u"\5I\n\5\3\5\3\5\3\5\5\5N\n\5\3\5\3\5\3\5\5\5S\n\5\3\5")
+        buf.write(u"\3\5\3\5\5\5X\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
+        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\5\5i\n\5\3\5\3\5\3\5\3\5\3\5")
+        buf.write(u"\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5")
+        buf.write(u"\3\5\3\5\3\5\3\5\5\5\u0081\n\5\3\5\3\5\3\5\3\5\5\5\u0087")
+        buf.write(u"\n\5\3\5\3\5\3\5\3\5\5\5\u008d\n\5\3\5\7\5\u0090\n\5")
+        buf.write(u"\f\5\16\5\u0093\13\5\3\6\3\6\3\6\3\7\5\7\u0099\n\7\3")
+        buf.write(u"\7\7\7\u009c\n\7\f\7\16\7\u009f\13\7\3\7\3\7\7\7\u00a3")
+        buf.write(u"\n\7\f\7\16\7\u00a6\13\7\3\7\6\7\u00a9\n\7\r\7\16\7\u00aa")
+        buf.write(u"\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\n\3\n\5\n\u00b7\n")
+        buf.write(u"\n\3\n\3\n\3\13\3\13\5\13\u00bd\n\13\3\f\3\f\3\f\3\r")
+        buf.write(u"\3\r\3\r\3\r\3\r\3\r\3\r\3\16\5\16\u00ca\n\16\3\16\3")
+        buf.write(u"\16\3\16\5\16\u00cf\n\16\3\17\3\17\3\17\3\17\3\17\3\17")
+        buf.write(u"\3\20\3\20\3\20\3\20\5\20\u00db\n\20\3\21\3\21\3\22\3")
+        buf.write(u"\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23")
+        buf.write(u"\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3")
+        buf.write(u"\23\3\23\3\23\3\23\3\23\5\23\u00fa\n\23\3\23\3\23\3\23")
+        buf.write(u"\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\7\23\u0108")
+        buf.write(u"\n\23\f\23\16\23\u010b\13\23\3\24\3\24\3\24\3\24\3\24")
+        buf.write(u"\3\24\5\24\u0113\n\24\3\25\3\25\3\25\3\25\5\25\u0119")
+        buf.write(u"\n\25\3\26\3\26\3\26\2\4\b$\27\2\4\6\b\n\f\16\20\22\24")
+        buf.write(u"\26\30\32\34\36 \"$&(*\2\6\3\2\16\17\3\2\26\31\4\2\"")
+        buf.write(u"%GG\3\2\35\36\2\u013e\2,\3\2\2\2\4:\3\2\2\2\6<\3\2\2")
+        buf.write(u"\2\bh\3\2\2\2\n\u0094\3\2\2\2\f\u0098\3\2\2\2\16\u00ac")
+        buf.write(u"\3\2\2\2\20\u00af\3\2\2\2\22\u00b6\3\2\2\2\24\u00bc\3")
+        buf.write(u"\2\2\2\26\u00be\3\2\2\2\30\u00c1\3\2\2\2\32\u00c9\3\2")
+        buf.write(u"\2\2\34\u00d0\3\2\2\2\36\u00da\3\2\2\2 \u00dc\3\2\2\2")
+        buf.write(u"\"\u00de\3\2\2\2$\u00f9\3\2\2\2&\u0112\3\2\2\2(\u0118")
+        buf.write(u"\3\2\2\2*\u011a\3\2\2\2,-\7\13\2\2-.\5\4\3\2./\t\2\2")
+        buf.write(u"\2/\60\5\4\3\2\60\61\7\f\2\2\61\3\3\2\2\2\62\64\5(\25")
+        buf.write(u"\2\63\65\5\6\4\2\64\63\3\2\2\2\64\65\3\2\2\2\65;\3\2")
+        buf.write(u"\2\2\668\7G\2\2\679\5\6\4\28\67\3\2\2\289\3\2\2\29;\3")
+        buf.write(u"\2\2\2:\62\3\2\2\2:\66\3\2\2\2;\5\3\2\2\2<=\t\3\2\2=")
+        buf.write(u"\7\3\2\2\2>?\b\5\1\2?i\5$\23\2@A\7\7\2\2AB\5\b\5\2BC")
+        buf.write(u"\7\b\2\2Ci\3\2\2\2DE\7*\2\2Ei\5\b\5\23FH\7\62\2\2GI\5")
+        buf.write(u"\2\2\2HG\3\2\2\2HI\3\2\2\2IJ\3\2\2\2Ji\5\b\5\rKM\7\63")
+        buf.write(u"\2\2LN\5\2\2\2ML\3\2\2\2MN\3\2\2\2NO\3\2\2\2Oi\5\b\5")
+        buf.write(u"\fPR\7\66\2\2QS\5\2\2\2RQ\3\2\2\2RS\3\2\2\2ST\3\2\2\2")
+        buf.write(u"Ti\5\b\5\tUW\7\67\2\2VX\5\2\2\2WV\3\2\2\2WX\3\2\2\2X")
+        buf.write(u"Y\3\2\2\2Yi\5\b\5\bZ[\7\60\2\2[\\\7\7\2\2\\]\5\b\5\2")
+        buf.write(u"]^\7\b\2\2^i\3\2\2\2_`\7\61\2\2`a\7\7\2\2ab\5\b\5\2b")
+        buf.write(u"c\7\b\2\2ci\3\2\2\2de\7:\2\2ei\5\b\5\4fg\79\2\2gi\5\b")
+        buf.write(u"\5\3h>\3\2\2\2h@\3\2\2\2hD\3\2\2\2hF\3\2\2\2hK\3\2\2")
+        buf.write(u"\2hP\3\2\2\2hU\3\2\2\2hZ\3\2\2\2h_\3\2\2\2hd\3\2\2\2")
+        buf.write(u"hf\3\2\2\2i\u0091\3\2\2\2jk\f\25\2\2kl\5&\24\2lm\5\b")
+        buf.write(u"\5\26m\u0090\3\2\2\2no\f\22\2\2op\7+\2\2p\u0090\5\b\5")
+        buf.write(u"\23qr\f\21\2\2rs\7,\2\2s\u0090\5\b\5\22tu\f\20\2\2uv")
+        buf.write(u"\7.\2\2v\u0090\5\b\5\21wx\f\17\2\2xy\7-\2\2y\u0090\5")
+        buf.write(u"\b\5\20z{\f\16\2\2{|\7/\2\2|\u0090\5\b\5\17}~\f\13\2")
+        buf.write(u"\2~\u0080\7\64\2\2\177\u0081\5\2\2\2\u0080\177\3\2\2")
+        buf.write(u"\2\u0080\u0081\3\2\2\2\u0081\u0082\3\2\2\2\u0082\u0090")
+        buf.write(u"\5\b\5\f\u0083\u0084\f\n\2\2\u0084\u0086\7\65\2\2\u0085")
+        buf.write(u"\u0087\5\2\2\2\u0086\u0085\3\2\2\2\u0086\u0087\3\2\2")
+        buf.write(u"\2\u0087\u0088\3\2\2\2\u0088\u0090\5\b\5\13\u0089\u008a")
+        buf.write(u"\f\7\2\2\u008a\u008c\78\2\2\u008b\u008d\5\2\2\2\u008c")
+        buf.write(u"\u008b\3\2\2\2\u008c\u008d\3\2\2\2\u008d\u008e\3\2\2")
+        buf.write(u"\2\u008e\u0090\5\b\5\b\u008fj\3\2\2\2\u008fn\3\2\2\2")
+        buf.write(u"\u008fq\3\2\2\2\u008ft\3\2\2\2\u008fw\3\2\2\2\u008fz")
+        buf.write(u"\3\2\2\2\u008f}\3\2\2\2\u008f\u0083\3\2\2\2\u008f\u0089")
+        buf.write(u"\3\2\2\2\u0090\u0093\3\2\2\2\u0091\u008f\3\2\2\2\u0091")
+        buf.write(u"\u0092\3\2\2\2\u0092\t\3\2\2\2\u0093\u0091\3\2\2\2\u0094")
+        buf.write(u"\u0095\5\f\7\2\u0095\u0096\7\2\2\3\u0096\13\3\2\2\2\u0097")
+        buf.write(u"\u0099\5\16\b\2\u0098\u0097\3\2\2\2\u0098\u0099\3\2\2")
+        buf.write(u"\2\u0099\u009d\3\2\2\2\u009a\u009c\5\20\t\2\u009b\u009a")
+        buf.write(u"\3\2\2\2\u009c\u009f\3\2\2\2\u009d\u009b\3\2\2\2\u009d")
+        buf.write(u"\u009e\3\2\2\2\u009e\u00a4\3\2\2\2\u009f\u009d\3\2\2")
+        buf.write(u"\2\u00a0\u00a3\5\24\13\2\u00a1\u00a3\5\26\f\2\u00a2\u00a0")
+        buf.write(u"\3\2\2\2\u00a2\u00a1\3\2\2\2\u00a3\u00a6\3\2\2\2\u00a4")
+        buf.write(u"\u00a2\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a8\3\2\2")
+        buf.write(u"\2\u00a6\u00a4\3\2\2\2\u00a7\u00a9\5\22\n\2\u00a8\u00a7")
+        buf.write(u"\3\2\2\2\u00a9\u00aa\3\2\2\2\u00aa\u00a8\3\2\2\2\u00aa")
+        buf.write(u"\u00ab\3\2\2\2\u00ab\r\3\2\2\2\u00ac\u00ad\7(\2\2\u00ad")
+        buf.write(u"\u00ae\7G\2\2\u00ae\17\3\2\2\2\u00af\u00b0\7)\2\2\u00b0")
+        buf.write(u"\u00b1\7G\2\2\u00b1\u00b2\7\34\2\2\u00b2\u00b3\7G\2\2")
+        buf.write(u"\u00b3\21\3\2\2\2\u00b4\u00b5\7G\2\2\u00b5\u00b7\7A\2")
+        buf.write(u"\2\u00b6\u00b4\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\u00b8")
+        buf.write(u"\3\2\2\2\u00b8\u00b9\5\b\5\2\u00b9\23\3\2\2\2\u00ba\u00bd")
+        buf.write(u"\5\32\16\2\u00bb\u00bd\5\34\17\2\u00bc\u00ba\3\2\2\2")
+        buf.write(u"\u00bc\u00bb\3\2\2\2\u00bd\25\3\2\2\2\u00be\u00bf\7\21")
+        buf.write(u"\2\2\u00bf\u00c0\5\30\r\2\u00c0\27\3\2\2\2\u00c1\u00c2")
+        buf.write(u"\7\33\2\2\u00c2\u00c3\7\7\2\2\u00c3\u00c4\7G\2\2\u00c4")
+        buf.write(u"\u00c5\7\17\2\2\u00c5\u00c6\7G\2\2\u00c6\u00c7\7\b\2")
+        buf.write(u"\2\u00c7\31\3\2\2\2\u00c8\u00ca\5\"\22\2\u00c9\u00c8")
+        buf.write(u"\3\2\2\2\u00c9\u00ca\3\2\2\2\u00ca\u00cb\3\2\2\2\u00cb")
+        buf.write(u"\u00cc\5 \21\2\u00cc\u00ce\7G\2\2\u00cd\u00cf\5\36\20")
+        buf.write(u"\2\u00ce\u00cd\3\2\2\2\u00ce\u00cf\3\2\2\2\u00cf\33\3")
+        buf.write(u"\2\2\2\u00d0\u00d1\7 \2\2\u00d1\u00d2\5 \21\2\u00d2\u00d3")
+        buf.write(u"\7G\2\2\u00d3\u00d4\7A\2\2\u00d4\u00d5\5(\25\2\u00d5")
+        buf.write(u"\35\3\2\2\2\u00d6\u00d7\7A\2\2\u00d7\u00db\5(\25\2\u00d8")
+        buf.write(u"\u00d9\7A\2\2\u00d9\u00db\5\b\5\2\u00da\u00d6\3\2\2\2")
+        buf.write(u"\u00da\u00d8\3\2\2\2\u00db\37\3\2\2\2\u00dc\u00dd\t\4")
+        buf.write(u"\2\2\u00dd!\3\2\2\2\u00de\u00df\t\5\2\2\u00df#\3\2\2")
+        buf.write(u"\2\u00e0\u00e1\b\23\1\2\u00e1\u00fa\7G\2\2\u00e2\u00fa")
+        buf.write(u"\5(\25\2\u00e3\u00e4\7\22\2\2\u00e4\u00e5\7\7\2\2\u00e5")
+        buf.write(u"\u00e6\5$\23\2\u00e6\u00e7\7\b\2\2\u00e7\u00fa\3\2\2")
+        buf.write(u"\2\u00e8\u00e9\7\23\2\2\u00e9\u00ea\7\7\2\2\u00ea\u00eb")
+        buf.write(u"\5$\23\2\u00eb\u00ec\7\b\2\2\u00ec\u00fa\3\2\2\2\u00ed")
+        buf.write(u"\u00ee\7\24\2\2\u00ee\u00ef\7\7\2\2\u00ef\u00f0\5$\23")
+        buf.write(u"\2\u00f0\u00f1\7\b\2\2\u00f1\u00fa\3\2\2\2\u00f2\u00f3")
+        buf.write(u"\7\25\2\2\u00f3\u00f4\7\7\2\2\u00f4\u00f5\5$\23\2\u00f5")
+        buf.write(u"\u00f6\7\17\2\2\u00f6\u00f7\5$\23\2\u00f7\u00f8\7\b\2")
+        buf.write(u"\2\u00f8\u00fa\3\2\2\2\u00f9\u00e0\3\2\2\2\u00f9\u00e2")
+        buf.write(u"\3\2\2\2\u00f9\u00e3\3\2\2\2\u00f9\u00e8\3\2\2\2\u00f9")
+        buf.write(u"\u00ed\3\2\2\2\u00f9\u00f2\3\2\2\2\u00fa\u0109\3\2\2")
+        buf.write(u"\2\u00fb\u00fc\f\n\2\2\u00fc\u00fd\7\4\2\2\u00fd\u0108")
+        buf.write(u"\5$\23\13\u00fe\u00ff\f\t\2\2\u00ff\u0100\7\3\2\2\u0100")
+        buf.write(u"\u0108\5$\23\n\u0101\u0102\f\b\2\2\u0102\u0103\7\5\2")
+        buf.write(u"\2\u0103\u0108\5$\23\t\u0104\u0105\f\7\2\2\u0105\u0106")
+        buf.write(u"\7\6\2\2\u0106\u0108\5$\23\b\u0107\u00fb\3\2\2\2\u0107")
+        buf.write(u"\u00fe\3\2\2\2\u0107\u0101\3\2\2\2\u0107\u0104\3\2\2")
+        buf.write(u"\2\u0108\u010b\3\2\2\2\u0109\u0107\3\2\2\2\u0109\u010a")
+        buf.write(u"\3\2\2\2\u010a%\3\2\2\2\u010b\u0109\3\2\2\2\u010c\u0113")
+        buf.write(u"\7>\2\2\u010d\u0113\7=\2\2\u010e\u0113\7@\2\2\u010f\u0113")
+        buf.write(u"\7?\2\2\u0110\u0113\7;\2\2\u0111\u0113\7<\2\2\u0112\u010c")
+        buf.write(u"\3\2\2\2\u0112\u010d\3\2\2\2\u0112\u010e\3\2\2\2\u0112")
+        buf.write(u"\u010f\3\2\2\2\u0112\u0110\3\2\2\2\u0112\u0111\3\2\2")
+        buf.write(u"\2\u0113\'\3\2\2\2\u0114\u0119\7E\2\2\u0115\u0119\7F")
+        buf.write(u"\2\2\u0116\u0117\7\3\2\2\u0117\u0119\5(\25\2\u0118\u0114")
+        buf.write(u"\3\2\2\2\u0118\u0115\3\2\2\2\u0118\u0116\3\2\2\2\u0119")
+        buf.write(u")\3\2\2\2\u011a\u011b\7G\2\2\u011b+\3\2\2\2\36\648:H")
+        buf.write(u"MRWh\u0080\u0086\u008c\u008f\u0091\u0098\u009d\u00a2")
+        buf.write(u"\u00a4\u00aa\u00b6\u00bc\u00c9\u00ce\u00da\u00f9\u0107")
+        buf.write(u"\u0109\u0112\u0118")
+        return buf.getvalue()
+
+
+class StlParser ( Parser ):
+
+    grammarFileName = "StlParser.g4"
+
+    atn = ATNDeserializer().deserialize(serializedATN())
+
+    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]
+
+    sharedContextCache = PredictionContextCache()
+
+    literalNames = [ u"<INVALID>", u"'-'", u"'+'", u"'*'", u"'/'", u"'('", 
+                     u"')'", u"'{'", u"'}'", u"'['", u"']'", u"';'", u"':'", 
+                     u"','", u"'.'", u"'@'", u"'abs'", u"'sqrt'", u"'exp'", 
+                     u"'pow'", u"'s'", u"'ms'", u"'us'", u"'ns'", u"'ps'", 
+                     u"'topic'", u"'import'", u"'input'", u"'output'", u"'internal'", 
+                     u"'const'", u"'real'", u"'float'", u"'long'", u"'complex'", 
+                     u"'int'", u"'bool'", u"'assertion'", u"'specification'", 
+                     u"'from'", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
+                     u"<INVALID>", u"<INVALID>", u"'xor'", u"'rise'", u"'fall'", 
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
+                     u"<INVALID>", u"'=='", u"'!=='", u"'>='", u"'<='", 
+                     u"'>'", u"'<'", u"'='" ]
+
+    symbolicNames = [ u"<INVALID>", u"MINUS", u"PLUS", u"TIMES", u"DIVIDE", 
+                      u"LPAREN", u"RPAREN", u"LBRACE", u"RBRACE", u"LBRACK", 
+                      u"RBRACK", u"SEMICOLON", u"COLON", u"COMMA", u"DOT", 
+                      u"AT", u"ABS", u"SQRT", u"EXP", u"POW", u"SEC", u"MSEC", 
+                      u"USEC", u"NSEC", u"PSEC", u"ROS_Topic", u"Import", 
+                      u"Input", u"Output", u"Internal", u"Constant", u"DomainTypeReal", 
+                      u"DomainTypeFloat", u"DomainTypeLong", u"DomainTypeComplex", 
+                      u"DomainTypeInt", u"DomainTypeBool", u"Assertion", 
+                      u"Specification", u"From", u"NotOperator", u"OrOperator", 
+                      u"AndOperator", u"IffOperator", u"ImpliesOperator", 
+                      u"XorOperator", u"RiseOperator", u"FallOperator", 
+                      u"AlwaysOperator", u"EventuallyOperator", u"UntilOperator", 
+                      u"UnlessOperator", u"HistoricallyOperator", u"OnceOperator", 
+                      u"SinceOperator", u"NextOperator", u"PreviousOperator", 
+                      u"EqualOperator", u"NotEqualOperator", u"GreaterOrEqualOperator", 
+                      u"LesserOrEqualOperator", u"GreaterOperator", u"LesserOperator", 
+                      u"EQUAL", u"BooleanLiteral", u"TRUE", u"FALSE", u"IntegerLiteral", 
+                      u"RealLiteral", u"Identifier", u"LINE_TERMINATOR", 
+                      u"WHITESPACE", u"COMMENT", u"LINE_COMMENT" ]
+
+    RULE_interval = 0
+    RULE_intervalTime = 1
+    RULE_unit = 2
+    RULE_expression = 3
+    RULE_specification_file = 4
+    RULE_specification = 5
+    RULE_spec = 6
+    RULE_modimport = 7
+    RULE_assertion = 8
+    RULE_declaration = 9
+    RULE_annotation = 10
+    RULE_annotation_type = 11
+    RULE_variableDeclaration = 12
+    RULE_constantDeclaration = 13
+    RULE_assignment = 14
+    RULE_domainType = 15
+    RULE_ioType = 16
+    RULE_real_expression = 17
+    RULE_comparisonOp = 18
+    RULE_literal = 19
+    RULE_identifier = 20
+
+    ruleNames =  [ u"interval", u"intervalTime", u"unit", u"expression", 
+                   u"specification_file", u"specification", u"spec", u"modimport", 
+                   u"assertion", u"declaration", u"annotation", u"annotation_type", 
+                   u"variableDeclaration", u"constantDeclaration", u"assignment", 
+                   u"domainType", u"ioType", u"real_expression", u"comparisonOp", 
+                   u"literal", u"identifier" ]
+
+    EOF = Token.EOF
+    MINUS=1
+    PLUS=2
+    TIMES=3
+    DIVIDE=4
+    LPAREN=5
+    RPAREN=6
+    LBRACE=7
+    RBRACE=8
+    LBRACK=9
+    RBRACK=10
+    SEMICOLON=11
+    COLON=12
+    COMMA=13
+    DOT=14
+    AT=15
+    ABS=16
+    SQRT=17
+    EXP=18
+    POW=19
+    SEC=20
+    MSEC=21
+    USEC=22
+    NSEC=23
+    PSEC=24
+    ROS_Topic=25
+    Import=26
+    Input=27
+    Output=28
+    Internal=29
+    Constant=30
+    DomainTypeReal=31
+    DomainTypeFloat=32
+    DomainTypeLong=33
+    DomainTypeComplex=34
+    DomainTypeInt=35
+    DomainTypeBool=36
+    Assertion=37
+    Specification=38
+    From=39
+    NotOperator=40
+    OrOperator=41
+    AndOperator=42
+    IffOperator=43
+    ImpliesOperator=44
+    XorOperator=45
+    RiseOperator=46
+    FallOperator=47
+    AlwaysOperator=48
+    EventuallyOperator=49
+    UntilOperator=50
+    UnlessOperator=51
+    HistoricallyOperator=52
+    OnceOperator=53
+    SinceOperator=54
+    NextOperator=55
+    PreviousOperator=56
+    EqualOperator=57
+    NotEqualOperator=58
+    GreaterOrEqualOperator=59
+    LesserOrEqualOperator=60
+    GreaterOperator=61
+    LesserOperator=62
+    EQUAL=63
+    BooleanLiteral=64
+    TRUE=65
+    FALSE=66
+    IntegerLiteral=67
+    RealLiteral=68
+    Identifier=69
+    LINE_TERMINATOR=70
+    WHITESPACE=71
+    COMMENT=72
+    LINE_COMMENT=73
+
+    def __init__(self, input, output=sys.stdout):
+        super(StlParser, self).__init__(input, output=output)
+        self.checkVersion("4.7.2")
+        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
+        self._predicates = None
+
+
+
+    class IntervalContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.IntervalContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def LBRACK(self):
+            return self.getToken(StlParser.LBRACK, 0)
+
+        def intervalTime(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.IntervalTimeContext)
+            else:
+                return self.getTypedRuleContext(StlParser.IntervalTimeContext,i)
+
+
+        def RBRACK(self):
+            return self.getToken(StlParser.RBRACK, 0)
+
+        def COLON(self):
+            return self.getToken(StlParser.COLON, 0)
+
+        def COMMA(self):
+            return self.getToken(StlParser.COMMA, 0)
+
+        def getRuleIndex(self):
+            return StlParser.RULE_interval
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitInterval"):
+                return visitor.visitInterval(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def interval(self):
+
+        localctx = StlParser.IntervalContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 0, self.RULE_interval)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 42
+            self.match(StlParser.LBRACK)
+            self.state = 43
+            self.intervalTime()
+            self.state = 44
+            _la = self._input.LA(1)
+            if not(_la==StlParser.COLON or _la==StlParser.COMMA):
+                self._errHandler.recoverInline(self)
+            else:
+                self._errHandler.reportMatch(self)
+                self.consume()
+            self.state = 45
+            self.intervalTime()
+            self.state = 46
+            self.match(StlParser.RBRACK)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class IntervalTimeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.IntervalTimeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_intervalTime
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.IntervalTimeContext, self).copyFrom(ctx)
+
+
+
+    class IntervalTimeLiteralContext(IntervalTimeContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.IntervalTimeContext)
+            super(StlParser.IntervalTimeLiteralContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def literal(self):
+            return self.getTypedRuleContext(StlParser.LiteralContext,0)
+
+        def unit(self):
+            return self.getTypedRuleContext(StlParser.UnitContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitIntervalTimeLiteral"):
+                return visitor.visitIntervalTimeLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ConstantTimeLiteralContext(IntervalTimeContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.IntervalTimeContext)
+            super(StlParser.ConstantTimeLiteralContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+        def unit(self):
+            return self.getTypedRuleContext(StlParser.UnitContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitConstantTimeLiteral"):
+                return visitor.visitConstantTimeLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def intervalTime(self):
+
+        localctx = StlParser.IntervalTimeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 2, self.RULE_intervalTime)
+        self._la = 0 # Token type
+        try:
+            self.state = 56
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [StlParser.MINUS, StlParser.IntegerLiteral, StlParser.RealLiteral]:
+                localctx = StlParser.IntervalTimeLiteralContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 48
+                self.literal()
+                self.state = 50
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.SEC) | (1 << StlParser.MSEC) | (1 << StlParser.USEC) | (1 << StlParser.NSEC))) != 0):
+                    self.state = 49
+                    self.unit()
+
+
+                pass
+            elif token in [StlParser.Identifier]:
+                localctx = StlParser.ConstantTimeLiteralContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 52
+                self.match(StlParser.Identifier)
+                self.state = 54
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.SEC) | (1 << StlParser.MSEC) | (1 << StlParser.USEC) | (1 << StlParser.NSEC))) != 0):
+                    self.state = 53
+                    self.unit()
+
+
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class UnitContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.UnitContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def SEC(self):
+            return self.getToken(StlParser.SEC, 0)
+
+        def MSEC(self):
+            return self.getToken(StlParser.MSEC, 0)
+
+        def USEC(self):
+            return self.getToken(StlParser.USEC, 0)
+
+        def NSEC(self):
+            return self.getToken(StlParser.NSEC, 0)
+
+        def getRuleIndex(self):
+            return StlParser.RULE_unit
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitUnit"):
+                return visitor.visitUnit(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def unit(self):
+
+        localctx = StlParser.UnitContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 4, self.RULE_unit)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 58
+            _la = self._input.LA(1)
+            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.SEC) | (1 << StlParser.MSEC) | (1 << StlParser.USEC) | (1 << StlParser.NSEC))) != 0)):
+                self._errHandler.recoverInline(self)
+            else:
+                self._errHandler.reportMatch(self)
+                self.consume()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class ExpressionContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.ExpressionContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_expression
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.ExpressionContext, self).copyFrom(ctx)
+
+
+    class ExprSinceContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprSinceContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def SinceOperator(self):
+            return self.getToken(StlParser.SinceOperator, 0)
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprSince"):
+                return visitor.visitExprSince(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprParenContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprParenContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprParen"):
+                return visitor.visitExprParen(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprIffContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprIffContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def IffOperator(self):
+            return self.getToken(StlParser.IffOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprIff"):
+                return visitor.visitExprIff(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExpreOnceContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExpreOnceContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def OnceOperator(self):
+            return self.getToken(StlParser.OnceOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExpreOnce"):
+                return visitor.visitExpreOnce(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprEvContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprEvContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EventuallyOperator(self):
+            return self.getToken(StlParser.EventuallyOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprEv"):
+                return visitor.visitExprEv(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprImpliesContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprImpliesContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def ImpliesOperator(self):
+            return self.getToken(StlParser.ImpliesOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprImplies"):
+                return visitor.visitExprImplies(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprUntilContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprUntilContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def UntilOperator(self):
+            return self.getToken(StlParser.UntilOperator, 0)
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprUntil"):
+                return visitor.visitExprUntil(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprNotContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprNotContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def NotOperator(self):
+            return self.getToken(StlParser.NotOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprNot"):
+                return visitor.visitExprNot(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprNextContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprNextContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def NextOperator(self):
+            return self.getToken(StlParser.NextOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprNext"):
+                return visitor.visitExprNext(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAndContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprAndContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def AndOperator(self):
+            return self.getToken(StlParser.AndOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAnd"):
+                return visitor.visitExprAnd(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprUnlessContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprUnlessContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def UnlessOperator(self):
+            return self.getToken(StlParser.UnlessOperator, 0)
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprUnless"):
+                return visitor.visitExprUnless(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprPreviousContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprPreviousContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def PreviousOperator(self):
+            return self.getToken(StlParser.PreviousOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprPrevious"):
+                return visitor.visitExprPrevious(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprHistContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprHistContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def HistoricallyOperator(self):
+            return self.getToken(StlParser.HistoricallyOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprHist"):
+                return visitor.visitExprHist(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprFallContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprFallContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def FallOperator(self):
+            return self.getToken(StlParser.FallOperator, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprFall"):
+                return visitor.visitExprFall(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprPredicateContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprPredicateContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def comparisonOp(self):
+            return self.getTypedRuleContext(StlParser.ComparisonOpContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprPredicate"):
+                return visitor.visitExprPredicate(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprXorContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprXorContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def XorOperator(self):
+            return self.getToken(StlParser.XorOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprXor"):
+                return visitor.visitExprXor(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprRiseContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprRiseContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def RiseOperator(self):
+            return self.getToken(StlParser.RiseOperator, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprRise"):
+                return visitor.visitExprRise(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprOrContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprOrContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ExpressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ExpressionContext,i)
+
+        def OrOperator(self):
+            return self.getToken(StlParser.OrOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprOr"):
+                return visitor.visitExprOr(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAlwaysContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprAlwaysContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def AlwaysOperator(self):
+            return self.getToken(StlParser.AlwaysOperator, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+        def interval(self):
+            return self.getTypedRuleContext(StlParser.IntervalContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAlways"):
+                return visitor.visitExprAlways(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprRealContext(ExpressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ExpressionContext)
+            super(StlParser.ExprRealContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self):
+            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprReal"):
+                return visitor.visitExprReal(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def expression(self, _p=0):
+        _parentctx = self._ctx
+        _parentState = self.state
+        localctx = StlParser.ExpressionContext(self, self._ctx, _parentState)
+        _prevctx = localctx
+        _startState = 6
+        self.enterRecursionRule(localctx, 6, self.RULE_expression, _p)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 102
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [StlParser.MINUS, StlParser.ABS, StlParser.SQRT, StlParser.EXP, StlParser.POW, StlParser.IntegerLiteral, StlParser.RealLiteral, StlParser.Identifier]:
+                localctx = StlParser.ExprRealContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+
+                self.state = 61
+                self.real_expression(0)
+                pass
+            elif token in [StlParser.LPAREN]:
+                localctx = StlParser.ExprParenContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 62
+                self.match(StlParser.LPAREN)
+                self.state = 63
+                self.expression(0)
+                self.state = 64
+                self.match(StlParser.RPAREN)
+                pass
+            elif token in [StlParser.NotOperator]:
+                localctx = StlParser.ExprNotContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 66
+                self.match(StlParser.NotOperator)
+                self.state = 67
+                self.expression(17)
+                pass
+            elif token in [StlParser.AlwaysOperator]:
+                localctx = StlParser.ExprAlwaysContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 68
+                self.match(StlParser.AlwaysOperator)
+                self.state = 70
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if _la==StlParser.LBRACK:
+                    self.state = 69
+                    self.interval()
+
+
+                self.state = 72
+                self.expression(11)
+                pass
+            elif token in [StlParser.EventuallyOperator]:
+                localctx = StlParser.ExprEvContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 73
+                self.match(StlParser.EventuallyOperator)
+                self.state = 75
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if _la==StlParser.LBRACK:
+                    self.state = 74
+                    self.interval()
+
+
+                self.state = 77
+                self.expression(10)
+                pass
+            elif token in [StlParser.HistoricallyOperator]:
+                localctx = StlParser.ExprHistContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 78
+                self.match(StlParser.HistoricallyOperator)
+                self.state = 80
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if _la==StlParser.LBRACK:
+                    self.state = 79
+                    self.interval()
+
+
+                self.state = 82
+                self.expression(7)
+                pass
+            elif token in [StlParser.OnceOperator]:
+                localctx = StlParser.ExpreOnceContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 83
+                self.match(StlParser.OnceOperator)
+                self.state = 85
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if _la==StlParser.LBRACK:
+                    self.state = 84
+                    self.interval()
+
+
+                self.state = 87
+                self.expression(6)
+                pass
+            elif token in [StlParser.RiseOperator]:
+                localctx = StlParser.ExprRiseContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 88
+                self.match(StlParser.RiseOperator)
+                self.state = 89
+                self.match(StlParser.LPAREN)
+                self.state = 90
+                self.expression(0)
+                self.state = 91
+                self.match(StlParser.RPAREN)
+                pass
+            elif token in [StlParser.FallOperator]:
+                localctx = StlParser.ExprFallContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 93
+                self.match(StlParser.FallOperator)
+                self.state = 94
+                self.match(StlParser.LPAREN)
+                self.state = 95
+                self.expression(0)
+                self.state = 96
+                self.match(StlParser.RPAREN)
+                pass
+            elif token in [StlParser.PreviousOperator]:
+                localctx = StlParser.ExprPreviousContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 98
+                self.match(StlParser.PreviousOperator)
+                self.state = 99
+                self.expression(2)
+                pass
+            elif token in [StlParser.NextOperator]:
+                localctx = StlParser.ExprNextContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 100
+                self.match(StlParser.NextOperator)
+                self.state = 101
+                self.expression(1)
+                pass
+            else:
+                raise NoViableAltException(self)
+
+            self._ctx.stop = self._input.LT(-1)
+            self.state = 143
+            self._errHandler.sync(self)
+            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
+            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                if _alt==1:
+                    if self._parseListeners is not None:
+                        self.triggerExitRuleEvent()
+                    _prevctx = localctx
+                    self.state = 141
+                    self._errHandler.sync(self)
+                    la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
+                    if la_ == 1:
+                        localctx = StlParser.ExprPredicateContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 104
+                        if not self.precpred(self._ctx, 19):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
+                        self.state = 105
+                        self.comparisonOp()
+                        self.state = 106
+                        self.expression(20)
+                        pass
+
+                    elif la_ == 2:
+                        localctx = StlParser.ExprOrContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 108
+                        if not self.precpred(self._ctx, 16):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
+                        self.state = 109
+                        self.match(StlParser.OrOperator)
+                        self.state = 110
+                        self.expression(17)
+                        pass
+
+                    elif la_ == 3:
+                        localctx = StlParser.ExprAndContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 111
+                        if not self.precpred(self._ctx, 15):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
+                        self.state = 112
+                        self.match(StlParser.AndOperator)
+                        self.state = 113
+                        self.expression(16)
+                        pass
+
+                    elif la_ == 4:
+                        localctx = StlParser.ExprImpliesContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 114
+                        if not self.precpred(self._ctx, 14):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
+                        self.state = 115
+                        self.match(StlParser.ImpliesOperator)
+                        self.state = 116
+                        self.expression(15)
+                        pass
+
+                    elif la_ == 5:
+                        localctx = StlParser.ExprIffContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 117
+                        if not self.precpred(self._ctx, 13):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
+                        self.state = 118
+                        self.match(StlParser.IffOperator)
+                        self.state = 119
+                        self.expression(14)
+                        pass
+
+                    elif la_ == 6:
+                        localctx = StlParser.ExprXorContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 120
+                        if not self.precpred(self._ctx, 12):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
+                        self.state = 121
+                        self.match(StlParser.XorOperator)
+                        self.state = 122
+                        self.expression(13)
+                        pass
+
+                    elif la_ == 7:
+                        localctx = StlParser.ExprUntilContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 123
+                        if not self.precpred(self._ctx, 9):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
+                        self.state = 124
+                        self.match(StlParser.UntilOperator)
+                        self.state = 126
+                        self._errHandler.sync(self)
+                        _la = self._input.LA(1)
+                        if _la==StlParser.LBRACK:
+                            self.state = 125
+                            self.interval()
+
+
+                        self.state = 128
+                        self.expression(10)
+                        pass
+
+                    elif la_ == 8:
+                        localctx = StlParser.ExprUnlessContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 129
+                        if not self.precpred(self._ctx, 8):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
+                        self.state = 130
+                        self.match(StlParser.UnlessOperator)
+                        self.state = 132
+                        self._errHandler.sync(self)
+                        _la = self._input.LA(1)
+                        if _la==StlParser.LBRACK:
+                            self.state = 131
+                            self.interval()
+
+
+                        self.state = 134
+                        self.expression(9)
+                        pass
+
+                    elif la_ == 9:
+                        localctx = StlParser.ExprSinceContext(self, StlParser.ExpressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
+                        self.state = 135
+                        if not self.precpred(self._ctx, 5):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
+                        self.state = 136
+                        self.match(StlParser.SinceOperator)
+                        self.state = 138
+                        self._errHandler.sync(self)
+                        _la = self._input.LA(1)
+                        if _la==StlParser.LBRACK:
+                            self.state = 137
+                            self.interval()
+
+
+                        self.state = 140
+                        self.expression(6)
+                        pass
+
+             
+                self.state = 145
+                self._errHandler.sync(self)
+                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.unrollRecursionContexts(_parentctx)
+        return localctx
+
+    class Specification_fileContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.Specification_fileContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def specification(self):
+            return self.getTypedRuleContext(StlParser.SpecificationContext,0)
+
+
+        def EOF(self):
+            return self.getToken(StlParser.EOF, 0)
+
+        def getRuleIndex(self):
+            return StlParser.RULE_specification_file
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitSpecification_file"):
+                return visitor.visitSpecification_file(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def specification_file(self):
+
+        localctx = StlParser.Specification_fileContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 8, self.RULE_specification_file)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 146
+            self.specification()
+            self.state = 147
+            self.match(StlParser.EOF)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class SpecificationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.SpecificationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def spec(self):
+            return self.getTypedRuleContext(StlParser.SpecContext,0)
+
+
+        def modimport(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.ModimportContext)
+            else:
+                return self.getTypedRuleContext(StlParser.ModimportContext,i)
+
+
+        def declaration(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.DeclarationContext)
+            else:
+                return self.getTypedRuleContext(StlParser.DeclarationContext,i)
+
+
+        def annotation(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.AnnotationContext)
+            else:
+                return self.getTypedRuleContext(StlParser.AnnotationContext,i)
+
+
+        def assertion(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.AssertionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.AssertionContext,i)
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_specification
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitSpecification"):
+                return visitor.visitSpecification(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def specification(self):
+
+        localctx = StlParser.SpecificationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 10, self.RULE_specification)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 150
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            if _la==StlParser.Specification:
+                self.state = 149
+                self.spec()
+
+
+            self.state = 155
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            while _la==StlParser.From:
+                self.state = 152
+                self.modimport()
+                self.state = 157
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+
+            self.state = 162
+            self._errHandler.sync(self)
+            _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
+            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                if _alt==1:
+                    self.state = 160
+                    self._errHandler.sync(self)
+                    token = self._input.LA(1)
+                    if token in [StlParser.Input, StlParser.Output, StlParser.Constant, StlParser.DomainTypeFloat, StlParser.DomainTypeLong, StlParser.DomainTypeComplex, StlParser.DomainTypeInt, StlParser.Identifier]:
+                        self.state = 158
+                        self.declaration()
+                        pass
+                    elif token in [StlParser.AT]:
+                        self.state = 159
+                        self.annotation()
+                        pass
+                    else:
+                        raise NoViableAltException(self)
+             
+                self.state = 164
+                self._errHandler.sync(self)
+                _alt = self._interp.adaptivePredict(self._input,16,self._ctx)
+
+            self.state = 166 
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            while True:
+                self.state = 165
+                self.assertion()
+                self.state = 168 
+                self._errHandler.sync(self)
+                _la = self._input.LA(1)
+                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << StlParser.MINUS) | (1 << StlParser.LPAREN) | (1 << StlParser.ABS) | (1 << StlParser.SQRT) | (1 << StlParser.EXP) | (1 << StlParser.POW) | (1 << StlParser.NotOperator) | (1 << StlParser.RiseOperator) | (1 << StlParser.FallOperator) | (1 << StlParser.AlwaysOperator) | (1 << StlParser.EventuallyOperator) | (1 << StlParser.HistoricallyOperator) | (1 << StlParser.OnceOperator) | (1 << StlParser.NextOperator) | (1 << StlParser.PreviousOperator))) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (StlParser.IntegerLiteral - 67)) | (1 << (StlParser.RealLiteral - 67)) | (1 << (StlParser.Identifier - 67)))) != 0)):
+                    break
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class SpecContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.SpecContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_spec
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.SpecContext, self).copyFrom(ctx)
+
+
+
+    class SpecificationIdContext(SpecContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.SpecContext)
+            super(StlParser.SpecificationIdContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Specification(self):
+            return self.getToken(StlParser.Specification, 0)
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitSpecificationId"):
+                return visitor.visitSpecificationId(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def spec(self):
+
+        localctx = StlParser.SpecContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 12, self.RULE_spec)
+        try:
+            localctx = StlParser.SpecificationIdContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 170
+            self.match(StlParser.Specification)
+            self.state = 171
+            self.match(StlParser.Identifier)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class ModimportContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.ModimportContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_modimport
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.ModimportContext, self).copyFrom(ctx)
+
+
+
+    class ModImportContext(ModimportContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ModimportContext)
+            super(StlParser.ModImportContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def From(self):
+            return self.getToken(StlParser.From, 0)
+        def Identifier(self, i=None):
+            if i is None:
+                return self.getTokens(StlParser.Identifier)
+            else:
+                return self.getToken(StlParser.Identifier, i)
+        def Import(self):
+            return self.getToken(StlParser.Import, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitModImport"):
+                return visitor.visitModImport(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def modimport(self):
+
+        localctx = StlParser.ModimportContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 14, self.RULE_modimport)
+        try:
+            localctx = StlParser.ModImportContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 173
+            self.match(StlParser.From)
+            self.state = 174
+            self.match(StlParser.Identifier)
+            self.state = 175
+            self.match(StlParser.Import)
+            self.state = 176
+            self.match(StlParser.Identifier)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class AssertionContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.AssertionContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def EQUAL(self):
+            return self.getToken(StlParser.EQUAL, 0)
+
+        def getRuleIndex(self):
+            return StlParser.RULE_assertion
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAssertion"):
+                return visitor.visitAssertion(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def assertion(self):
+
+        localctx = StlParser.AssertionContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 16, self.RULE_assertion)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 180
+            self._errHandler.sync(self)
+            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
+            if la_ == 1:
+                self.state = 178
+                self.match(StlParser.Identifier)
+                self.state = 179
+                self.match(StlParser.EQUAL)
+
+
+            self.state = 182
+            self.expression(0)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class DeclarationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.DeclarationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_declaration
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.DeclarationContext, self).copyFrom(ctx)
+
+
+
+    class DeclVariableContext(DeclarationContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.DeclarationContext)
+            super(StlParser.DeclVariableContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def variableDeclaration(self):
+            return self.getTypedRuleContext(StlParser.VariableDeclarationContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitDeclVariable"):
+                return visitor.visitDeclVariable(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class DeclConstantContext(DeclarationContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.DeclarationContext)
+            super(StlParser.DeclConstantContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def constantDeclaration(self):
+            return self.getTypedRuleContext(StlParser.ConstantDeclarationContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitDeclConstant"):
+                return visitor.visitDeclConstant(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def declaration(self):
+
+        localctx = StlParser.DeclarationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 18, self.RULE_declaration)
+        try:
+            self.state = 186
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [StlParser.Input, StlParser.Output, StlParser.DomainTypeFloat, StlParser.DomainTypeLong, StlParser.DomainTypeComplex, StlParser.DomainTypeInt, StlParser.Identifier]:
+                localctx = StlParser.DeclVariableContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 184
+                self.variableDeclaration()
+                pass
+            elif token in [StlParser.Constant]:
+                localctx = StlParser.DeclConstantContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 185
+                self.constantDeclaration()
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class AnnotationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.AnnotationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def AT(self):
+            return self.getToken(StlParser.AT, 0)
+
+        def annotation_type(self):
+            return self.getTypedRuleContext(StlParser.Annotation_typeContext,0)
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_annotation
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAnnotation"):
+                return visitor.visitAnnotation(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def annotation(self):
+
+        localctx = StlParser.AnnotationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 20, self.RULE_annotation)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 188
+            self.match(StlParser.AT)
+            self.state = 189
+            self.annotation_type()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class Annotation_typeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.Annotation_typeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_annotation_type
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.Annotation_typeContext, self).copyFrom(ctx)
+
+
+
+    class RosTopicContext(Annotation_typeContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Annotation_typeContext)
+            super(StlParser.RosTopicContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def ROS_Topic(self):
+            return self.getToken(StlParser.ROS_Topic, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def Identifier(self, i=None):
+            if i is None:
+                return self.getTokens(StlParser.Identifier)
+            else:
+                return self.getToken(StlParser.Identifier, i)
+        def COMMA(self):
+            return self.getToken(StlParser.COMMA, 0)
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitRosTopic"):
+                return visitor.visitRosTopic(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def annotation_type(self):
+
+        localctx = StlParser.Annotation_typeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 22, self.RULE_annotation_type)
+        try:
+            localctx = StlParser.RosTopicContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 191
+            self.match(StlParser.ROS_Topic)
+            self.state = 192
+            self.match(StlParser.LPAREN)
+            self.state = 193
+            self.match(StlParser.Identifier)
+            self.state = 194
+            self.match(StlParser.COMMA)
+            self.state = 195
+            self.match(StlParser.Identifier)
+            self.state = 196
+            self.match(StlParser.RPAREN)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class VariableDeclarationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.VariableDeclarationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def domainType(self):
+            return self.getTypedRuleContext(StlParser.DomainTypeContext,0)
+
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def ioType(self):
+            return self.getTypedRuleContext(StlParser.IoTypeContext,0)
+
+
+        def assignment(self):
+            return self.getTypedRuleContext(StlParser.AssignmentContext,0)
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_variableDeclaration
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitVariableDeclaration"):
+                return visitor.visitVariableDeclaration(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def variableDeclaration(self):
+
+        localctx = StlParser.VariableDeclarationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 24, self.RULE_variableDeclaration)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 199
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            if _la==StlParser.Input or _la==StlParser.Output:
+                self.state = 198
+                self.ioType()
+
+
+            self.state = 201
+            self.domainType()
+            self.state = 202
+            self.match(StlParser.Identifier)
+            self.state = 204
+            self._errHandler.sync(self)
+            _la = self._input.LA(1)
+            if _la==StlParser.EQUAL:
+                self.state = 203
+                self.assignment()
+
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class ConstantDeclarationContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.ConstantDeclarationContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def Constant(self):
+            return self.getToken(StlParser.Constant, 0)
+
+        def domainType(self):
+            return self.getTypedRuleContext(StlParser.DomainTypeContext,0)
+
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def EQUAL(self):
+            return self.getToken(StlParser.EQUAL, 0)
+
+        def literal(self):
+            return self.getTypedRuleContext(StlParser.LiteralContext,0)
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_constantDeclaration
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitConstantDeclaration"):
+                return visitor.visitConstantDeclaration(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def constantDeclaration(self):
+
+        localctx = StlParser.ConstantDeclarationContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 26, self.RULE_constantDeclaration)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 206
+            self.match(StlParser.Constant)
+            self.state = 207
+            self.domainType()
+            self.state = 208
+            self.match(StlParser.Identifier)
+            self.state = 209
+            self.match(StlParser.EQUAL)
+            self.state = 210
+            self.literal()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class AssignmentContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.AssignmentContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_assignment
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.AssignmentContext, self).copyFrom(ctx)
+
+
+
+    class AsgnExprContext(AssignmentContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.AssignmentContext)
+            super(StlParser.AsgnExprContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EQUAL(self):
+            return self.getToken(StlParser.EQUAL, 0)
+        def expression(self):
+            return self.getTypedRuleContext(StlParser.ExpressionContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAsgnExpr"):
+                return visitor.visitAsgnExpr(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class AsgnLiteralContext(AssignmentContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.AssignmentContext)
+            super(StlParser.AsgnLiteralContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EQUAL(self):
+            return self.getToken(StlParser.EQUAL, 0)
+        def literal(self):
+            return self.getTypedRuleContext(StlParser.LiteralContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitAsgnLiteral"):
+                return visitor.visitAsgnLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def assignment(self):
+
+        localctx = StlParser.AssignmentContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 28, self.RULE_assignment)
+        try:
+            self.state = 216
+            self._errHandler.sync(self)
+            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
+            if la_ == 1:
+                localctx = StlParser.AsgnLiteralContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 212
+                self.match(StlParser.EQUAL)
+                self.state = 213
+                self.literal()
+                pass
+
+            elif la_ == 2:
+                localctx = StlParser.AsgnExprContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 214
+                self.match(StlParser.EQUAL)
+                self.state = 215
+                self.expression(0)
+                pass
+
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class DomainTypeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.DomainTypeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def DomainTypeFloat(self):
+            return self.getToken(StlParser.DomainTypeFloat, 0)
+
+        def DomainTypeInt(self):
+            return self.getToken(StlParser.DomainTypeInt, 0)
+
+        def DomainTypeLong(self):
+            return self.getToken(StlParser.DomainTypeLong, 0)
+
+        def DomainTypeComplex(self):
+            return self.getToken(StlParser.DomainTypeComplex, 0)
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def getRuleIndex(self):
+            return StlParser.RULE_domainType
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitDomainType"):
+                return visitor.visitDomainType(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def domainType(self):
+
+        localctx = StlParser.DomainTypeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 30, self.RULE_domainType)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 218
+            _la = self._input.LA(1)
+            if not(((((_la - 32)) & ~0x3f) == 0 and ((1 << (_la - 32)) & ((1 << (StlParser.DomainTypeFloat - 32)) | (1 << (StlParser.DomainTypeLong - 32)) | (1 << (StlParser.DomainTypeComplex - 32)) | (1 << (StlParser.DomainTypeInt - 32)) | (1 << (StlParser.Identifier - 32)))) != 0)):
+                self._errHandler.recoverInline(self)
+            else:
+                self._errHandler.reportMatch(self)
+                self.consume()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class IoTypeContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.IoTypeContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def Input(self):
+            return self.getToken(StlParser.Input, 0)
+
+        def Output(self):
+            return self.getToken(StlParser.Output, 0)
+
+        def getRuleIndex(self):
+            return StlParser.RULE_ioType
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitIoType"):
+                return visitor.visitIoType(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def ioType(self):
+
+        localctx = StlParser.IoTypeContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 32, self.RULE_ioType)
+        self._la = 0 # Token type
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 220
+            _la = self._input.LA(1)
+            if not(_la==StlParser.Input or _la==StlParser.Output):
+                self._errHandler.recoverInline(self)
+            else:
+                self._errHandler.reportMatch(self)
+                self.consume()
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class Real_expressionContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.Real_expressionContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_real_expression
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.Real_expressionContext, self).copyFrom(ctx)
+
+
+    class ExprSubtractionContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprSubtractionContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
+
+        def MINUS(self):
+            return self.getToken(StlParser.MINUS, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprSubtraction"):
+                return visitor.visitExprSubtraction(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprPowContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprPowContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def POW(self):
+            return self.getToken(StlParser.POW, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
+
+        def COMMA(self):
+            return self.getToken(StlParser.COMMA, 0)
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprPow"):
+                return visitor.visitExprPow(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprDivisionContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprDivisionContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
+
+        def DIVIDE(self):
+            return self.getToken(StlParser.DIVIDE, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprDivision"):
+                return visitor.visitExprDivision(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprMultiplicationContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprMultiplicationContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
+
+        def TIMES(self):
+            return self.getToken(StlParser.TIMES, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprMultiplication"):
+                return visitor.visitExprMultiplication(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprLiteralContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprLiteralContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def literal(self):
+            return self.getTypedRuleContext(StlParser.LiteralContext,0)
+
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprLiteral"):
+                return visitor.visitExprLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprExpContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprExpContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EXP(self):
+            return self.getToken(StlParser.EXP, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def real_expression(self):
+            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprExp"):
+                return visitor.visitExprExp(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprSqrtContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprSqrtContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def SQRT(self):
+            return self.getToken(StlParser.SQRT, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def real_expression(self):
+            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprSqrt"):
+                return visitor.visitExprSqrt(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprIdContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprIdContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprId"):
+                return visitor.visitExprId(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAbsContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprAbsContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def ABS(self):
+            return self.getToken(StlParser.ABS, 0)
+        def LPAREN(self):
+            return self.getToken(StlParser.LPAREN, 0)
+        def real_expression(self):
+            return self.getTypedRuleContext(StlParser.Real_expressionContext,0)
+
+        def RPAREN(self):
+            return self.getToken(StlParser.RPAREN, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAbs"):
+                return visitor.visitExprAbs(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class ExprAdditionContext(Real_expressionContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.Real_expressionContext)
+            super(StlParser.ExprAdditionContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def real_expression(self, i=None):
+            if i is None:
+                return self.getTypedRuleContexts(StlParser.Real_expressionContext)
+            else:
+                return self.getTypedRuleContext(StlParser.Real_expressionContext,i)
+
+        def PLUS(self):
+            return self.getToken(StlParser.PLUS, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitExprAddition"):
+                return visitor.visitExprAddition(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def real_expression(self, _p=0):
+        _parentctx = self._ctx
+        _parentState = self.state
+        localctx = StlParser.Real_expressionContext(self, self._ctx, _parentState)
+        _prevctx = localctx
+        _startState = 34
+        self.enterRecursionRule(localctx, 34, self.RULE_real_expression, _p)
+        try:
+            self.enterOuterAlt(localctx, 1)
+            self.state = 247
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [StlParser.Identifier]:
+                localctx = StlParser.ExprIdContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+
+                self.state = 223
+                self.match(StlParser.Identifier)
+                pass
+            elif token in [StlParser.MINUS, StlParser.IntegerLiteral, StlParser.RealLiteral]:
+                localctx = StlParser.ExprLiteralContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 224
+                self.literal()
+                pass
+            elif token in [StlParser.ABS]:
+                localctx = StlParser.ExprAbsContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 225
+                self.match(StlParser.ABS)
+                self.state = 226
+                self.match(StlParser.LPAREN)
+                self.state = 227
+                self.real_expression(0)
+                self.state = 228
+                self.match(StlParser.RPAREN)
+                pass
+            elif token in [StlParser.SQRT]:
+                localctx = StlParser.ExprSqrtContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 230
+                self.match(StlParser.SQRT)
+                self.state = 231
+                self.match(StlParser.LPAREN)
+                self.state = 232
+                self.real_expression(0)
+                self.state = 233
+                self.match(StlParser.RPAREN)
+                pass
+            elif token in [StlParser.EXP]:
+                localctx = StlParser.ExprExpContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 235
+                self.match(StlParser.EXP)
+                self.state = 236
+                self.match(StlParser.LPAREN)
+                self.state = 237
+                self.real_expression(0)
+                self.state = 238
+                self.match(StlParser.RPAREN)
+                pass
+            elif token in [StlParser.POW]:
+                localctx = StlParser.ExprPowContext(self, localctx)
+                self._ctx = localctx
+                _prevctx = localctx
+                self.state = 240
+                self.match(StlParser.POW)
+                self.state = 241
+                self.match(StlParser.LPAREN)
+                self.state = 242
+                self.real_expression(0)
+                self.state = 243
+                self.match(StlParser.COMMA)
+                self.state = 244
+                self.real_expression(0)
+                self.state = 245
+                self.match(StlParser.RPAREN)
+                pass
+            else:
+                raise NoViableAltException(self)
+
+            self._ctx.stop = self._input.LT(-1)
+            self.state = 263
+            self._errHandler.sync(self)
+            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
+            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                if _alt==1:
+                    if self._parseListeners is not None:
+                        self.triggerExitRuleEvent()
+                    _prevctx = localctx
+                    self.state = 261
+                    self._errHandler.sync(self)
+                    la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
+                    if la_ == 1:
+                        localctx = StlParser.ExprAdditionContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 249
+                        if not self.precpred(self._ctx, 8):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
+                        self.state = 250
+                        self.match(StlParser.PLUS)
+                        self.state = 251
+                        self.real_expression(9)
+                        pass
+
+                    elif la_ == 2:
+                        localctx = StlParser.ExprSubtractionContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 252
+                        if not self.precpred(self._ctx, 7):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
+                        self.state = 253
+                        self.match(StlParser.MINUS)
+                        self.state = 254
+                        self.real_expression(8)
+                        pass
+
+                    elif la_ == 3:
+                        localctx = StlParser.ExprMultiplicationContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 255
+                        if not self.precpred(self._ctx, 6):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
+                        self.state = 256
+                        self.match(StlParser.TIMES)
+                        self.state = 257
+                        self.real_expression(7)
+                        pass
+
+                    elif la_ == 4:
+                        localctx = StlParser.ExprDivisionContext(self, StlParser.Real_expressionContext(self, _parentctx, _parentState))
+                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_expression)
+                        self.state = 258
+                        if not self.precpred(self._ctx, 5):
+                            from antlr4.error.Errors import FailedPredicateException
+                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
+                        self.state = 259
+                        self.match(StlParser.DIVIDE)
+                        self.state = 260
+                        self.real_expression(6)
+                        pass
+
+             
+                self.state = 265
+                self._errHandler.sync(self)
+                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.unrollRecursionContexts(_parentctx)
+        return localctx
+
+    class ComparisonOpContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.ComparisonOpContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_comparisonOp
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.ComparisonOpContext, self).copyFrom(ctx)
+
+
+
+    class GeqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
+            super(StlParser.GeqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def GreaterOrEqualOperator(self):
+            return self.getToken(StlParser.GreaterOrEqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitGeq"):
+                return visitor.visitGeq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class LeqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
+            super(StlParser.LeqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def LesserOrEqualOperator(self):
+            return self.getToken(StlParser.LesserOrEqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitLeq"):
+                return visitor.visitLeq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class GreaterContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
+            super(StlParser.GreaterContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def GreaterOperator(self):
+            return self.getToken(StlParser.GreaterOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitGreater"):
+                return visitor.visitGreater(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class NeqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
+            super(StlParser.NeqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def NotEqualOperator(self):
+            return self.getToken(StlParser.NotEqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitNeq"):
+                return visitor.visitNeq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class EqContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
+            super(StlParser.EqContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def EqualOperator(self):
+            return self.getToken(StlParser.EqualOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitEq"):
+                return visitor.visitEq(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+    class LessContext(ComparisonOpContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.ComparisonOpContext)
+            super(StlParser.LessContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def LesserOperator(self):
+            return self.getToken(StlParser.LesserOperator, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitLess"):
+                return visitor.visitLess(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def comparisonOp(self):
+
+        localctx = StlParser.ComparisonOpContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 36, self.RULE_comparisonOp)
+        try:
+            self.state = 272
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [StlParser.LesserOrEqualOperator]:
+                localctx = StlParser.LeqContext(self, localctx)
+                self.enterOuterAlt(localctx, 1)
+                self.state = 266
+                self.match(StlParser.LesserOrEqualOperator)
+                pass
+            elif token in [StlParser.GreaterOrEqualOperator]:
+                localctx = StlParser.GeqContext(self, localctx)
+                self.enterOuterAlt(localctx, 2)
+                self.state = 267
+                self.match(StlParser.GreaterOrEqualOperator)
+                pass
+            elif token in [StlParser.LesserOperator]:
+                localctx = StlParser.LessContext(self, localctx)
+                self.enterOuterAlt(localctx, 3)
+                self.state = 268
+                self.match(StlParser.LesserOperator)
+                pass
+            elif token in [StlParser.GreaterOperator]:
+                localctx = StlParser.GreaterContext(self, localctx)
+                self.enterOuterAlt(localctx, 4)
+                self.state = 269
+                self.match(StlParser.GreaterOperator)
+                pass
+            elif token in [StlParser.EqualOperator]:
+                localctx = StlParser.EqContext(self, localctx)
+                self.enterOuterAlt(localctx, 5)
+                self.state = 270
+                self.match(StlParser.EqualOperator)
+                pass
+            elif token in [StlParser.NotEqualOperator]:
+                localctx = StlParser.NeqContext(self, localctx)
+                self.enterOuterAlt(localctx, 6)
+                self.state = 271
+                self.match(StlParser.NotEqualOperator)
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class LiteralContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.LiteralContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+        def IntegerLiteral(self):
+            return self.getToken(StlParser.IntegerLiteral, 0)
+
+        def RealLiteral(self):
+            return self.getToken(StlParser.RealLiteral, 0)
+
+        def MINUS(self):
+            return self.getToken(StlParser.MINUS, 0)
+
+        def literal(self):
+            return self.getTypedRuleContext(StlParser.LiteralContext,0)
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_literal
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitLiteral"):
+                return visitor.visitLiteral(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+
+    def literal(self):
+
+        localctx = StlParser.LiteralContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 38, self.RULE_literal)
+        try:
+            self.state = 278
+            self._errHandler.sync(self)
+            token = self._input.LA(1)
+            if token in [StlParser.IntegerLiteral]:
+                self.enterOuterAlt(localctx, 1)
+                self.state = 274
+                self.match(StlParser.IntegerLiteral)
+                pass
+            elif token in [StlParser.RealLiteral]:
+                self.enterOuterAlt(localctx, 2)
+                self.state = 275
+                self.match(StlParser.RealLiteral)
+                pass
+            elif token in [StlParser.MINUS]:
+                self.enterOuterAlt(localctx, 3)
+                self.state = 276
+                self.match(StlParser.MINUS)
+                self.state = 277
+                self.literal()
+                pass
+            else:
+                raise NoViableAltException(self)
+
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+    class IdentifierContext(ParserRuleContext):
+
+        def __init__(self, parser, parent=None, invokingState=-1):
+            super(StlParser.IdentifierContext, self).__init__(parent, invokingState)
+            self.parser = parser
+
+
+        def getRuleIndex(self):
+            return StlParser.RULE_identifier
+
+     
+        def copyFrom(self, ctx):
+            super(StlParser.IdentifierContext, self).copyFrom(ctx)
+
+
+
+    class IdContext(IdentifierContext):
+
+        def __init__(self, parser, ctx): # actually a StlParser.IdentifierContext)
+            super(StlParser.IdContext, self).__init__(parser)
+            self.copyFrom(ctx)
+
+        def Identifier(self):
+            return self.getToken(StlParser.Identifier, 0)
+
+        def accept(self, visitor):
+            if hasattr(visitor, "visitId"):
+                return visitor.visitId(self)
+            else:
+                return visitor.visitChildren(self)
+
+
+
+    def identifier(self):
+
+        localctx = StlParser.IdentifierContext(self, self._ctx, self.state)
+        self.enterRule(localctx, 40, self.RULE_identifier)
+        try:
+            localctx = StlParser.IdContext(self, localctx)
+            self.enterOuterAlt(localctx, 1)
+            self.state = 280
+            self.match(StlParser.Identifier)
+        except RecognitionException as re:
+            localctx.exception = re
+            self._errHandler.reportError(self, re)
+            self._errHandler.recover(self, re)
+        finally:
+            self.exitRule()
+        return localctx
+
+
+
+    def sempred(self, localctx, ruleIndex, predIndex):
+        if self._predicates == None:
+            self._predicates = dict()
+        self._predicates[3] = self.expression_sempred
+        self._predicates[17] = self.real_expression_sempred
+        pred = self._predicates.get(ruleIndex, None)
+        if pred is None:
+            raise Exception("No predicate with index:" + str(ruleIndex))
+        else:
+            return pred(localctx, predIndex)
+
+    def expression_sempred(self, localctx, predIndex):
+            if predIndex == 0:
+                return self.precpred(self._ctx, 19)
+         
+
+            if predIndex == 1:
+                return self.precpred(self._ctx, 16)
+         
+
+            if predIndex == 2:
+                return self.precpred(self._ctx, 15)
+         
+
+            if predIndex == 3:
+                return self.precpred(self._ctx, 14)
+         
+
+            if predIndex == 4:
+                return self.precpred(self._ctx, 13)
+         
+
+            if predIndex == 5:
+                return self.precpred(self._ctx, 12)
+         
+
+            if predIndex == 6:
+                return self.precpred(self._ctx, 9)
+         
+
+            if predIndex == 7:
+                return self.precpred(self._ctx, 8)
+         
+
+            if predIndex == 8:
+                return self.precpred(self._ctx, 5)
+         
+
+    def real_expression_sempred(self, localctx, predIndex):
+            if predIndex == 9:
+                return self.precpred(self._ctx, 8)
+         
+
+            if predIndex == 10:
+                return self.precpred(self._ctx, 7)
+         
+
+            if predIndex == 11:
+                return self.precpred(self._ctx, 6)
+         
+
+            if predIndex == 12:
+                return self.precpred(self._ctx, 5)
+         
+
+
+
+
```

### Comparing `rtamt-0.3/rtamt/parser/stl/error/parser_error_listener.py` & `rtamt-0.3.5/rtamt/antlr/parser/ltl/error/parser_error_listener.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-from antlr4.error.ErrorListener import ErrorListener
-from rtamt.exception.stl.exception import STLParseException
-
-class STLParserErrorListener( ErrorListener ):
-    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):
-        raise STLParseException (str(line) + ":" + str(column) + ": Syntax ERROR, " + str(msg))
-
-    def reportAmbiguity(self, recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs):
-        raise STLParseException("Ambiguity ERROR, " + str(configs))
-
-    def reportAttemptingFullContext(self, recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs):
-        raise STLParseException("Attempting full context ERROR, " + str(configs))
-
-    def reportContextSensitivity(self, recognizer, dfa, startIndex, stopIndex, prediction, configs):
-        raise STLParseException("Context ERROR, " + str(configs))
+from antlr4.error.ErrorListener import ErrorListener
+from rtamt.exception.exception import RTAMTException
+
+class LTLParserErrorListener( ErrorListener ):
+    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):
+        raise RTAMTException (str(line) + ":" + str(column) + ": Syntax ERROR, " + str(msg))
+
+    def reportAmbiguity(self, recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs):
+        raise RTAMTException("Ambiguity ERROR, " + str(configs))
+
+    def reportAttemptingFullContext(self, recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs):
+        raise RTAMTException("Attempting full context ERROR, " + str(configs))
+
+    def reportContextSensitivity(self, recognizer, dfa, startIndex, stopIndex, prediction, configs):
+        raise RTAMTException("Context ERROR, " + str(configs))
```

### Comparing `rtamt-0.3/rtamt/pastifier/stl/horizon.py` & `rtamt-0.3.5/rtamt/pastifier/stl/horizon.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,60 +1,54 @@
-from rtamt.ast.visitor.stl.ASTVisitor import STLASTVisitor
-from rtamt.pastifier.ltl.horizon import LTLHorizon
-from rtamt.pastifier.ltl.pastifier import LTLPastifier
-
-from rtamt.node.ltl.variable import Variable
-from rtamt.node.stl.timed_precedes import TimedPrecedes
-from rtamt.node.stl.timed_historically import TimedHistorically
-from rtamt.node.stl.timed_once import TimedOnce
-from rtamt.node.stl.timed_since import TimedSince
-
-from rtamt.exception.stl.exception import STLException
-
-class STLHorizon(LTLHorizon, STLASTVisitor):
-
-    def __init__(self):
-        LTLHorizon.__init__(self)
-
-    def visit(self, element, args):
-        return STLASTVisitor.visit(self, element, args)
-
-    def visitTimedEventually(self, element, args):
-        op_horizon = self.visit(element.children[0], args)
-
-        return op_horizon + element.end
-
-    def visitTimedAlways(self, element, args):
-        op_horizon = self.visit(element.children[0], args)
-
-        return op_horizon + element.end
-
-    def visitTimedUntil(self, element, args):
-        op1_horizon = self.visit(element.children[0], args)
-        op2_horizon = self.visit(element.children[1], args)
-
-        return max(op1_horizon, op2_horizon) + element.end
-
-    def visitTimedOnce(self, element, args):
-        op_horizon = self.visit(element.children[0], args)
-
-        return op_horizon
-
-    def visitTimedHistorically(self, element, args):
-        op_horizon = self.visit(element.children[0], args)
-
-        return op_horizon
-
-    def visitTimedSince(self, element, args):
-        op1_horizon = self.visit(element.children[0], args)
-        op2_horizon = self.visit(element.children[1], args)
-
-        return max(op1_horizon, op2_horizon)
-
-    def visitTimedPrecedes(self, element, args):
-        op1_horizon = self.visit(element.children[0], args)
-        op2_horizon = self.visit(element.children[1], args)
-
-        return max(op1_horizon, op2_horizon)
-
-    def visitDefault(self, element):
-        raise STLException('STL Pastifier: encountered unexpected type of node.')
+from rtamt.syntax.ast.visitor.stl.ast_visitor import StlAstVisitor
+from rtamt.pastifier.ltl.horizon import LtlHorizon
+
+from rtamt.exception.exception import RTAMTException
+
+
+class StlHorizon(LtlHorizon, StlAstVisitor):
+
+    def __init__(self):
+        LtlHorizon.__init__(self)
+
+    def visit(self, node, *args, **kwargs):
+        return StlAstVisitor.visit(self, node, *args, **kwargs)
+
+    def visitTimedEventually(self, node, *args, **kwargs):
+        op_horizon = self.visit(node.children[0], *args, **kwargs)
+
+        return op_horizon + node.end
+
+    def visitTimedAlways(self, node, *args, **kwargs):
+        op_horizon = self.visit(node.children[0], *args, **kwargs)
+
+        return op_horizon + node.end
+
+    def visitTimedUntil(self, node, *args, **kwargs):
+        op1_horizon = self.visit(node.children[0], *args, **kwargs)
+        op2_horizon = self.visit(node.children[1], *args, **kwargs)
+
+        return max(op1_horizon, op2_horizon) + node.end
+
+    def visitTimedOnce(self, node, *args, **kwargs):
+        op_horizon = self.visit(node.children[0], *args, **kwargs)
+
+        return op_horizon
+
+    def visitTimedHistorically(self, node, *args, **kwargs):
+        op_horizon = self.visit(node.children[0], *args, **kwargs)
+
+        return op_horizon
+
+    def visitTimedSince(self, node, *args, **kwargs):
+        op1_horizon = self.visit(node.children[0], *args, **kwargs)
+        op2_horizon = self.visit(node.children[1], *args, **kwargs)
+
+        return max(op1_horizon, op2_horizon)
+
+    def visitTimedPrecedes(self, node, *args, **kwargs):
+        op1_horizon = self.visit(node.children[0], *args, **kwargs)
+        op2_horizon = self.visit(node.children[1], *args, **kwargs)
+
+        return max(op1_horizon, op2_horizon)
+
+    def visitDefault(self, node):
+        raise RTAMTException('STL Pastifier: encountered unexpected type of node.')
```

### Comparing `rtamt-0.3/rtamt/spec/ltl/discrete_time/specification.py` & `rtamt-0.3.5/rtamt/spec/ltl/discrete_time/specification.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,277 +1,257 @@
-import logging
-import importlib
-
-from antlr4 import *
-from antlr4.InputStream import InputStream
-
-from rtamt.spec.abstract_specification import AbstractSpecification
-
-from rtamt.parser.ltl.LtlLexer import LtlLexer
-from rtamt.parser.ltl.LtlParser import LtlParser
-from rtamt.spec.ltl.discrete_time.specification_parser import LTLSpecificationParser
-
-from rtamt.parser.ltl.error.parser_error_listener import LTLParserErrorListener
-from rtamt.exception.stl.exception import STLParseException
-
-from rtamt.pastifier.ltl.pastifier import LTLPastifier
-from rtamt.evaluator.ltl.online_evaluator import LTLEvaluator
-from rtamt.reset.ltl.reset import LTLReset
-from rtamt.enumerations.options import *
-
-
-class LTLDiscreteTimeSpecification(AbstractSpecification):
-    """A class used as a container for STL specifications
-
-    Attributes:
-        name : String
-
-        vars : set(String) - set of variable names
-        free_vars : set(String) - set of free variable names
-
-        sampling_period : int - size of the sampling period
-
-
-        var_object_dict : dict(String,AbstractNode) - dictionary that maps variable names to their Node instances
-        modules : dict(String,String) - dictionary that maps module paths to module names
-
-        top : AbstractNode - pointer to the specification parse tree
-
-        online_evaluator : AbstractEvaluator - pointer to the object that implements the monitoring algorithm
-
-        update_counter : int
-        previous_time : float
-        sampling_violation_counter : int
-
-    """
-
-    def __init__(self, semantics=Semantics.STANDARD, language=Language.PYTHON):
-        """Constructor for STL Specification"""
-        super(LTLDiscreteTimeSpecification, self).__init__()
-        self.name = 'LTL Specification'
-
-        self.reseter = LTLReset()
-        self.semantics = semantics
-        self.language = language
-
-        self.in_vars = set()
-        self.out_vars = set()
-
-    def set_var_io_type(self, var_name, var_iotype):
-        if not var_name in self.vars:
-            logging.warning('The variable {} does not exist'.format(var_name))
-        else:
-            if var_iotype == 'input':
-                self.add_input_var(var_name)
-                self.remove_output_var(var_name)
-                self.var_io_dict[var_name] = 'input'
-            elif var_iotype == 'output':
-                self.add_output_var(var_name)
-                self.remove_input_var(var_name)
-                self.var_io_dict[var_name] = 'output'
-            else:
-                self.remove_input_var(var_name)
-                self.remove_output_var(var_name)
-                self.var_io_dict[var_name] = 'undefined'
-
-    def add_input_var(self, input_var):
-        self.in_vars.add(input_var)
-
-    def remove_input_var(self, var):
-        self.in_vars.discard(var)
-
-    def add_output_var(self, output_var):
-        self.out_vars.add(output_var)
-
-    def remove_output_var(self, var):
-        self.out_vars.discard(var)
-
-    def import_module(self, from_name, module_name):
-        try:
-            module = importlib.import_module(from_name)
-            self.modules[module_name] = module
-        except ImportError:
-            raise STLParseException('The module {} cannot be loaded'.format(from_name))
-
-    def declare_const(self, const_name, const_type, const_val):
-        if const_name in self.vars:
-            raise STLParseException('Constant {} already declared'.format(const_name))
-
-        self.const_type_dict[const_name] = const_type
-        self.const_val_dict[const_name] = const_val
-        self.vars.add(const_name)
-
-    def declare_var(self, var_name, var_type):
-        if var_name in self.vars:
-            logging.warning(
-                'Variable {} was already declared. It is now overriden with the new declaration.'.format(var_name))
-
-        # Associate to variable name 'var' its type 'type'
-        self.var_type_dict[var_name] = var_type
-
-        # Add variable name 'var' to the set of variables
-        self.add_var(var_name)
-        self.free_vars.add(var_name)
-        instance = self.create_var_from_name(var_name)
-        self.var_object_dict[var_name] = instance
-
-        # Add the default variable topic to var
-        self.var_topic_dict[var_name] = 'rtamt/{}'.format(var_name)
-
-        self.var_io_dict[var_name] = 'output'
-
-    def set_var_topic(self, var_name, var_topic):
-        if not var_name in self.vars:
-            logging.warning(
-                'The variable {0} is not declared. Setting its topic name to {1} is ignored.'.format(var_name,
-                                                                                                     var_topic))
-        else:
-            topic = self.var_topic_dict[var_name]
-            self.var_topic_dict[var_name] = var_topic
-
-    def create_var_from_name(self, var_name):
-        var = None
-        var_type = self.var_type_dict[var_name]
-        if var_type.encode('utf-8') == 'float'.encode('utf-8'):
-            var = float()
-        elif var_type.encode('utf-8') == 'int'.encode('utf-8'):
-            var = int()
-        elif var_type.encode('utf-8') == 'complex'.encode('utf-8'):
-            var = complex()
-        else:
-            try:
-                var_module = self.modules[var_type]
-                class_ = getattr(var_module, var_type)
-                var = class_()
-            except KeyError:
-                raise STLParseException('The type {} does not seem to be imported.'.format(var_type))
-        return var
-
-    @property
-    def semantics(self):
-        return self.__semantics
-
-    @semantics.setter
-    def semantics(self, semantics):
-        self.__semantics = semantics
-
-    @property
-    def in_vars(self):
-        return self.__in_vars
-
-    @in_vars.setter
-    def in_vars(self, in_vars):
-        self.__in_vars = in_vars
-
-    @property
-    def out_vars(self):
-        return self.__out_vars
-
-    @out_vars.setter
-    def out_vars(self, out_vars):
-        self.__out_vars = out_vars
-
-    # Parses the STL property
-    # string can be either file path containing the STL property
-    # or the textual property itself
-    def parse(self):
-        if self.spec is None:
-            raise STLParseException('STL specification if empty')
-
-        # Parse the STL spec - ANTLR4 magic
-
-        entire_spec = self.modular_spec + self.spec
-        input_stream = InputStream(entire_spec)
-        lexer = LtlLexer(input_stream)
-        stream = CommonTokenStream(lexer)
-        parser = LtlParser(stream)
-        parser._listeners = [LTLParserErrorListener()]
-        ctx = parser.specification_file()
-
-        # Create the visitor for the actual spec nodes
-        visitor = LTLSpecificationParser(self)
-        self.top = visitor.visitSpecification_file(ctx)
-
-    def pastify(self):
-        # Translate bounded future STL to past STL
-        pastifier = LTLPastifier()
-        self.top.accept(pastifier)
-
-        # evaluate modular sub-specs
-        for key in self.var_subspec_dict:
-            node = self.var_subspec_dict[key]
-            node.accept(pastifier)
-            node = pastifier.pastify(node)
-            self.var_subspec_dict[key] = node
-
-        past = pastifier.pastify(self.top)
-        self.top = past
-
-    def update(self, timestamp, list_inputs):
-        # timestamp - float
-        # inputs - list of [var name, var value] pairs
-        # Example:
-        # update(3.48, [['a', 2.2], ['b', 3.3]])
-
-        if self.online_evaluator == None:
-            self.online_evaluator = LTLEvaluator(self)
-            self.top.accept(self.online_evaluator)
-
-        # update the value of every input variable
-        for inp in list_inputs:
-            var_name = inp[0]
-            var_value = inp[1]
-            self.var_object_dict[var_name] = var_value
-
-        # evaluate modular sub-specs
-        for key in self.var_subspec_dict:
-            node = self.var_subspec_dict[key]
-            out = self.online_evaluator.evaluate(node, [])
-            self.var_object_dict[key] = out
-
-        # The evaluation done wrt the discrete counter (logical time)
-        out = self.online_evaluator.evaluate(self.top, [])
-
-        return out
-
-    def evaluate(self, *args, **kargs):
-        pass
-
-    def reset(self):
-        if self.online_evaluator is not None:
-            self.reseter.node_monitor_dict = self.online_evaluator.node_monitor_dict
-            self.top.accept(self.reseter)
-            self.reseter.reset(self.top)
-            self.update_counter = int(0);
-            self.previous_time = float(0.0);
-            self.sampling_violation_counter = int(0);
-
-    # def offline(self, dataset):
-    #     counter = 0
-    #     prev_signal_length = 0
-    #     signal_length = 0
-    #     out = 0
-    #
-    #     for var_name in dataset:
-    #         signal_length = len(dataset[var_name])
-    #         if counter > 0 and not (signal_length == prev_signal_length):
-    #             raise STLOfflineException('Input signals have different length')
-    #         prev_signal_length = signal_length
-    #         counter = counter + 1
-    #
-    #     for i in range(signal_length):
-    #         signal_snapshot = []
-    #         counter = 0
-    #         prev_time = 0
-    #         for var_name in dataset:
-    #             signal = dataset[var_name]
-    #             sample = signal[i]
-    #             time = sample[0]
-    #             value = sample[1]
-    #             if counter > 0 and not (time == prev_time):
-    #                 raise STLOfflineException('The time indices do not agree')
-    #             signal_snapshot.append((var_name, value))
-    #             counter = counter + 1
-    #             prev_time = time
-    #         out = self.update(time, signal_snapshot)
-    #
-    #     return out
+import logging
+import importlib
+
+from rtamt.spec.abstract_specification import AbstractSpecification
+from rtamt.syntax.ast.parser.ltl.specification_parser import LtlAstParserVisitor
+
+from rtamt.exception.exception import RTAMTException
+
+from rtamt.pastifier.ltl.pastifier import LtlPastifier
+from rtamt.interpreter.ltl.online_interpreter import LTLInterpreter
+from rtamt.reset.ltl.reset import LTLReset
+from rtamt.semantics.enumerations.options import *
+
+
+class LTLDiscreteTimeSpecification(AbstractSpecification):
+    """A class used as a container for STL specifications
+
+    Attributes:
+        name : String
+
+        vars : set(String) - set of variable names
+        free_vars : set(String) - set of free variable names
+
+        sampling_period : int - size of the sampling period
+
+
+        var_object_dict : dict(String,AbstractNode) - dictionary that maps variable names to their Node instances
+        modules : dict(String,String) - dictionary that maps module paths to module names
+
+        top : AbstractNode - pointer to the specification parse tree
+
+        online_interpreter : AbstractInterpreter - pointer to the object that implements the monitoring algorithm
+
+        update_counter : int
+        previous_time : float
+        sampling_violation_counter : int
+
+    """
+
+    def __init__(self, semantics=Semantics.STANDARD, language=Language.PYTHON):
+        """Constructor for STL Specification"""
+        super(LTLDiscreteTimeSpecification, self).__init__()
+        self.name = 'LTL Specification'
+
+        self.reseter = LTLReset()
+        self.semantics = semantics
+        self.language = language
+
+        self.in_vars = set()
+        self.out_vars = set()
+
+    def set_var_io_type(self, var_name, var_iotype):
+        if not var_name in self.vars:
+            logging.warning('The variable {} does not exist'.format(var_name))
+        else:
+            if var_iotype == 'input':
+                self.add_input_var(var_name)
+                self.remove_output_var(var_name)
+                self.var_io_dict[var_name] = 'input'
+            elif var_iotype == 'output':
+                self.add_output_var(var_name)
+                self.remove_input_var(var_name)
+                self.var_io_dict[var_name] = 'output'
+            else:
+                self.remove_input_var(var_name)
+                self.remove_output_var(var_name)
+                self.var_io_dict[var_name] = 'undefined'
+
+    def add_input_var(self, input_var):
+        self.in_vars.add(input_var)
+
+    def remove_input_var(self, var):
+        self.in_vars.discard(var)
+
+    def add_output_var(self, output_var):
+        self.out_vars.add(output_var)
+
+    def remove_output_var(self, var):
+        self.out_vars.discard(var)
+
+    def import_module(self, from_name, module_name):
+        try:
+            module = importlib.import_module(from_name)
+            self.modules[module_name] = module
+        except ImportError:
+            raise RTAMTException('The module {} cannot be loaded'.format(from_name))
+
+    def declare_const(self, const_name, const_type, const_val):
+        if const_name in self.vars:
+            raise RTAMTException('Constant {} already declared'.format(const_name))
+
+        self.const_type_dict[const_name] = const_type
+        self.const_val_dict[const_name] = const_val
+        self.vars.add(const_name)
+
+    def declare_var(self, var_name, var_type):
+        if var_name in self.vars:
+            logging.warning(
+                'Variable {} was already declared. It is now overriden with the new declaration.'.format(var_name))
+
+        # Associate to variable name 'var' its type 'type'
+        self.var_type_dict[var_name] = var_type
+
+        # Add variable name 'var' to the set of variables
+        self.add_var(var_name)
+        self.free_vars.add(var_name)
+        instance = self.create_var_from_name(var_name)
+        self.var_object_dict[var_name] = instance
+
+        # Add the default variable topic to var
+        self.var_topic_dict[var_name] = 'rtamt/{}'.format(var_name)
+
+        self.var_io_dict[var_name] = 'output'
+
+    def set_var_topic(self, var_name, var_topic):
+        if not var_name in self.vars:
+            logging.warning(
+                'The variable {0} is not declared. Setting its topic name to {1} is ignored.'.format(var_name,
+                                                                                                     var_topic))
+        else:
+            topic = self.var_topic_dict[var_name]
+            self.var_topic_dict[var_name] = var_topic
+
+    def create_var_from_name(self, var_name):
+        var = None
+        var_type = self.var_type_dict[var_name]
+        if var_type.encode('utf-8') == 'float'.encode('utf-8'):
+            var = float()
+        elif var_type.encode('utf-8') == 'int'.encode('utf-8'):
+            var = int()
+        elif var_type.encode('utf-8') == 'complex'.encode('utf-8'):
+            var = complex()
+        else:
+            try:
+                var_module = self.modules[var_type]
+                class_ = getattr(var_module, var_type)
+                var = class_()
+            except KeyError:
+                raise RTAMTException('The type {} does not seem to be imported.'.format(var_type))
+        return var
+
+    @property
+    def semantics(self):
+        return self.__semantics
+
+    @semantics.setter
+    def semantics(self, semantics):
+        self.__semantics = semantics
+
+    @property
+    def in_vars(self):
+        return self.__in_vars
+
+    @in_vars.setter
+    def in_vars(self, in_vars):
+        self.__in_vars = in_vars
+
+    @property
+    def out_vars(self):
+        return self.__out_vars
+
+    @out_vars.setter
+    def out_vars(self, out_vars):
+        self.__out_vars = out_vars
+
+    # Parses the STL property
+    # string can be either file path containing the STL property
+    # or the textual property itself
+    def parse(self):
+        # Create the visitor for the actual spec nodes
+        parser = LtlAstParserVisitor(self)
+        self.top = parser.parse()
+
+    def pastify(self):
+        # Translate bounded future STL to past STL
+        pastifier = LTLPastifier()
+        self.top.accept(pastifier)
+
+        # evaluate modular sub-specs
+        for key in self.var_subspec_dict:
+            node = self.var_subspec_dict[key]
+            node.accept(pastifier)
+            node = pastifier.pastify(node)
+            self.var_subspec_dict[key] = node
+
+        past = pastifier.pastify(self.top)
+        self.top = past
+
+    def update(self, timestamp, list_inputs):
+        # timestamp - float
+        # inputs - list of [var name, var value] pairs
+        # Example:
+        # update(3.48, [['a', 2.2], ['b', 3.3]])
+
+        if self.online_interpreter == None:
+            self.online_interpreter = LTLInterpreter(self)
+            self.top.accept(self.online_interpreter)
+
+        # update the value of every input variable
+        for inp in list_inputs:
+            var_name = inp[0]
+            var_value = inp[1]
+            self.var_object_dict[var_name] = var_value
+
+        # evaluate modular sub-specs
+        for key in self.var_subspec_dict:
+            node = self.var_subspec_dict[key]
+            out = self.online_interpreter.evaluate(node, [])
+            self.var_object_dict[key] = out
+
+        # The evaluation done wrt the discrete counter (logical time)
+        out = self.online_interpreter.evaluate(self.top, [])
+
+        return out
+
+    def evaluate(self, *args, **kargs):
+        pass
+
+    def reset(self):
+        if self.online_interpreter is not None:
+            self.reseter.node_monitor_dict = self.online_interpreter.node_monitor_dict
+            self.top.accept(self.reseter)
+            self.reseter.reset(self.top)
+            self.update_counter = int(0);
+            self.previous_time = float(0.0);
+            self.sampling_violation_counter = int(0);
+
+    # def offline(self, dataset):
+    #     counter = 0
+    #     prev_signal_length = 0
+    #     signal_length = 0
+    #     out = 0
+    #
+    #     for var_name in dataset:
+    #         signal_length = len(dataset[var_name])
+    #         if counter > 0 and not (signal_length == prev_signal_length):
+    #             raise STLOfflineException('Input signals have different length')
+    #         prev_signal_length = signal_length
+    #         counter = counter + 1
+    #
+    #     for i in range(signal_length):
+    #         signal_snapshot = []
+    #         counter = 0
+    #         prev_time = 0
+    #         for var_name in dataset:
+    #             signal = dataset[var_name]
+    #             sample = signal[i]
+    #             time = sample[0]
+    #             value = sample[1]
+    #             if counter > 0 and not (time == prev_time):
+    #                 raise STLOfflineException('The time indices do not agree')
+    #             signal_snapshot.append((var_name, value))
+    #             counter = counter + 1
+    #             prev_time = time
+    #         out = self.update(time, signal_snapshot)
+    #
+    #     return out
```

### Comparing `rtamt-0.3/tests/python/oper/test_stl_ct_boolean_and_temporal_online.py` & `rtamt-0.3.5/tests/python/oper/test_stl_ct_boolean_and_temporal_online.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,551 +1,551 @@
-import unittest
-from rtamt.operation.stl.dense_time.online.and_operation import AndOperation
-from rtamt.operation.stl.dense_time.online.not_operation import NotOperation
-from rtamt.operation.stl.dense_time.online.or_operation import OrOperation
-from rtamt.operation.stl.dense_time.online.implies_operation import ImpliesOperation
-from rtamt.operation.stl.dense_time.online.iff_operation import IffOperation
-from rtamt.operation.stl.dense_time.online.xor_operation import XorOperation
-from rtamt.operation.stl.dense_time.online.always_operation import AlwaysOperation
-from rtamt.operation.stl.dense_time.online.historically_operation import HistoricallyOperation
-from rtamt.operation.stl.dense_time.online.once_operation import OnceOperation
-from rtamt.operation.stl.dense_time.online.since_operation import SinceOperation
-from rtamt.operation.stl.dense_time.online.once_bounded_operation import OnceBoundedOperation
-from rtamt.operation.stl.dense_time.online.historically_bounded_operation import HistoricallyBoundedOperation
-
-
-class TestSTLBooleanAndTemporalOnline(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestSTLBooleanAndTemporalOnline, self).__init__(*args, **kwargs)
-
-    def test_and(self):
-         oper = AndOperation()
-         in_data_1_1 = [[2, 2], [3.3, 3], [5.7, 4]]
-         in_data_2_1 = [[2.5, 5], [4.7, 6]]
-         out_expected_1 = [[2.5, 2], [3.3, 3]]
-         out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
-
-         self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-         in_data_1_2 = []
-         in_data_2_2 = [[5.7, 1]]
-         out_expected_2 = [[4.7, 3]]
-         out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
-
-         self.assertListEqual(out_expected_2, out_computed_2,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_2, out_computed_2))
-
-         out_expected_final = [[5.7, 1]]
-         out_computed_final = oper.update_final([], [])
-         self.assertListEqual(out_expected_final, out_computed_final,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_final, out_computed_final))
-
-         oper = AndOperation()
-         in_data_1_1 = [[2, 2]]
-         in_data_2_1 = [[2, 1]]
-
-         out_expected_1 = []
-         out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
-
-         self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-         in_data_1_2 = [[3.3, 3]]
-         in_data_2_2 = [[3.3, 5]]
-
-         out_expected_2 = [[2, 1]]
-         out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
-
-         self.assertListEqual(out_expected_2, out_computed_2,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_2, out_computed_2))
-
-         in_data_1_3 = [[4.7, 5]]
-         in_data_2_3 = [[4.7, 2]]
-
-         out_expected_3 = [[3.3, 3]]
-         out_computed_3 = oper.update(in_data_1_3, in_data_2_3)
-
-         self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-         out_expected_final = [[4.7, 2]]
-         out_computed_final = oper.update_final([], [])
-
-         self.assertListEqual(out_expected_final, out_computed_final,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_final, out_computed_final))
-
-         ################################################################################################
-
-         oper = AndOperation()
-         in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
-         in_data_2_1 = [[1.2, 1]]
-         out_expected_1 = []
-         out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
-
-         self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-         in_data_1_2 = []
-         in_data_2_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
-         out_expected_2 = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2]]
-         out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
-
-         self.assertListEqual(out_expected_2, out_computed_2,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_2, out_computed_2))
-
-         in_data_1_3 = [[6.7, 4], [9.9, 5]]
-         in_data_2_3 = [[8.1, 6]]
-         out_expected_3 = [[6.1, 1], [6.7, 3], [7.5, 2]]
-         out_computed_3 = oper.update(in_data_1_3, in_data_2_3)
-
-         self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-
-         out_expected_final = [[8.1, 4]]
-         out_computed_final = oper.update_final([], [])
-
-         self.assertListEqual(out_expected_final, out_computed_final,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_final, out_computed_final))
-
-
-    def test_or(self):
-        oper = OrOperation()
-        in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
-        in_data_2_1 = [[1.2, 1]]
-        out_expected_1 = []
-        out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_1, out_computed_1))
-
-        in_data_1_2 = []
-        in_data_2_2 = [[3.7, 3], [7.5, 2]]
-        out_expected_2 = [[1.2, 2], [3.7, 3]]
-        out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_1_3 = [[6.7, 4], [9.9, 5]]
-        in_data_2_3 = [[8.1, 6]]
-        out_expected_3 = [[6.1, 3], [6.7, 4]]
-        out_computed_3 = oper.update(in_data_1_3, in_data_2_3)
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-        out_expected_final = [[8.1, 6]]
-        out_computed_final = oper.update_final([], [])
-
-        self.assertListEqual(out_expected_final, out_computed_final,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_final, out_computed_final))
-
-
-    def test_iff(self):
-        oper = IffOperation()
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, -1], [4.1, -2], [5, -1], [6.1, -2], [6.7, -1], [7.5, -2]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        out_expected = [[8.1, -2]]
-        out_computed = oper.update_final([], [])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-    def test_xor(self):
-        oper = XorOperation()
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [4.1, 2], [5, 1], [6.1, 2], [6.7, 1], [7.5, 2]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        out_expected = [[8.1, 2]]
-        out_computed = oper.update_final([], [])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_implies(self):
-        oper = ImpliesOperation()
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [3.7, 3], [7.5, 2]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        out_expected = [[8.1, 6]]
-        out_computed = oper.update_final([], [])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-
-    def test_always(self):
-        oper = AlwaysOperation()
-        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
-        out_expected = [[5, 3], [5.3, 1], [5.75, 1]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[6.5, 1], [6.75, 1], [9, 1], [9.25, 1], [10, 1]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_historically(self):
-        oper = HistoricallyOperation()
-        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
-        out_expected = [[5, 3], [5.3, 1], [5.75, 1]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[6.5, 1], [6.75, 1], [9, 1], [9.25, 1], [10, 1]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_once(self):
-        oper = OnceOperation()
-
-        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
-        out_expected = [[5, 3], [5.3, 3], [5.75, 3]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[6.5, 5], [6.75, 6]]
-        out_expected = [[6.5, 5], [6.75, 6]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[9, 6], [9.25, 6], [10, 6]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_once_0_1(self):
-        oper = OnceBoundedOperation(0, 1)
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[5, 3]]
-        out_computed_1 = oper.update(in_data_1)
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                                  "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[5.75, 3], [6.3, 2], [6.5, 5], [6.75, 6]]
-        out_computed_2 = oper.update(in_data_2)
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[9, 6]]
-        out_computed_3 = oper.update(in_data_3)
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-        out_expected_final = [[10, 5], [10.25, 4], [11, 2]]
-        out_computed_final = oper.update_final([])
-
-        self.assertListEqual(out_expected_final, out_computed_final,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_final, out_computed_final))
-
-    def test_once_1_3(self):
-        oper = OnceBoundedOperation(1, 3)
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[6, 3]]
-        out_computed_1 = oper.update(in_data_1)
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                            out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[6.75, 3], [7.5, 5], [7.75, 6]]
-        out_computed_2 = oper.update(in_data_2)
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                            out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[10, 6]]
-        out_computed_3 = oper.update(in_data_3)
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                out_expected_3, out_computed_3))
-
-        out_expected_final = [[11, 6], [12, 5], [12.25, 4], [13, 2]]
-        out_computed_final = oper.update_final([])
-
-        self.assertListEqual(out_expected_final, out_computed_final,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                out_expected_final, out_computed_final))
-
-
-    def test_since(self):
-
-        oper = SinceOperation()
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 3], [7.5, 3]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        out_expected = [[8.1, 4]]
-        out_computed = oper.update_final([], [])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        oper = SinceOperation()
-        in_data_1 = [[1, 2], [4.1, 1]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
-        out_expected = [[1.2, 1], [3.7, 2]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data_1 = [[5, 2], [6.1, 1], [6.7, 4]]
-        in_data_2 = []
-        out_expected = [[4.1, 1], [5, 2], [6.1, 1]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data_1 = [[9.9, 5]]
-        in_data_2 = [[8.1, 6]]
-        out_expected = [[6.7, 3], [7.5, 3]]
-        out_computed = oper.update(in_data_1, in_data_2)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        out_expected = [[8.1, 4]]
-        out_computed = oper.update_final([], [])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_historically_1_2(self):
-        oper = HistoricallyBoundedOperation(1, 2)
-        in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[6, 3], [6.3, 1], [7.75, 2], [8.5, 5], [8.75, 6], [10, 5], [10.25, 4]]
-        out_computed = oper.update(in_data)
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected, out_computed))
-
-        out_expected = [[11, 2]]
-        out_computed = oper.update_final([])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        oper = HistoricallyBoundedOperation(1, 2)
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[6, 3], [6.3, 2]]
-        out_computed_1 = oper.update(in_data_1)
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[6.75, 1], [8.5, 5], [8.75, 6]]
-        out_computed_2 = oper.update(in_data_2)
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[10, 5], [10.25, 4]]
-        out_computed_3 = oper.update(in_data_3)
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-        out_expected_final = [[11, 2]]
-        out_computed_final = oper.update_final([])
-
-        self.assertListEqual(out_expected_final, out_computed_final,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_final, out_computed_final))
-
-    #     in_data = [[0, 1], [0.5, 2], [1, 3], [1.5, 4], [2, 5]]
-    #     out_expected = [[1, 1], [2.5, 2], [3, 3], [3.5, 4], [4, 5]]
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                          "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-    #                          out_expected, out_computed))
-    #
-    #     in_data = [[0, 5], [0.5, 4], [1, 3], [1.5, 2], [2, 1]]
-    #     out_expected = [[1, 5], [1.5, 4], [2, 3], [2.5, 2], [4, 1]]
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                          "Problem with 3rd example:\nExpected output: %s\nComputed output: %s" % (
-    #                          out_expected, out_computed))
-    #
-    #     in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 1], [9, 5], [9.25, 4], [10, 2]]
-    #     out_expected = [[6, 3], [6.3, 1], [11, 4], [12, 2]]
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                           "Problem with 4th example:\nExpected output: %s\nComputed output: %s" % (
-    #                               out_expected, out_computed))
-    #
-    #     in_data = [[6, 2], [8, 1], [8.1, 2], [10, 3]]
-    #     out_expected = [[7, 2], [9, 1], [10.1, 2], [12, 3]]
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                          "Problem with 5th example:\nExpected output: %s\nComputed output: %s" % (
-    #                              out_expected, out_computed))
-    #
-    #     in_data = [[6, 2], [8, 3], [8.1, 2], [10, 3]]
-    #     out_expected = [[7, 2], [12, 3]]
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                          "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-    #                              out_expected, out_computed))
-    #
-    #     in_data = []
-    #     out_expected = []
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                          "Problem with 7th example:\nExpected output: %s\nComputed output: %s" % (
-    #                              out_expected, out_computed))
-    #
-    #     in_data = [[2, 5]]
-    #     out_expected = []
-    #     out_computed = oper.offline(in_data)
-    #
-    #     self.assertListEqual(out_expected, out_computed,
-    #                          "Problem with 8th example:\nExpected output: %s\nComputed output: %s" % (
-    #                              out_expected, out_computed))
-    #
-    #
-    # def test_since_0_1(self):
-    #     oper = SinceBoundedOperation(0, 1)
-    #     in_data_1 = [[0, 3], [2, 4], [4, 6]]
-    #     in_data_2 = [[0, -1], [2, 5], [4, 6]]
-    #     out_expected = [[0, -1], [2, 4]]
-    #     out_computed = oper.offline(in_data_1, in_data_2)
-    #
-    #     # self.assertListEqual(out_expected, out_computed,
-    #     #                      "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-    #     #                          out_expected, out_computed))
-    #
-    def test_not(self):
-         oper = NotOperation()
-         in_data_1 = [[5, 3], [5.3, 1]]
-         in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-         in_data_3 = [[10, 2]]
-
-         out_expected_1 = [[5, -3], [5.3, -1]]
-         out_expected_2 = [[5.75, -2], [6.5, -5], [6.75, -6], [9, -5], [9.25, -4]]
-         out_expected_3 = [[10, -2]]
-         out_expected_final = []
-
-         out_computed_1 = oper.update(in_data_1)
-         out_computed_2 = oper.update(in_data_2)
-         out_computed_3 = oper.update(in_data_3)
-         out_computed_final = oper.update_final([])
-
-
-         self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-         self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-         self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-         self.assertListEqual(out_expected_final, out_computed_final,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_final, out_computed_final))
-
-
-
-if __name__ == '__main__':
+import unittest
+from rtamt.semantics.stl.dense_time.online.and_operation import AndOperation
+from rtamt.semantics.stl.dense_time.online.not_operation import NotOperation
+from rtamt.semantics.stl.dense_time.online.or_operation import OrOperation
+from rtamt.semantics.stl.dense_time.online.implies_operation import ImpliesOperation
+from rtamt.semantics.stl.dense_time.online.iff_operation import IffOperation
+from rtamt.semantics.stl.dense_time.online.xor_operation import XorOperation
+from rtamt.semantics.stl.dense_time.online.always_operation import AlwaysOperation
+from rtamt.semantics.stl.dense_time.online.historically_operation import HistoricallyOperation
+from rtamt.semantics.stl.dense_time.online.once_operation import OnceOperation
+from rtamt.semantics.stl.dense_time.online.since_operation import SinceOperation
+from rtamt.semantics.stl.dense_time.online.once_timed_operation import OnceTimedOperation
+from rtamt.semantics.stl.dense_time.online.historically_timed_operation import HistoricallyTimedOperation
+
+
+class TestSTLBooleanAndTemporalOnline(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestSTLBooleanAndTemporalOnline, self).__init__(*args, **kwargs)
+
+    def test_and(self):
+         oper = AndOperation()
+         in_data_1_1 = [[2, 2], [3.3, 3], [5.7, 4]]
+         in_data_2_1 = [[2.5, 5], [4.7, 6]]
+         out_expected_1 = [[2.5, 2], [3.3, 3]]
+         out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
+
+         self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+         in_data_1_2 = []
+         in_data_2_2 = [[5.7, 1]]
+         out_expected_2 = [[4.7, 3]]
+         out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
+
+         self.assertListEqual(out_expected_2, out_computed_2,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_2, out_computed_2))
+
+         out_expected_final = [[5.7, 1]]
+         out_computed_final = oper.update_final([], [])
+         self.assertListEqual(out_expected_final, out_computed_final,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_final, out_computed_final))
+
+         oper = AndOperation()
+         in_data_1_1 = [[2, 2]]
+         in_data_2_1 = [[2, 1]]
+
+         out_expected_1 = []
+         out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
+
+         self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+         in_data_1_2 = [[3.3, 3]]
+         in_data_2_2 = [[3.3, 5]]
+
+         out_expected_2 = [[2, 1]]
+         out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
+
+         self.assertListEqual(out_expected_2, out_computed_2,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_2, out_computed_2))
+
+         in_data_1_3 = [[4.7, 5]]
+         in_data_2_3 = [[4.7, 2]]
+
+         out_expected_3 = [[3.3, 3]]
+         out_computed_3 = oper.update(in_data_1_3, in_data_2_3)
+
+         self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+         out_expected_final = [[4.7, 2]]
+         out_computed_final = oper.update_final([], [])
+
+         self.assertListEqual(out_expected_final, out_computed_final,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_final, out_computed_final))
+
+         ################################################################################################
+
+         oper = AndOperation()
+         in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
+         in_data_2_1 = [[1.2, 1]]
+         out_expected_1 = []
+         out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
+
+         self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+         in_data_1_2 = []
+         in_data_2_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
+         out_expected_2 = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2]]
+         out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
+
+         self.assertListEqual(out_expected_2, out_computed_2,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_2, out_computed_2))
+
+         in_data_1_3 = [[6.7, 4], [9.9, 5]]
+         in_data_2_3 = [[8.1, 6]]
+         out_expected_3 = [[6.1, 1], [6.7, 3], [7.5, 2]]
+         out_computed_3 = oper.update(in_data_1_3, in_data_2_3)
+
+         self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+
+         out_expected_final = [[8.1, 4]]
+         out_computed_final = oper.update_final([], [])
+
+         self.assertListEqual(out_expected_final, out_computed_final,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_final, out_computed_final))
+
+
+    def test_or(self):
+        oper = OrOperation()
+        in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
+        in_data_2_1 = [[1.2, 1]]
+        out_expected_1 = []
+        out_computed_1 = oper.update(in_data_1_1, in_data_2_1)
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_1, out_computed_1))
+
+        in_data_1_2 = []
+        in_data_2_2 = [[3.7, 3], [7.5, 2]]
+        out_expected_2 = [[1.2, 2], [3.7, 3]]
+        out_computed_2 = oper.update(in_data_1_2, in_data_2_2)
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_1_3 = [[6.7, 4], [9.9, 5]]
+        in_data_2_3 = [[8.1, 6]]
+        out_expected_3 = [[6.1, 3], [6.7, 4]]
+        out_computed_3 = oper.update(in_data_1_3, in_data_2_3)
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+        out_expected_final = [[8.1, 6]]
+        out_computed_final = oper.update_final([], [])
+
+        self.assertListEqual(out_expected_final, out_computed_final,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_final, out_computed_final))
+
+
+    def test_iff(self):
+        oper = IffOperation()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, -1], [4.1, -2], [5, -1], [6.1, -2], [6.7, -1], [7.5, -2]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        out_expected = [[8.1, -2]]
+        out_computed = oper.update_final([], [])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+    def test_xor(self):
+        oper = XorOperation()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [4.1, 2], [5, 1], [6.1, 2], [6.7, 1], [7.5, 2]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        out_expected = [[8.1, 2]]
+        out_computed = oper.update_final([], [])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_implies(self):
+        oper = ImpliesOperation()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [3.7, 3], [7.5, 2]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        out_expected = [[8.1, 6]]
+        out_computed = oper.update_final([], [])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+
+    def test_always(self):
+        oper = AlwaysOperation()
+        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
+        out_expected = [[5, 3], [5.3, 1], [5.75, 1]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[6.5, 1], [6.75, 1], [9, 1], [9.25, 1], [10, 1]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_historically(self):
+        oper = HistoricallyOperation()
+        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
+        out_expected = [[5, 3], [5.3, 1], [5.75, 1]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[6.5, 1], [6.75, 1], [9, 1], [9.25, 1], [10, 1]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_once(self):
+        oper = OnceOperation()
+
+        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
+        out_expected = [[5, 3], [5.3, 3], [5.75, 3]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[6.5, 5], [6.75, 6]]
+        out_expected = [[6.5, 5], [6.75, 6]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[9, 6], [9.25, 6], [10, 6]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_once_0_1(self):
+        oper = OnceTimedOperation(0, 1)
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[5, 3]]
+        out_computed_1 = oper.update(in_data_1)
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                                  "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[5.75, 3], [6.3, 2], [6.5, 5], [6.75, 6]]
+        out_computed_2 = oper.update(in_data_2)
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[9, 6]]
+        out_computed_3 = oper.update(in_data_3)
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+        out_expected_final = [[10, 5], [10.25, 4], [11, 2]]
+        out_computed_final = oper.update_final([])
+
+        self.assertListEqual(out_expected_final, out_computed_final,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_final, out_computed_final))
+
+    def test_once_1_3(self):
+        oper = OnceTimedOperation(1, 3)
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[6, 3]]
+        out_computed_1 = oper.update(in_data_1)
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                            out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[6.75, 3], [7.5, 5], [7.75, 6]]
+        out_computed_2 = oper.update(in_data_2)
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                            out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[10, 6]]
+        out_computed_3 = oper.update(in_data_3)
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                out_expected_3, out_computed_3))
+
+        out_expected_final = [[11, 6], [12, 5], [12.25, 4], [13, 2]]
+        out_computed_final = oper.update_final([])
+
+        self.assertListEqual(out_expected_final, out_computed_final,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                out_expected_final, out_computed_final))
+
+
+    def test_since(self):
+
+        oper = SinceOperation()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 3], [7.5, 3]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        out_expected = [[8.1, 4]]
+        out_computed = oper.update_final([], [])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        oper = SinceOperation()
+        in_data_1 = [[1, 2], [4.1, 1]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
+        out_expected = [[1.2, 1], [3.7, 2]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data_1 = [[5, 2], [6.1, 1], [6.7, 4]]
+        in_data_2 = []
+        out_expected = [[4.1, 1], [5, 2], [6.1, 1]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data_1 = [[9.9, 5]]
+        in_data_2 = [[8.1, 6]]
+        out_expected = [[6.7, 3], [7.5, 3]]
+        out_computed = oper.update(in_data_1, in_data_2)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        out_expected = [[8.1, 4]]
+        out_computed = oper.update_final([], [])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_historically_1_2(self):
+        oper = HistoricallyTimedOperation(1, 2)
+        in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[6, 3], [6.3, 1], [7.75, 2], [8.5, 5], [8.75, 6], [10, 5], [10.25, 4]]
+        out_computed = oper.update(in_data)
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected, out_computed))
+
+        out_expected = [[11, 2]]
+        out_computed = oper.update_final([])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        oper = HistoricallyTimedOperation(1, 2)
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[6, 3], [6.3, 2]]
+        out_computed_1 = oper.update(in_data_1)
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[6.75, 1], [8.5, 5], [8.75, 6]]
+        out_computed_2 = oper.update(in_data_2)
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[10, 5], [10.25, 4]]
+        out_computed_3 = oper.update(in_data_3)
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+        out_expected_final = [[11, 2]]
+        out_computed_final = oper.update_final([])
+
+        self.assertListEqual(out_expected_final, out_computed_final,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_final, out_computed_final))
+
+    #     in_data = [[0, 1], [0.5, 2], [1, 3], [1.5, 4], [2, 5]]
+    #     out_expected = [[1, 1], [2.5, 2], [3, 3], [3.5, 4], [4, 5]]
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                          "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+    #                          out_expected, out_computed))
+    #
+    #     in_data = [[0, 5], [0.5, 4], [1, 3], [1.5, 2], [2, 1]]
+    #     out_expected = [[1, 5], [1.5, 4], [2, 3], [2.5, 2], [4, 1]]
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                          "Problem with 3rd example:\nExpected output: %s\nComputed output: %s" % (
+    #                          out_expected, out_computed))
+    #
+    #     in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 1], [9, 5], [9.25, 4], [10, 2]]
+    #     out_expected = [[6, 3], [6.3, 1], [11, 4], [12, 2]]
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                           "Problem with 4th example:\nExpected output: %s\nComputed output: %s" % (
+    #                               out_expected, out_computed))
+    #
+    #     in_data = [[6, 2], [8, 1], [8.1, 2], [10, 3]]
+    #     out_expected = [[7, 2], [9, 1], [10.1, 2], [12, 3]]
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                          "Problem with 5th example:\nExpected output: %s\nComputed output: %s" % (
+    #                              out_expected, out_computed))
+    #
+    #     in_data = [[6, 2], [8, 3], [8.1, 2], [10, 3]]
+    #     out_expected = [[7, 2], [12, 3]]
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                          "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+    #                              out_expected, out_computed))
+    #
+    #     in_data = []
+    #     out_expected = []
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                          "Problem with 7th example:\nExpected output: %s\nComputed output: %s" % (
+    #                              out_expected, out_computed))
+    #
+    #     in_data = [[2, 5]]
+    #     out_expected = []
+    #     out_computed = oper.offline(in_data)
+    #
+    #     self.assertListEqual(out_expected, out_computed,
+    #                          "Problem with 8th example:\nExpected output: %s\nComputed output: %s" % (
+    #                              out_expected, out_computed))
+    #
+    #
+    # def test_since_0_1(self):
+    #     oper = SinceBoundedOperation(0, 1)
+    #     in_data_1 = [[0, 3], [2, 4], [4, 6]]
+    #     in_data_2 = [[0, -1], [2, 5], [4, 6]]
+    #     out_expected = [[0, -1], [2, 4]]
+    #     out_computed = oper.offline(in_data_1, in_data_2)
+    #
+    #     # self.assertListEqual(out_expected, out_computed,
+    #     #                      "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+    #     #                          out_expected, out_computed))
+    #
+    def test_not(self):
+         oper = NotOperation()
+         in_data_1 = [[5, 3], [5.3, 1]]
+         in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+         in_data_3 = [[10, 2]]
+
+         out_expected_1 = [[5, -3], [5.3, -1]]
+         out_expected_2 = [[5.75, -2], [6.5, -5], [6.75, -6], [9, -5], [9.25, -4]]
+         out_expected_3 = [[10, -2]]
+         out_expected_final = []
+
+         out_computed_1 = oper.update(in_data_1)
+         out_computed_2 = oper.update(in_data_2)
+         out_computed_3 = oper.update(in_data_3)
+         out_computed_final = oper.update_final([])
+
+
+         self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+         self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+         self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+         self.assertListEqual(out_expected_final, out_computed_final,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_final, out_computed_final))
+
+
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/oper/test_stl_discrete_time_online_evaluation.py` & `rtamt-0.3.5/tests/python/semantics/test_stl_discrete_time_online_update.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,579 +1,606 @@
-import unittest
-import math
-from rtamt.operation.stl.discrete_time.online.constant_operation import ConstantOperation
-from rtamt.operation.stl.discrete_time.online.and_operation import AndOperation
-from rtamt.operation.stl.discrete_time.online.rise_operation import RiseOperation
-from rtamt.operation.stl.discrete_time.online.fall_operation import FallOperation
-from rtamt.operation.stl.discrete_time.online.predicate_operation import PredicateOperation
-from rtamt.operation.stl.discrete_time.online.not_operation import NotOperation
-from rtamt.operation.stl.discrete_time.online.or_operation import OrOperation
-from rtamt.operation.stl.discrete_time.online.implies_operation import ImpliesOperation
-from rtamt.operation.stl.discrete_time.online.iff_operation import IffOperation
-from rtamt.operation.stl.discrete_time.online.xor_operation import XorOperation
-from rtamt.operation.stl.discrete_time.online.always_operation import AlwaysOperation
-from rtamt.operation.stl.discrete_time.online.eventually_operation import EventuallyOperation
-from rtamt.operation.stl.discrete_time.online.historically_operation import HistoricallyOperation
-from rtamt.operation.stl.discrete_time.online.once_operation import OnceOperation
-from rtamt.operation.stl.discrete_time.online.since_operation import SinceOperation
-from rtamt.operation.stl.discrete_time.online.once_bounded_operation import OnceBoundedOperation
-from rtamt.operation.stl.discrete_time.online.historically_bounded_operation import HistoricallyBoundedOperation
-from rtamt.operation.stl.discrete_time.online.since_bounded_operation import SinceBoundedOperation
-from rtamt.operation.stl.discrete_time.online.precedes_bounded_operation import PrecedesBoundedOperation
-from rtamt.operation.arithmetic.discrete_time.online.subtraction_operation import SubtractionOperation
-from rtamt.operation.arithmetic.discrete_time.online.addition_operation import AdditionOperation
-from rtamt.operation.arithmetic.discrete_time.online.multiplication_operation import MultiplicationOperation
-from rtamt.operation.arithmetic.discrete_time.online.division_operation import DivisionOperation
-from rtamt.operation.arithmetic.discrete_time.online.abs_operation import AbsOperation
-from rtamt.operation.arithmetic.discrete_time.online.sqrt_operation import SqrtOperation
-from rtamt.operation.arithmetic.discrete_time.online.exp_operation import ExpOperation
-from rtamt.operation.arithmetic.discrete_time.online.pow_operation import PowOperation
-from rtamt.operation.stl.discrete_time.online.previous_operation import PreviousOperation
-from rtamt.enumerations.comp_op import StlComparisonOperator
-
-class TestSTLEvaluation(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestSTLEvaluation, self).__init__(*args, **kwargs)
-        self.left1 = 100
-        self.right1 = 20
-
-        self.left2 = -1
-        self.right2 = -2
-
-        self.left3 = -2
-        self.right3 = 10
-
-        self.left4 = 5
-        self.right4 = 4
-
-        self.left5 = -1
-        self.right5 = -1
-
-    def test_constant(self):
-        oper = ConstantOperation(5)
-
-        out1 = oper.update()
-        out2 = oper.update()
-
-        self.assertEqual(out1, 5, "input 1")
-        self.assertEqual(out2, 5, "input 2")
-
-
-    def test_addition(self):
-        oper = AdditionOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 120, "input 1")
-        self.assertEqual(out2, -3, "input 2")
-        self.assertEqual(out3, 8, "input 3")
-        self.assertEqual(out4, 9, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_subtraction(self):
-        oper = SubtractionOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_multiplication(self):
-        oper = MultiplicationOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 2000, "input 1")
-        self.assertEqual(out2, 2, "input 2")
-        self.assertEqual(out3, -20, "input 3")
-        self.assertEqual(out4, 20, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_division(self):
-        oper = DivisionOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 100 / 20, "input 1")
-        self.assertEqual(out2, -1 / -2, "input 2")
-        self.assertEqual(out3, -2 / 10, "input 3")
-        self.assertEqual(out4, 5 / 4, "input 4")
-        self.assertEqual(out5, -1 / -1, "input 5")
-
-    def test_abs(self):
-        oper = AbsOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 2, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_sqrt_without_negative(self):
-        oper = SqrtOperation()
-
-        out1 = oper.update(4)
-        out2 = oper.update(17.3)
-        out3 = oper.update(6)
-        out4 = oper.update(2)
-        out5 = oper.update(0.0001)
-
-        self.assertEqual(out1, math.sqrt(4), "input 1")
-        self.assertEqual(out2, math.sqrt(17.3), "input 2")
-        self.assertEqual(out3, math.sqrt(6), "input 3")
-        self.assertEqual(out4, math.sqrt(2), "input 4")
-        self.assertEqual(out5, math.sqrt(0.0001), "input 5")
-
-    def test_sqrt_with_negative(self):
-        oper = SqrtOperation()
-
-        self.assertRaises(Exception, oper.update, -4)
-
-    def test_exp(self):
-        oper = ExpOperation()
-
-        out1 = oper.update(4)
-        out2 = oper.update(17.3)
-        out3 = oper.update(6)
-        out4 = oper.update(2)
-        out5 = oper.update(0.0001)
-
-        self.assertEqual(out1, math.exp(4), "input 1")
-        self.assertEqual(out2, math.exp(17.3), "input 2")
-        self.assertEqual(out3, math.exp(6), "input 3")
-        self.assertEqual(out4, math.exp(2), "input 4")
-        self.assertEqual(out5, math.exp(0.0001), "input 5")
-
-    def test_pow(self):
-        oper = PowOperation()
-
-        out1 = oper.update(4, 1)
-        out2 = oper.update(17.3, 0.3)
-        out3 = oper.update(6, 1.2)
-        out4 = oper.update(2, 2)
-        out5 = oper.update(0.0001, 3)
-
-        self.assertEqual(out1, math.pow(4, 1), "input 1")
-        self.assertEqual(out2, math.pow(17.3, 0.3), "input 2")
-        self.assertEqual(out3, math.pow(6, 1.2), "input 3")
-        self.assertEqual(out4, math.pow(2, 2), "input 4")
-        self.assertEqual(out5, math.pow(0.0001, 3), "input 5")
-
-    def test_previous(self):
-        oper = PreviousOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_and(self):
-        oper = AndOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -2, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_or(self):
-        oper = OrOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_iff(self):
-        oper = IffOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_xor(self):
-        oper = XorOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_implies(self):
-        oper = ImpliesOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_always(self):
-        oper = AlwaysOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_historically(self):
-        oper = HistoricallyOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_once(self):
-        oper = OnceOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, 100, "input 3")
-        self.assertEqual(out4, 100, "input 4")
-        self.assertEqual(out5, 100, "input 5")
-
-    def test_eventually(self):
-        oper = EventuallyOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, 100, "input 3")
-        self.assertEqual(out4, 100, "input 4")
-        self.assertEqual(out5, 100, "input 5")
-
-    def test_since(self):
-        oper = SinceOperation()
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_once_0_1(self):
-        oper = OnceBoundedOperation(0,1)
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_once_1_2(self):
-        oper = OnceBoundedOperation(1,2)
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, -float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, 100, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_historically_0_1(self):
-        oper = HistoricallyBoundedOperation(0,1)
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_historically_1_2(self):
-        oper = HistoricallyBoundedOperation(1,2)
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_since_0_1(self):
-        oper = SinceBoundedOperation(0,1)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_precedes_1_2(self):
-        oper = PrecedesBoundedOperation(1, 2)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, 20, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_not(self):
-        oper = NotOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, -100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 2, "input 3")
-        self.assertEqual(out4, -5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_rise(self):
-        oper = RiseOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -100, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 2, "input 4")
-        self.assertEqual(out5, -5, "input 5")
-
-    def test_fall(self):
-        oper = FallOperation()
-
-        out1 = oper.update(self.left1)
-        out2 = oper.update(self.left2)
-        out3 = oper.update(self.left3)
-        out4 = oper.update(self.left4)
-        out5 = oper.update(self.left5)
-
-        self.assertEqual(out1, -100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-
-    def test_predicate_leq(self):
-        oper = PredicateOperation(StlComparisonOperator.LEQ)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_less(self):
-        oper = PredicateOperation(StlComparisonOperator.LESS)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_geq(self):
-        oper = PredicateOperation(StlComparisonOperator.GEQ)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_greater(self):
-        oper = PredicateOperation(StlComparisonOperator.GREATER)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_eq(self):
-        oper = PredicateOperation(StlComparisonOperator.EQUAL)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_neq(self):
-        oper = PredicateOperation(StlComparisonOperator.NEQ)
-
-        out1 = oper.update(self.left1, self.right1)
-        out2 = oper.update(self.left2, self.right2)
-        out3 = oper.update(self.left3, self.right3)
-        out4 = oper.update(self.left4, self.right4)
-        out5 = oper.update(self.left5, self.right5)
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-if __name__ == '__main__':
+import unittest
+import math
+
+from rtamt.syntax.ast.parser.stl.specification_parser import StlAst
+from rtamt.semantics.stl.discrete_time.online.constant_operation import ConstantOperation
+from rtamt.semantics.stl.discrete_time.online.and_operation import AndOperation
+from rtamt.semantics.stl.discrete_time.online.interpreter import StlDiscreteTimeOnlineInterpreter
+from rtamt.semantics.stl.discrete_time.online.rise_operation import RiseOperation
+from rtamt.semantics.stl.discrete_time.online.fall_operation import FallOperation
+from rtamt.semantics.stl.discrete_time.online.predicate_operation import PredicateOperation
+from rtamt.semantics.stl.discrete_time.online.not_operation import NotOperation
+from rtamt.semantics.stl.discrete_time.online.or_operation import OrOperation
+from rtamt.semantics.stl.discrete_time.online.implies_operation import ImpliesOperation
+from rtamt.semantics.stl.discrete_time.online.iff_operation import IffOperation
+from rtamt.semantics.stl.discrete_time.online.xor_operation import XorOperation
+from rtamt.semantics.stl.discrete_time.online.always_operation import AlwaysOperation
+from rtamt.semantics.stl.discrete_time.online.eventually_operation import EventuallyOperation
+from rtamt.semantics.stl.discrete_time.online.historically_operation import HistoricallyOperation
+from rtamt.semantics.stl.discrete_time.online.once_operation import OnceOperation
+from rtamt.semantics.stl.discrete_time.online.since_operation import SinceOperation
+from rtamt.semantics.stl.discrete_time.online.once_timed_operation import OnceTimedOperation
+from rtamt.semantics.stl.discrete_time.online.historically_timed_operation import HistoricallyTimedOperation
+from rtamt.semantics.stl.discrete_time.online.since_timed_operation import SinceTimedOperation
+from rtamt.semantics.stl.discrete_time.online.precedes_timed_operation import PrecedesTimedOperation
+from rtamt.semantics.arithmetic.discrete_time.online.subtraction_operation import SubtractionOperation
+from rtamt.semantics.arithmetic.discrete_time.online.addition_operation import AdditionOperation
+from rtamt.semantics.arithmetic.discrete_time.online.multiplication_operation import MultiplicationOperation
+from rtamt.semantics.arithmetic.discrete_time.online.division_operation import DivisionOperation
+from rtamt.semantics.arithmetic.discrete_time.online.abs_operation import AbsOperation
+from rtamt.semantics.arithmetic.discrete_time.online.sqrt_operation import SqrtOperation
+from rtamt.semantics.arithmetic.discrete_time.online.exp_operation import ExpOperation
+from rtamt.semantics.arithmetic.discrete_time.online.pow_operation import PowOperation
+from rtamt.semantics.stl.discrete_time.online.previous_operation import PreviousOperation
+from rtamt.semantics.enumerations.comp_op import StlComparisonOperator
+
+class TestSTLEvaluation(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestSTLEvaluation, self).__init__(*args, **kwargs)
+        self.left1 = 100
+        self.right1 = 20
+
+        self.left2 = -1
+        self.right2 = -2
+
+        self.left3 = -2
+        self.right3 = 10
+
+        self.left4 = 5
+        self.right4 = 4
+
+        self.left5 = -1
+        self.right5 = -1
+
+    def test_constant(self):
+        oper = ConstantOperation(5)
+
+        out1 = oper.update()
+        out2 = oper.update()
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+
+    def test_addition(self):
+        ast = StlAst()
+        ast.declare_var('a', 'float')
+        ast.declare_var('b', 'float')
+        ast.spec = 'a + b'
+        ast.parse()
+        interpreter = StlDiscreteTimeOnlineInterpreter()
+        interpreter.set_ast(ast)
+
+        in1 = [['a', self.left1], ['b', self.right1]]
+        in2 = [['a', self.left2], ['b', self.right2]]
+        in3 = [['a', self.left3], ['b', self.right3]]
+        in4 = [['a', self.left4], ['b', self.right4]]
+        in5 = [['a', self.left5], ['b', self.right5]]
+
+        out1 = interpreter.update(0, in1)
+        out2 = interpreter.update(1, in2)
+        out3 = interpreter.update(2, in3)
+        out4 = interpreter.update(3, in4)
+        out5 = interpreter.update(4, in5)
+
+        self.assertEqual(out1, 120, "input 1")
+        self.assertEqual(out2, -3, "input 2")
+        self.assertEqual(out3, 8, "input 3")
+        self.assertEqual(out4, 9, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_subtraction(self):
+        ast = StlAst()
+        ast.declare_var('a', 'float')
+        ast.declare_var('b', 'float')
+        ast.spec = 'a - b'
+        ast.parse()
+        interpreter = StlDiscreteTimeOnlineInterpreter()
+        interpreter.set_ast(ast)
+
+        in1 = [['a', self.left1], ['b', self.right1]]
+        in2 = [['a', self.left2], ['b', self.right2]]
+        in3 = [['a', self.left3], ['b', self.right3]]
+        in4 = [['a', self.left4], ['b', self.right4]]
+        in5 = [['a', self.left5], ['b', self.right5]]
+
+        out1 = interpreter.update(0, in1)
+        out2 = interpreter.update(1, in2)
+        out3 = interpreter.update(2, in3)
+        out4 = interpreter.update(3, in4)
+        out5 = interpreter.update(4, in5)
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_multiplication(self):
+        oper = MultiplicationOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 2000, "input 1")
+        self.assertEqual(out2, 2, "input 2")
+        self.assertEqual(out3, -20, "input 3")
+        self.assertEqual(out4, 20, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_division(self):
+        oper = DivisionOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 100 / 20, "input 1")
+        self.assertEqual(out2, -1 / -2, "input 2")
+        self.assertEqual(out3, -2 / 10, "input 3")
+        self.assertEqual(out4, 5 / 4, "input 4")
+        self.assertEqual(out5, -1 / -1, "input 5")
+
+    def test_abs(self):
+        oper = AbsOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_sqrt_without_negative(self):
+        oper = SqrtOperation()
+
+        out1 = oper.update(4)
+        out2 = oper.update(17.3)
+        out3 = oper.update(6)
+        out4 = oper.update(2)
+        out5 = oper.update(0.0001)
+
+        self.assertEqual(out1, math.sqrt(4), "input 1")
+        self.assertEqual(out2, math.sqrt(17.3), "input 2")
+        self.assertEqual(out3, math.sqrt(6), "input 3")
+        self.assertEqual(out4, math.sqrt(2), "input 4")
+        self.assertEqual(out5, math.sqrt(0.0001), "input 5")
+
+    def test_sqrt_with_negative(self):
+        oper = SqrtOperation()
+
+        self.assertRaises(Exception, oper.update, -4)
+
+    def test_exp(self):
+        oper = ExpOperation()
+
+        out1 = oper.update(4)
+        out2 = oper.update(17.3)
+        out3 = oper.update(6)
+        out4 = oper.update(2)
+        out5 = oper.update(0.0001)
+
+        self.assertEqual(out1, math.exp(4), "input 1")
+        self.assertEqual(out2, math.exp(17.3), "input 2")
+        self.assertEqual(out3, math.exp(6), "input 3")
+        self.assertEqual(out4, math.exp(2), "input 4")
+        self.assertEqual(out5, math.exp(0.0001), "input 5")
+
+    def test_pow(self):
+        oper = PowOperation()
+
+        out1 = oper.update(4, 1)
+        out2 = oper.update(17.3, 0.3)
+        out3 = oper.update(6, 1.2)
+        out4 = oper.update(2, 2)
+        out5 = oper.update(0.0001, 3)
+
+        self.assertEqual(out1, math.pow(4, 1), "input 1")
+        self.assertEqual(out2, math.pow(17.3, 0.3), "input 2")
+        self.assertEqual(out3, math.pow(6, 1.2), "input 3")
+        self.assertEqual(out4, math.pow(2, 2), "input 4")
+        self.assertEqual(out5, math.pow(0.0001, 3), "input 5")
+
+    def test_previous(self):
+        oper = PreviousOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_and(self):
+        oper = AndOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -2, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_or(self):
+        oper = OrOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_iff(self):
+        oper = IffOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_xor(self):
+        oper = XorOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_implies(self):
+        oper = ImpliesOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_always(self):
+        oper = AlwaysOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_historically(self):
+        oper = HistoricallyOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_once(self):
+        oper = OnceOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, 100, "input 4")
+        self.assertEqual(out5, 100, "input 5")
+
+    def test_eventually(self):
+        oper = EventuallyOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, 100, "input 4")
+        self.assertEqual(out5, 100, "input 5")
+
+    def test_since(self):
+        oper = SinceOperation()
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_once_0_1(self):
+        oper = OnceTimedOperation(0,1)
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_once_1_2(self):
+        oper = OnceTimedOperation(1,2)
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, -float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_historically_0_1(self):
+        oper = HistoricallyTimedOperation(0,1)
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_historically_1_2(self):
+        oper = HistoricallyTimedOperation(1,2)
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_since_0_1(self):
+        oper = SinceTimedOperation(0,1)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_precedes_1_2(self):
+        oper = PrecedesTimedOperation(1, 2)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 20, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_not(self):
+        oper = NotOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_rise(self):
+        oper = RiseOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -100, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 2, "input 4")
+        self.assertEqual(out5, -5, "input 5")
+
+    def test_fall(self):
+        oper = FallOperation()
+
+        out1 = oper.update(self.left1)
+        out2 = oper.update(self.left2)
+        out3 = oper.update(self.left3)
+        out4 = oper.update(self.left4)
+        out5 = oper.update(self.left5)
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+
+    def test_predicate_leq(self):
+        oper = PredicateOperation(StlComparisonOperator.LEQ)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_less(self):
+        oper = PredicateOperation(StlComparisonOperator.LESS)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_geq(self):
+        oper = PredicateOperation(StlComparisonOperator.GEQ)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_greater(self):
+        oper = PredicateOperation(StlComparisonOperator.GREATER)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_eq(self):
+        oper = PredicateOperation(StlComparisonOperator.EQUAL)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_neq(self):
+        oper = PredicateOperation(StlComparisonOperator.NEQ)
+
+        out1 = oper.update(self.left1, self.right1)
+        out2 = oper.update(self.left2, self.right2)
+        out3 = oper.update(self.left3, self.right3)
+        out4 = oper.update(self.left4, self.right4)
+        out5 = oper.update(self.left5, self.right5)
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_ia_stl_spec_dense_time_online_evaluation.py` & `rtamt-0.3.5/tests/python/api/test_iastl_dense_time_online_specification.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,86 +1,86 @@
-import unittest
-import rtamt
-
-class TestIASTLSpecDenseTimeOnlineEvaluation(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestIASTLSpecDenseTimeOnlineEvaluation, self).__init__(*args, **kwargs)
-
-    def test_output_robustness(self):
-        spec = rtamt.STLDenseTimeSpecification(semantics=rtamt.Semantics.OUTPUT_ROBUSTNESS);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'input')
-        spec.set_var_io_type('gnt', 'output')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
-        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
-
-        out = spec.update(['req', left], ['gnt', right])
-        expected = [[0, 20], [1, float("inf")]]
-
-        self.assertEqual(out, expected, "output robustness")
-
-    def test_input_vacuity(self):
-        spec = rtamt.STLDenseTimeSpecification(semantics=rtamt.Semantics.INPUT_VACUITY);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'input')
-        spec.set_var_io_type('gnt', 'output')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
-        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
-
-        out = spec.update(['req', left], ['gnt', right])
-        expected = [[0, 0], [1, 4], [2, 5]]
-
-        self.assertEqual(out, expected, "input vacuity")
-
-    def test_input_robustness(self):
-        spec = rtamt.STLDenseTimeSpecification(semantics=rtamt.Semantics.INPUT_ROBUSTNESS);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'output')
-        spec.set_var_io_type('gnt', 'input')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
-        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
-
-        out = spec.update(['req', left], ['gnt', right])
-        expected = [[0, 20], [1, float("inf")]]
-
-        self.assertEqual(out, expected, "input robustness")
-
-    def test_output_vacuity(self):
-        spec = rtamt.STLDenseTimeSpecification(semantics=rtamt.Semantics.OUTPUT_VACUITY);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'output')
-        spec.set_var_io_type('gnt', 'input')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
-        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
-
-        out = spec.update(['req', left], ['gnt', right])
-        expected = [[0, 0], [1, 4], [2, 5]]
-
-        self.assertEqual(out, expected, "output vacuity")
-
-if __name__ == '__main__':
+import unittest
+import rtamt
+
+class TestIastlDenseTimeOnlineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestIastlDenseTimeOnlineSpecification, self).__init__(*args, **kwargs)
+
+    def test_output_robustness(self):
+        spec = rtamt.StlDenseTimeSpecification(semantics=rtamt.Semantics.OUTPUT_ROBUSTNESS)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'input')
+        spec.set_var_io_type('gnt', 'output')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
+        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
+
+        out = spec.update(['req', left], ['gnt', right])
+        expected = [[0, 20], [1, float("inf")]]
+
+        self.assertEqual(out, expected, "output robustness")
+
+    def test_input_vacuity(self):
+        spec = rtamt.StlDenseTimeSpecification(semantics=rtamt.Semantics.INPUT_VACUITY)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'input')
+        spec.set_var_io_type('gnt', 'output')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
+        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
+
+        out = spec.update(['req', left], ['gnt', right])
+        expected = [[0, 0], [1, 4], [2, 5]]
+
+        self.assertEqual(out, expected, "input vacuity")
+
+    def test_input_robustness(self):
+        spec = rtamt.StlDenseTimeSpecification(semantics=rtamt.Semantics.INPUT_ROBUSTNESS)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'output')
+        spec.set_var_io_type('gnt', 'input')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
+        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
+
+        out = spec.update(['req', left], ['gnt', right])
+        expected = [[0, 20], [1, float("inf")]]
+
+        self.assertEqual(out, expected, "input robustness")
+
+    def test_output_vacuity(self):
+        spec = rtamt.StlDenseTimeSpecification(semantics=rtamt.Semantics.OUTPUT_VACUITY)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'output')
+        spec.set_var_io_type('gnt', 'input')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        left = [[0, 100], [1, -1], [2, -2], [3, 5], [4, -1]]
+        right = [[0, 20], [1, -2], [2, 10], [3, 4], [4, -1]]
+
+        out = spec.update(['req', left], ['gnt', right])
+        expected = [[0, 0], [1, 4], [2, 5]]
+
+        self.assertEqual(out, expected, "output vacuity")
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_ia_stl_spec_discrete_time_offline_evaluation.py` & `rtamt-0.3.5/tests/python/api/test_iastl_discrete_time_offline_specification.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,79 +1,79 @@
-import unittest
-import rtamt
-
-class TestIASTLSpecDiscreteTimeOfflineEvaluation(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestIASTLSpecDiscreteTimeOfflineEvaluation, self).__init__(*args, **kwargs)
-        self.dataset = {
-            'time': [0, 1, 2, 3, 4],
-            'req': [100, -1, -2, 5, -1],
-            'gnt': [20, -2, 10, 4, -1]
-        }
-
-    def test_output_robustness(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_ROBUSTNESS);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'input')
-        spec.set_var_io_type('gnt', 'output')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out = spec.evaluate(self.dataset)
-        expected = [[0, 20], [1, float("inf")], [2, float("inf")], [3, 4], [4, float("inf")]]
-
-        self.assertListEqual(out, expected, "output robustness")
-
-    def test_input_vacuity(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_VACUITY);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'input')
-        spec.set_var_io_type('gnt', 'output')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out = spec.evaluate(self.dataset)
-        expected = [[0, 0], [1, 4], [2, 5], [3, 0], [4, 4]]
-
-        self.assertListEqual(out, expected, "input vacuity")
-
-    def test_input_robustness(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_ROBUSTNESS);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'output')
-        spec.set_var_io_type('gnt', 'input')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out = spec.evaluate(self.dataset)
-        expected = [[0, 20], [1, float("inf")], [2, float("inf")], [3, 4], [4, float("inf")]]
-
-        self.assertListEqual(out, expected, "input robustness")
-
-    def test_output_vacuity(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_VACUITY);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'output')
-        spec.set_var_io_type('gnt', 'input')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out = spec.evaluate(self.dataset)
-        expected = [[0, 0], [1, 4], [2, 5], [3, 0], [4, 4]]
-
-        self.assertListEqual(out, expected, "output vacuity")
-
-if __name__ == '__main__':
+import unittest
+import rtamt
+
+class TestIastlDiscreteTimeOfflineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestIastlDiscreteTimeOfflineSpecification, self).__init__(*args, **kwargs)
+        self.dataset = {
+            'time': [0, 1, 2, 3, 4],
+            'req': [100, -1, -2, 5, -1],
+            'gnt': [20, -2, 10, 4, -1]
+        }
+
+    def test_output_robustness(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_ROBUSTNESS)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'input')
+        spec.set_var_io_type('gnt', 'output')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out = spec.evaluate(self.dataset)
+        expected = [[0, 20], [1, float("inf")], [2, float("inf")], [3, 4], [4, float("inf")]]
+
+        self.assertListEqual(out, expected, "output robustness")
+
+    def test_input_vacuity(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_VACUITY)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'input')
+        spec.set_var_io_type('gnt', 'output')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out = spec.evaluate(self.dataset)
+        expected = [[0, 0], [1, 4], [2, 5], [3, 0], [4, 4]]
+
+        self.assertListEqual(out, expected, "input vacuity")
+
+    def test_input_robustness(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_ROBUSTNESS)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'output')
+        spec.set_var_io_type('gnt', 'input')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out = spec.evaluate(self.dataset)
+        expected = [[0, 20], [1, float("inf")], [2, float("inf")], [3, 4], [4, float("inf")]]
+
+        self.assertListEqual(out, expected, "input robustness")
+
+    def test_output_vacuity(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_VACUITY)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'output')
+        spec.set_var_io_type('gnt', 'input')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out = spec.evaluate(self.dataset)
+        expected = [[0, 0], [1, 4], [2, 5], [3, 0], [4, 4]]
+
+        self.assertListEqual(out, expected, "output vacuity")
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_ia_stl_spec_discrete_time_online_evaluation.py` & `rtamt-0.3.5/tests/python/api/test_iastl_discrete_time_online_specification.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,116 +1,116 @@
-import unittest
-import rtamt
-
-class TestIASTLSpecDiscreteTimeOnlineEvaluation(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestIASTLSpecDiscreteTimeOnlineEvaluation, self).__init__(*args, **kwargs)
-        self.left1 = 100
-        self.right1 = 20
-
-        self.left2 = -1
-        self.right2 = -2
-
-        self.left3 = -2
-        self.right3 = 10
-
-        self.left4 = 5
-        self.right4 = 4
-
-        self.left5 = -1
-        self.right5 = -1
-
-    def test_output_robustness(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_ROBUSTNESS);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'input')
-        spec.set_var_io_type('gnt', 'output')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, float("inf"), "input 2")
-        self.assertEqual(out3, float("inf"), "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, float("inf"), "input 5")
-
-    def test_input_vacuity(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_VACUITY);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'input')
-        spec.set_var_io_type('gnt', 'output')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 0, "input 1")
-        self.assertEqual(out2, 4, "input 2")
-        self.assertEqual(out3, 5, "input 3")
-        self.assertEqual(out4, 0, "input 4")
-        self.assertEqual(out5, 4, "input 5")
-
-    def test_input_robustness(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_ROBUSTNESS);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'output')
-        spec.set_var_io_type('gnt', 'input')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, float("inf"), "input 2")
-        self.assertEqual(out3, float("inf"), "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, float("inf"), "input 5")
-
-    def test_output_vacuity(self):
-        spec = rtamt.STLDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_VACUITY);
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.set_var_io_type('req', 'output')
-        spec.set_var_io_type('gnt', 'input')
-        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 0, "input 1")
-        self.assertEqual(out2, 4, "input 2")
-        self.assertEqual(out3, 5, "input 3")
-        self.assertEqual(out4, 0, "input 4")
-        self.assertEqual(out5, 4, "input 5")
-
-if __name__ == '__main__':
+import unittest
+import rtamt
+
+class TestIastlDiscreteTimeOnlineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestIastlDiscreteTimeOnlineSpecification, self).__init__(*args, **kwargs)
+        self.left1 = 100
+        self.right1 = 20
+
+        self.left2 = -1
+        self.right2 = -2
+
+        self.left3 = -2
+        self.right3 = 10
+
+        self.left4 = 5
+        self.right4 = 4
+
+        self.left5 = -1
+        self.right5 = -1
+
+    def test_output_robustness(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_ROBUSTNESS)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'input')
+        spec.set_var_io_type('gnt', 'output')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, float("inf"), "input 2")
+        self.assertEqual(out3, float("inf"), "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, float("inf"), "input 5")
+
+    def test_input_vacuity(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_VACUITY)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'input')
+        spec.set_var_io_type('gnt', 'output')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 0, "input 1")
+        self.assertEqual(out2, 4, "input 2")
+        self.assertEqual(out3, 5, "input 3")
+        self.assertEqual(out4, 0, "input 4")
+        self.assertEqual(out5, 4, "input 5")
+
+    def test_input_robustness(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.INPUT_ROBUSTNESS)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'output')
+        spec.set_var_io_type('gnt', 'input')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, float("inf"), "input 2")
+        self.assertEqual(out3, float("inf"), "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, float("inf"), "input 5")
+
+    def test_output_vacuity(self):
+        spec = rtamt.StlDiscreteTimeSpecification(semantics=rtamt.Semantics.OUTPUT_VACUITY)
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('req', 'output')
+        spec.set_var_io_type('gnt', 'input')
+        spec.spec = 'out = (req >= 3) implies (gnt >= 0)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 0, "input 1")
+        self.assertEqual(out2, 4, "input 2")
+        self.assertEqual(out3, 5, "input 3")
+        self.assertEqual(out4, 0, "input 4")
+        self.assertEqual(out5, 4, "input 5")
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_ltl_spec_discrete_time_online_evaluation.py` & `rtamt-0.3.5/tests/cpp/test_stl_discrete_time_online_specification_cpp.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,640 +1,836 @@
-import unittest
-import math
-import rtamt
-
-class TestLTLSpecDiscreteTimeOnlineEvaluation(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestLTLSpecDiscreteTimeOnlineEvaluation, self).__init__(*args, **kwargs)
-        self.left1 = 100
-        self.right1 = 20
-
-        self.left2 = -1
-        self.right2 = -2
-
-        self.left3 = -2
-        self.right3 = 10
-
-        self.left4 = 5
-        self.right4 = 4
-
-        self.left5 = -1
-        self.right5 = -1
-
-    def test_constant(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = 5'
-
-        spec.parse();
-        out1 = spec.update(0, [])
-        out2 = spec.update(1, [])
-
-        self.assertEqual(out1, 5, "input 1")
-        self.assertEqual(out2, 5, "input 2")
-
-    def test_constant_2(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_const('c', 'int', 5)
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = c'
-
-        spec.parse();
-        out1 = spec.update(0, [])
-        out2 = spec.update(1, [])
-
-        self.assertEqual(out1, 5, "input 1")
-        self.assertEqual(out2, 5, "input 2")
-
-    def test_addition(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req + gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 120, "input 1")
-        self.assertEqual(out2, -3, "input 2")
-        self.assertEqual(out3, 8, "input 3")
-        self.assertEqual(out4, 9, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_subtraction(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req - gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_multiplication(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req * gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 2000, "input 1")
-        self.assertEqual(out2, 2, "input 2")
-        self.assertEqual(out3, -20, "input 3")
-        self.assertEqual(out4, 20, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_division(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req / gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 100 / 20, "input 1")
-        self.assertEqual(out2, -1 / -2, "input 2")
-        self.assertEqual(out3, -2 / 10, "input 3")
-        self.assertEqual(out4, 5 / 4, "input 4")
-        self.assertEqual(out5, -1 / -1, "input 5")
-
-    def test_abs(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = abs(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 2, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_sqrt(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = sqrt(abs(req))'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, math.sqrt(100), "input 1")
-        self.assertEqual(out2, math.sqrt(1), "input 2")
-        self.assertEqual(out3, math.sqrt(2), "input 3")
-        self.assertEqual(out4, math.sqrt(5), "input 4")
-        self.assertEqual(out5, math.sqrt(1), "input 5")
-
-    def test_previous(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = prev(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_next_without_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = next(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_next_with_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = next(req)'
-
-        spec.parse()
-        spec.pastify()
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_and(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -2, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_or(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req or gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_iff(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req iff gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_xor(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req xor gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_implies(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req -> gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_always_without_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_always_with_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_eventually_without_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_eventually_with_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_historically(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_once(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, 100, "input 3")
-        self.assertEqual(out4, 100, "input 4")
-        self.assertEqual(out5, 100, "input 5")
-
-    def test_since(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_until_without_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
-
-    def test_always_with_pastify(self):
-        spec = rtamt.LTLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_not(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = not(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, -100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 2, "input 3")
-        self.assertEqual(out4, -5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_rise(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = rise(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -100, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 2, "input 4")
-        self.assertEqual(out5, -5, "input 5")
-
-    def test_fall(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = fall(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, -100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-
-    def test_predicate_leq(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req <= gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_less(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req < gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_geq(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req >= gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_greater(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req > gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_eq(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req == gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_neq(self):
-        spec = rtamt.LTLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req !== gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-if __name__ == '__main__':
+import unittest
+import math
+import rtamt
+
+class TestStlDenseTimeOnlineSpecificationCpp(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestStlDenseTimeOnlineSpecificationCpp, self).__init__(*args, **kwargs)
+        self.left1 = 100
+        self.right1 = 20
+
+        self.left2 = -1
+        self.right2 = -2
+
+        self.left3 = -2
+        self.right3 = 10
+
+        self.left4 = 5
+        self.right4 = 4
+
+        self.left5 = -1
+        self.right5 = -1
+
+    def test_constant(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = 5'
+
+        spec.parse()
+        out1 = spec.update(0, [])
+        out2 = spec.update(1, [])
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+    def test_constant_2(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_const('c', 'int', 5)
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = c'
+
+        spec.parse()
+        out1 = spec.update(0, [])
+        out2 = spec.update(1, [])
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+    def test_addition(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req + gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 120, "input 1")
+        self.assertEqual(out2, -3, "input 2")
+        self.assertEqual(out3, 8, "input 3")
+        self.assertEqual(out4, 9, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_subtraction(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req - gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_multiplication(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req * gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 2000, "input 1")
+        self.assertEqual(out2, 2, "input 2")
+        self.assertEqual(out3, -20, "input 3")
+        self.assertEqual(out4, 20, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_division(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req / gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 100.0 / 20.0, "input 1")
+        self.assertEqual(out2, -1.0 / -2.0, "input 2")
+        self.assertEqual(out3, -2.0 / 10, "input 3")
+        self.assertEqual(out4,  5.0 / 4.0, "input 4")
+        self.assertEqual(out5, -1.0 / -1.0, "input 5")
+
+    def test_abs(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = abs(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_sqrt(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = sqrt(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', 2)])
+        out2 = spec.update(1, [('req', 3.3)])
+        out3 = spec.update(2, [('req', 4.5)])
+        out4 = spec.update(3, [('req', 0.1)])
+        out5 = spec.update(4, [('req', 1)])
+
+        self.assertEqual(out1, math.sqrt(2), "input 1")
+        self.assertEqual(out2, math.sqrt(3.3), "input 2")
+        self.assertEqual(out3, math.sqrt(4.5), "input 3")
+        self.assertEqual(out4, math.sqrt(0.1), "input 4")
+        self.assertEqual(out5, math.sqrt(1), "input 5")
+
+    def test_previous(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = prev(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_next_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_next_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next(req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_and(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -2, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_or(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req or gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_iff(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req iff gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_xor(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req xor gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_implies(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req -> gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_always_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_always_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_eventually_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_eventually_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_historically(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_once(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, 100, "input 4")
+        self.assertEqual(out5, 100, "input 5")
+
+    def test_since(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_until_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.STLNotImplementedException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
+
+    def test_until_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_eventually_0_1_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0,1](req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_eventually_0_1_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0,1](req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_once_0_1(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[0,1](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_once_1_2(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[1,2](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_always_0_1_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0,1](req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_always_0_1_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0,1](req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_historically_0_1(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[0,1](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_historically_1_2(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[1,2](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_until_0_1_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until[0,1] gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
+
+    def test_until_1_2_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until[1,2] gnt'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 20, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_since_0_1(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since[0,1] gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_not(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = not(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_rise(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = rise(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -100, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 2, "input 4")
+        self.assertEqual(out5, -5, "input 5")
+
+    def test_fall(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = fall(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+
+    def test_predicate_leq(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req <= gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_less(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req < gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_geq(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req >= gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_greater(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req > gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_eq(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req == gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_neq(self):
+        spec = rtamt.StlDiscreteTimeOnlineSpecificationCpp()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req !== gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_stl_interval_style.py` & `rtamt-0.3.5/tests/python/api/test_stl_interval_style.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-import unittest
-import rtamt
-
-class TestSTLIntervalStyle(unittest.TestCase):
-    def __init__(self, *args, **kwargs):
-        super(TestSTLIntervalStyle, self).__init__(*args, **kwargs)
-
-    def test_interval_style(self):
-        spec_comma = rtamt.STLDiscreteTimeSpecification()
-        spec_comma.name = 'STL Comma Style'
-
-        spec_column = rtamt.STLDiscreteTimeSpecification()
-        spec_column.name = 'STL Column Style'
-
-        spec_comma.declare_var('req', 'float')
-        spec_comma.declare_var('gnt', 'float')
-        spec_comma.declare_var('out', 'float')
-
-        spec_column.declare_var('req', 'float')
-        spec_column.declare_var('gnt', 'float')
-        spec_column.declare_var('out', 'float')
-
-        spec_comma.spec = 'out = once[0,2] (req<=2 and gnt>=3)'
-        spec_column.spec = 'out = once[0:2] (req<=2 and gnt>=3)'
-
-        try:
-            spec_comma.parse();
-            spec_column.parse();
-            
-            computed_comma = spec_comma.update(0, [['req', 2.2], ['gnt', 1]])
-            computed_column = spec_column.update(0, [['req', 2.2], ['gnt', 1]])
-            self.assertEqual(computed_comma, computed_column, 'First computation')
-
-            computed_comma = spec_comma.update(1, [['req', 1.2], ['gnt', 3.1]])
-            computed_column = spec_column.update(1, [['req', 1.2], ['gnt', 3.1]])
-            self.assertEqual(computed_comma, computed_column, 'Second computation')
-
-            computed_comma = spec_comma.update(2, [['req', 3.3], ['gnt', 1.4]])
-            computed_column = spec_column.update(2, [['req', 3.3], ['gnt', 1.4]])
-            self.assertEqual(computed_comma, computed_column, 'Second computation')
-
-            computed_comma = spec_comma.update(3, [['req', 4.3], ['gnt', 4.4]])
-            computed_column = spec_column.update(3, [['req', 4.3], ['gnt', 4.4]])
-            self.assertEqual(computed_comma, computed_column, 'Second computation')
-
-        except rtamt.STLParseException as err:
-            print('STL Parse Exception: {}'.format(err))
-
-if __name__ == '__main__':
-    unittest.main()
+import unittest
+import rtamt
+
+class TestStlIntervalStyle(unittest.TestCase):
+    def __init__(self, *args, **kwargs):
+        super(TestStlIntervalStyle, self).__init__(*args, **kwargs)
+
+    def test_interval_style(self):
+        spec_comma = rtamt.StlDiscreteTimeSpecification()
+        spec_comma.name = 'STL Comma Style'
+
+        spec_column = rtamt.StlDiscreteTimeSpecification()
+        spec_column.name = 'STL Column Style'
+
+        spec_comma.declare_var('req', 'float')
+        spec_comma.declare_var('gnt', 'float')
+        spec_comma.declare_var('out', 'float')
+
+        spec_column.declare_var('req', 'float')
+        spec_column.declare_var('gnt', 'float')
+        spec_column.declare_var('out', 'float')
+
+        spec_comma.spec = 'out = once[0,2] (req<=2 and gnt>=3)'
+        spec_column.spec = 'out = once[0:2] (req<=2 and gnt>=3)'
+
+        try:
+            spec_comma.parse()
+            spec_column.parse()
+
+            computed_comma = spec_comma.update(0, [['req', 2.2], ['gnt', 1]])
+            computed_column = spec_column.update(0, [['req', 2.2], ['gnt', 1]])
+            self.assertEqual(computed_comma, computed_column, 'First computation')
+
+            computed_comma = spec_comma.update(1, [['req', 1.2], ['gnt', 3.1]])
+            computed_column = spec_column.update(1, [['req', 1.2], ['gnt', 3.1]])
+            self.assertEqual(computed_comma, computed_column, 'Second computation')
+
+            computed_comma = spec_comma.update(2, [['req', 3.3], ['gnt', 1.4]])
+            computed_column = spec_column.update(2, [['req', 3.3], ['gnt', 1.4]])
+            self.assertEqual(computed_comma, computed_column, 'Second computation')
+
+            computed_comma = spec_comma.update(3, [['req', 4.3], ['gnt', 4.4]])
+            computed_column = spec_column.update(3, [['req', 4.3], ['gnt', 4.4]])
+            self.assertEqual(computed_comma, computed_column, 'Second computation')
+
+        except rtamt.RTAMTException as err:
+            print('STL Parse Exception: {}'.format(err))
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_stl_reset.py` & `rtamt-0.3.5/tests/python/api/test_ltl_discrete_time_online_specification.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,644 +1,640 @@
-import unittest
-import math
-
-from rtamt.spec.stl.discrete_time.specification import STLDiscreteTimeSpecification
-
-class TestSTLReset(unittest.TestCase):
-    def __init__(self, *args, **kwargs):
-        super(TestSTLReset, self).__init__(*args, **kwargs)
-
-    def test_constant(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = 5'
-        spec.parse()
-
-        out = spec.update(0, [])
-        self.assertEqual(5, out, 'Constant reset assertion')
-
-        out = spec.update(0, [])
-        self.assertEqual(5, out, 'Constant reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [])
-        self.assertEqual(5, out, 'Constant reset assertion')
-
-    def test_variable(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(1.1, out, 'Variable reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(2, out, 'Variable reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3]])
-        self.assertEqual(3.3, out, 'Variable reset assertion')
-
-    def test_abs(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = abs(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(1.1, out, 'Abs reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(2, out, 'Abs reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3.3]])
-        self.assertEqual(3.3, out, 'Abs reset assertion')
-
-
-    def test_sqrt(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = sqrt(abs(req))'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(math.sqrt(1.1), out, 'Abs reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(math.sqrt(2), out, 'Abs reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3.3]])
-        self.assertEqual(math.sqrt(3.3), out, 'Abs reset assertion')
-
-    def test_exp(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = exp(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(math.exp(1.1), out, 'Abs reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(math.exp(2), out, 'Abs reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3.3]])
-        self.assertEqual(math.exp(-3.3), out, 'Abs reset assertion')
-
-    def test_pow(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = pow(2,req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(math.pow(2,1.1), out, 'Abs reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(math.pow(2,2), out, 'Abs reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3.3]])
-        self.assertEqual(math.pow(2,-3.3), out, 'Abs reset assertion')
-
-    def test_addition(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req + gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(1.1 + 2.2, out, 'Addition reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2 - 1, out, 'Addition reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(3.3 + 4.3, out, 'Addition reset assertion')
-
-    def test_subtraction(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req - gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(1.1 - 2.2, out, 'Subtraction reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2 + 1, out, 'Subtraction reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(3.3 - 4.3, out, 'Subtraction reset assertion')
-
-    def test_multiplication(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req * gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(1.1 * 2.2, out, 'Multiplication reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2 * -1, out, 'Multiplication reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(3.3 * 4.3, out, 'Multiplication reset assertion')
-
-    def test_division(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req / gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(1.1 / 2.2, out, 'Division reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2 / -1, out, 'Division reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(3.3 / 4.3, out, 'Division reset assertion')
-
-    def test_predicate_leq(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req <= gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2 - 1.1, out, 'Predicate <= reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(-1 - 2, out, 'Predicate <= reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(4.3 - 3.3, out, 'Predicate <= reset assertion')
-
-    def test_predicate_less(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req < gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2 - 1.1, out, 'Predicate < reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(-1 - 2, out, 'Predicate < reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(4.3 - 3.3, out, 'Predicate < reset assertion')
-
-    def test_predicate_geq(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req >= gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(-2.2 + 1.1, out, 'Predicate >= reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(1 + 2, out, 'Predicate >= reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(-4.3 + 3.3, out, 'Predicate >= reset assertion')
-
-    def test_predicate_greater(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req >= gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(-2.2 + 1.1, out, 'Predicate > reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(1 + 2, out, 'Predicate > reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(-4.3 + 3.3, out, 'Predicate > reset assertion')
-
-    def test_predicate_eq(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req == gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(-(2.2 - 1.1), out, 'Predicate == reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(-(1 + 2), out, 'Predicate == reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(-4.3 + 3.3, out, 'Predicate == reset assertion')
-
-    def test_predicate_neq(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req !== gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2 - 1.1, out, 'Predicate == reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(1 + 2, out, 'Predicate == reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(4.3 - 3.3, out, 'Predicate == reset assertion')
-
-    def test_not(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = not(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(-1.1, out, 'Negation reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(-2, out, 'Negation reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3.3]])
-        self.assertEqual(3.3, out, 'Negation reset assertion')
-
-    def test_conjunction(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(1.1, out, 'And reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(-1, out, 'And reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(3.3, out, 'And reset assertion')
-
-    def test_disjunction(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req or gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2, out, 'Or reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2, out, 'Or reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(4.3, out, 'Or reset assertion')
-
-    def test_implication(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req implies gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2, out, 'Implies reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(-1, out, 'Implies reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(4.3, out, 'Implies reset assertion')
-
-    def test_iff(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req iff gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(1.1 - 2.2, out, 'Iff reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(-1 - 2, out, 'Iff reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(3.3 - 4.3, out, 'Iff reset assertion')
-
-    def test_xor(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req xor gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(-(1.1 - 2.2), out, 'Xor reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(1 + 2, out, 'Xor reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 4.3]])
-        self.assertEqual(4.3 - 3.3, out, 'Xor reset assertion')
-
-    def test_rise(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = rise(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(1.1, out, 'Rise reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(-1.1, out, 'Rise reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 4.3]])
-        self.assertEqual(4.3, out, 'Rise reset assertion')
-
-    def test_fall(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = fall(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(-1.1, out, 'Fall reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(-2, out, 'Fall reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3]])
-        self.assertEqual(3, out, 'Rise reset assertion')
-
-    def test_prev(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = prev(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(float("inf"), out, 'Fall reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(1.1, out, 'Fall reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', -3]])
-        self.assertEqual(float("inf"), out, 'Rise reset assertion')
-
-    def test_once(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 5]])
-        self.assertEqual(5, out, 'Once reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(5, out, 'Once reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 4.3]])
-        self.assertEqual(4.3, out, 'Once reset assertion')
-
-    def test_historically(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically(req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(1.1, out, 'Historically reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(1.1, out, 'Historically reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 4.3]])
-        self.assertEqual(4.3, out, 'Historically reset assertion')
-
-    # def test_eventually(self):
-    #     spec = STLDiscreteTimeSpecification()
-    #     spec.declare_var('req', 'float')
-    #     spec.declare_var('out', 'float')
-    #     spec.spec = 'out = eventually(req)'
-    #     spec.parse()
-    #
-    #     out = spec.update(0, [['req', 5]])
-    #     self.assertEqual(5, out, 'Eventually reset assertion')
-    #
-    #     out = spec.update(1, [['req', 2]])
-    #     self.assertEqual(5, out, 'Eventually reset assertion')
-    #
-    #     spec.reset()
-    #
-    #     out = spec.update(0, [['req', 4.3]])
-    #     self.assertEqual(4.3, out, 'Eventually reset assertion')
-
-    # def test_always(self):
-    #     spec = STLDiscreteTimeSpecification()
-    #     spec.declare_var('req', 'float')
-    #     spec.declare_var('out', 'float')
-    #     spec.spec = 'out = always(req)'
-    #     spec.parse()
-    #
-    #     out = spec.update(0, [['req', 1.1]])
-    #     self.assertEqual(1.1, out, 'Always reset assertion')
-    #
-    #     out = spec.update(1, [['req', 2]])
-    #     self.assertEqual(1.1, out, 'Always reset assertion')
-    #
-    #     spec.reset()
-    #
-    #     out = spec.update(0, [['req', 4.3]])
-    #     self.assertEqual(4.3, out, 'Always reset assertion')
-
-    def test_since(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2, out, 'Since reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2, out, 'Since reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 1.6]])
-        self.assertEqual(1.6, out, 'Since reset assertion')
-
-
-    def test_once_0_1(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once[0:1](req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 5]])
-        self.assertEqual(5, out, 'Once [0,1] reset assertion')
-
-        out = spec.update(1, [['req', 4.8]])
-        self.assertEqual(5, out, 'Once [0,1] reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 4.3]])
-        self.assertEqual(4.3, out, 'Once [0,1] reset assertion')
-
-
-    def test_historically_0_1(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically[0:1](req)'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1]])
-        self.assertEqual(1.1, out, 'Historically [0,1] reset assertion')
-
-        out = spec.update(1, [['req', 2]])
-        self.assertEqual(1.1, out, 'Historically [0,1] reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 4.3]])
-        self.assertEqual(4.3, out, 'Historically [0,1] reset assertion')
-
-    def test_since_0_1(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since[0:1] gnt'
-        spec.parse()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2, out, 'Since [0:1] reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2, out, 'Since [0:1] reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 1.6]])
-        self.assertEqual(1.6, out, 'Since [0:1] reset assertion')
-
-    def test_precedes_0_1(self):
-        spec = STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until[0:1] gnt'
-        spec.parse()
-        spec.pastify()
-
-        out = spec.update(0, [['req', 1.1], ['gnt', 2.2]])
-        self.assertEqual(2.2, out, 'Precedes [0:1] reset assertion')
-
-        out = spec.update(1, [['req', 2], ['gnt', -1]])
-        self.assertEqual(2.2, out, 'Precedes [0:1] reset assertion')
-
-        spec.reset()
-
-        out = spec.update(0, [['req', 3.3], ['gnt', 1.6]])
-        self.assertEqual(1.6, out, 'Precedes [0:1] reset assertion')
-
-    if __name__ == '__main__':
-        unittest.main()
+import unittest
+import math
+import rtamt
+
+class TestLtlDiscreteTimeOnlineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestLtlDiscreteTimeOnlineSpecification, self).__init__(*args, **kwargs)
+        self.left1 = 100
+        self.right1 = 20
+
+        self.left2 = -1
+        self.right2 = -2
+
+        self.left3 = -2
+        self.right3 = 10
+
+        self.left4 = 5
+        self.right4 = 4
+
+        self.left5 = -1
+        self.right5 = -1
+
+    def test_constant(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = 5'
+
+        spec.parse()
+        out1 = spec.update(0, [])
+        out2 = spec.update(1, [])
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+    def test_constant_2(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_const('c', 'int', 5)
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = c'
+
+        spec.parse()
+        out1 = spec.update(0, [])
+        out2 = spec.update(1, [])
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+    def test_addition(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req + gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 120, "input 1")
+        self.assertEqual(out2, -3, "input 2")
+        self.assertEqual(out3, 8, "input 3")
+        self.assertEqual(out4, 9, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_subtraction(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req - gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_multiplication(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req * gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 2000, "input 1")
+        self.assertEqual(out2, 2, "input 2")
+        self.assertEqual(out3, -20, "input 3")
+        self.assertEqual(out4, 20, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_division(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req / gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 100 / 20, "input 1")
+        self.assertEqual(out2, -1 / -2, "input 2")
+        self.assertEqual(out3, -2 / 10, "input 3")
+        self.assertEqual(out4, 5 / 4, "input 4")
+        self.assertEqual(out5, -1 / -1, "input 5")
+
+    def test_abs(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = abs(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_sqrt(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = sqrt(abs(req))'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, math.sqrt(100), "input 1")
+        self.assertEqual(out2, math.sqrt(1), "input 2")
+        self.assertEqual(out3, math.sqrt(2), "input 3")
+        self.assertEqual(out4, math.sqrt(5), "input 4")
+        self.assertEqual(out5, math.sqrt(1), "input 5")
+
+    def test_previous(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = prev(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_next_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_next_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next(req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_and(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -2, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_or(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req or gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_iff(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req iff gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_xor(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req xor gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_implies(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req -> gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_always_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_always_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_eventually_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_eventually_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_historically(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_once(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, 100, "input 4")
+        self.assertEqual(out5, 100, "input 5")
+
+    def test_since(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_until_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
+
+    def test_always_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_not(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = not(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_rise(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = rise(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -100, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 2, "input 4")
+        self.assertEqual(out5, -5, "input 5")
+
+    def test_fall(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = fall(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+
+    def test_predicate_leq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req <= gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_less(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req < gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_geq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req >= gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_greater(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req > gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_eq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req == gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_neq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req !== gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_stl_sampling_time_units.py` & `rtamt-0.3.5/tests/python/api/test_stl_sampling_time_units.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-import unittest
-import rtamt
-
-
-class TestSTLSamplingTimeUnits(unittest.TestCase):
-    def __init__(self, *args, **kwargs):
-        super(TestSTLSamplingTimeUnits, self).__init__(*args, **kwargs)
-
-    def test_example(self):
-        spec = rtamt.STLDiscreteTimeSpecification()
-        spec.name = 'STL Example specification'
-
-        self.assertEqual(spec.name, 'STL Example specification', 'Spec name assertion')
-
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-
-        spec.spec = 'out = req<=2 and gnt>=3'
-
-        self.assertEqual(spec.spec, 'out = req<=2 and gnt>=3', 'Spec assertion')
-        self.assertEqual(spec.sampling_tolerance, 0.1, 'Spec sampling tolerance assertion')
-
-        try:
-            spec.parse();
-            computed = spec.update(0, [['req', 2.2], ['gnt', 1]])
-            self.assertEqual(-2.0, computed, 'First computation')
-
-            computed = spec.update(1.2, [['req', 4.2], ['gnt', -3.7]])
-            self.assertEqual(-6.7, computed, 'First computation')
-            self.assertEqual(1, spec.sampling_violation_counter, 'Violation counter')
-        except rtamt.STLParseException as err:
-            print('STL Parse Exception: {}'.format(err))
-
-    def test_wrong_tolerance(self):
-        spec = rtamt.STLDiscreteTimeSpecification()
-        with self.assertRaises(rtamt.STLException):
-            spec.set_sampling_period(1, 's', 1.5)
-
-    def test_default_unit_default_sampling_unit_greater_tolerance_ok_samples(self):
-        spec = rtamt.STLDiscreteTimeSpecification()
-        spec.name = 'STL Example specification'
-
-        self.assertEqual(spec.name, 'STL Example specification', 'Spec name assertion')
-
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-
-        spec.set_sampling_period(1, 's', 0.5)
-
-        spec.spec = 'out = rise(req)'
-
-        try:
-            spec.parse();
-            spec.update(0, [['req', 2.2], ['gnt', 1]])
-            spec.update(1.11, [['req', 2.2], ['gnt', 1]])
-            spec.update(1.99, [['req', 2.2], ['gnt', 1]])
-            spec.update(3.38, [['req', 2.2], ['gnt', 1]])
-            spec.update(4.39, [['req', 2.2], ['gnt', 1]])
-
-            self.assertEqual(0, spec.sampling_violation_counter, 'Violation counter')
-        except rtamt.STLParseException as err:
-            print('STL Parse Exception: {}'.format(err))
-
-
-if __name__ == '__main__':
-    unittest.main()
+import unittest
+import rtamt
+
+
+class TestStlSamplingTimeUnits(unittest.TestCase):
+    def __init__(self, *args, **kwargs):
+        super(TestStlSamplingTimeUnits, self).__init__(*args, **kwargs)
+
+    def test_example(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.name = 'STL Example specification'
+
+        self.assertEqual(spec.name, 'STL Example specification', 'Spec name assertion')
+
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+
+        spec.spec = 'out = req<=2 and gnt>=3'
+
+        self.assertEqual(spec.spec, 'out = req<=2 and gnt>=3', 'Spec assertion')
+        self.assertEqual(spec.sampling_tolerance, 0.1, 'Spec sampling tolerance assertion')
+
+        try:
+            spec.parse()
+            computed = spec.update(0, [['req', 2.2], ['gnt', 1]])
+            self.assertEqual(-2.0, computed, 'First computation')
+
+            computed = spec.update(1.2, [['req', 4.2], ['gnt', -3.7]])
+            self.assertEqual(-6.7, computed, 'First computation')
+            self.assertEqual(1, spec.sampling_violation_counter, 'Violation counter')
+        except rtamt.RTAMTException as err:
+            print('STL Parse Exception: {}'.format(err))
+
+    def test_wrong_tolerance(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        with self.assertRaises(Exception):
+            spec.set_sampling_period(1, 's', 1.5)
+
+    def test_default_unit_default_sampling_unit_greater_tolerance_ok_samples(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.name = 'STL Example specification'
+
+        self.assertEqual(spec.name, 'STL Example specification', 'Spec name assertion')
+
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+
+        spec.set_sampling_period(1, 's', 0.5)
+
+        spec.spec = 'out = rise(req)'
+
+        try:
+            spec.parse()
+            spec.update(0, [['req', 2.2], ['gnt', 1]])
+            spec.update(1.11, [['req', 2.2], ['gnt', 1]])
+            spec.update(1.99, [['req', 2.2], ['gnt', 1]])
+            spec.update(3.38, [['req', 2.2], ['gnt', 1]])
+            spec.update(4.39, [['req', 2.2], ['gnt', 1]])
+
+            self.assertEqual(0, spec.sampling_violation_counter, 'Violation counter')
+        except rtamt.RTAMTException as err:
+            print('STL Parse Exception: {}'.format(err))
+
+
+if __name__ == '__main__':
+    unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_stl_spec_dense_time_offline_evaluation.py` & `rtamt-0.3.5/tests/python/api/test_stl_dense_time_offline_specification.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,573 +1,619 @@
-import unittest
-import math
-import rtamt
-
-class TestSTLBooleanAndTemporalOffline(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestSTLBooleanAndTemporalOffline, self).__init__(*args, **kwargs)
-
-    def test_and(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 1.3], [0.7, 3], [1.3, -1.2], [2.1, -2.2]]
-
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "and")
-
-
-    def test_or(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req or gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5], [0.7, 4], [1.3, 0.1], [2.1, 1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "or")
-
-    def test_iff(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req iff gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, -1.2 - 0.1], [2.1, -2.2 - 1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "iff")
-
-    def test_xor(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req xor gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5-1.3], [0.7, 4-3], [1.3, 1.2 + 0.1], [2.1, 2.2 + 1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "xor")
-
-    def test_implies(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req implies gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5], [0.7, 4], [1.3, -0.1], [2.1, 2.2]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "implies")
-
-
-    def test_always(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, -1.2], [2.1, 1.7]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "always")
-
-    def test_eventually(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually(req)'
-
-        spec.parse()
-
-        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 4], [1.3, 1.7], [2.1, 1.7]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "ev")
-
-
-    def test_historically(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically(req)'
-
-        spec.parse()
-
-        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5], [1.3, -1.2], [2.1, -1.2]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "hist")
-
-    def test_once(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once(req)'
-
-        spec.parse()
-
-        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5], [0.7, 4], [2.1, 4]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "hist")
-
-
-    def test_since(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since gnt'
-
-        spec.parse();
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        self.assertListEqual(out, expected, "since")
-
-    def test_until(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse();
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 1.3], [0.7, 3], [1.3, -1.2], [2.1, -2.2]]
-        self.assertListEqual(out, expected, "until")
-
-    def test_once_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once[0:1](req)'
-
-        spec.parse()
-
-        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
-
-        expected = [[0, 4], [6, 2], [10, 5], [15, 5]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "once[0,1]")
-
-    def test_historically_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically[0:1](req)'
-
-        spec.parse()
-
-        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
-
-        expected = [[0, 4], [5, 2], [11, 5], [15, 3]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "hist[0,1]")
-
-    def test_always_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always[0:1](req)'
-
-        spec.parse()
-
-        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
-
-        expected = [[0, 4], [4, 2], [10, 5], [15, 5]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "alw[0,1]")
-
-    def test_eventually_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually[0:1](req)'
-
-        spec.parse()
-
-        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
-
-        expected = [[0, 4], [5, 2], [9, 5], [15, 5]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "ev[0,1]")
-
-    def test_since_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since[0:1] gnt'
-
-        spec.parse();
-        left = [[0, 2], [10, 2]]
-        right = [[0, 4], [10, 4]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 2], [10, 2]]
-        self.assertListEqual(out, expected, "since[0:1]")
-
-    def test_until_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until[0:1] gnt'
-
-        spec.parse();
-        left = [[0, 2], [10, 2]]
-        right = [[0, 4], [10, 4]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 2], [10, 2]]
-        self.assertListEqual(out, expected, "until[0:1]")
-
-
-    def test_addition(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req + gnt'
-
-        spec.parse();
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 1.3 + 2.5], [0.7, 3 + 4], [1.3, 0.1 + -1.2], [2.1, -2.2 + 1.7]]
-        self.assertListEqual(out, expected, "add")
-
-    def test_subtraction(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req - gnt'
-
-        spec.parse();
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, 0.1 - -1.2], [2.1, -2.2 - 1.7]]
-        self.assertListEqual(out, expected, "sub")
-
-    def test_multiplication(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req * gnt'
-
-        spec.parse();
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 1.3 * 2.5], [0.7, 3 * 4], [1.3, 0.1 * -1.2], [2.1, -2.2 * 1.7]]
-        self.assertListEqual(out, expected, "mult")
-
-    def test_division(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req / gnt'
-
-        spec.parse();
-        left = [[0, 1.3], [0.7, 3.], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4.], [1.3, -1.2], [2.1, 1.7]]
-
-        out = spec.evaluate(['req', left], ['gnt', right])
-        expected = [[0, 1.3 / 2.5], [0.7, 3. / 4.], [1.3, 0.1 / -1.2], [2.1, -2.2 / 1.7]]
-        self.assertListEqual(out, expected, "div")
-
-    def test_abs(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = abs(req)'
-
-        spec.parse()
-
-        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
-
-        expected = [[1.3, 4], [3.7, 2.2], [9.4, 33]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "abs")
-
-    def test_sqrt(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = sqrt(abs(req))'
-
-        spec.parse()
-
-        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
-
-        expected = [[1.3, math.sqrt(4)], [3.7, math.sqrt(2.2)], [9.4, math.sqrt(33)]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "sqrt")
-
-    def test_exp(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = exp(req)'
-
-        spec.parse()
-
-        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
-
-        expected = [[1.3, math.exp(4)], [3.7, math.exp(-2.2)], [9.4, math.exp(-33)]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "exp")
-
-    def test_pow(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = pow(2,req)'
-
-        spec.parse()
-
-        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
-
-        expected = [[1.3, math.pow(2,4)], [3.7, math.pow(2,-2.2)], [9.4, math.pow(2,-33)]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "pow")
-
-
-    def test_not(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = not(req)'
-
-        spec.parse()
-
-        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
-
-        expected = [[1.3, -4], [3.7, 2.2], [9.4, 33]]
-        computed = spec.evaluate(['req', op])
-
-        self.assertListEqual(expected, computed, "not")
-
-    def test_next(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = next req'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_prev(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = prev req'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_rise(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = rise(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_fall(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = fall(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-
-
-    def test_predicate_leq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req <= gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5 - 1.3], [0.7, 4 - 3], [1.3, -1.2-0.1], [2.1, 1.7+2.2]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "leq")
-
-    def test_predicate_less(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req < gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5 - 1.3], [0.7, 4 - 3], [1.3, -1.2 - 0.1], [2.1, 1.7 + 2.2]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "less")
-
-    def test_predicate_geq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req >= gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 1.3-2.5], [0.7, 3-4], [1.3, 0.1+1.2], [2.1, -2.2-1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "geq")
-
-    def test_predicate_greater(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req > gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, 0.1 + 1.2], [2.1, -2.2 - 1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "greater")
-
-    def test_predicate_eq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req == gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, -0.1 - 1.2], [2.1, -2.2 - 1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "eq")
-
-    def test_predicate_neq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req !== gnt'
-
-        spec.parse();
-
-        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
-        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
-
-        expected = [[0, 2.5-1.3], [0.7, 4-3], [1.3, 0.1 + 1.2], [2.1, 2.2+1.7]]
-
-        computed = spec.evaluate(['req', left], ['gnt', right])
-
-        self.assertListEqual(expected, computed, "neq")
-
-if __name__ == '__main__':
+import unittest
+import math
+import rtamt
+
+class TestStlDenseTimeOfflineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestStlDenseTimeOfflineSpecification, self).__init__(*args, **kwargs)
+
+    def test_and(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 1.3], [0.7, 3], [1.3, -1.2], [2.1, -2.2]]
+
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "and")
+
+
+    def test_or(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req or gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5], [0.7, 4], [1.3, 0.1], [2.1, 1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "or")
+
+    def test_iff(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req iff gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, -1.2 - 0.1], [2.1, -2.2 - 1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "iff")
+
+    def test_xor(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req xor gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5-1.3], [0.7, 4-3], [1.3, 1.2 + 0.1], [2.1, 2.2 + 1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "xor")
+
+    def test_implies(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_io_type('out', 'output')
+        spec.spec = 'out = req implies gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5], [0.7, 4], [1.3, -0.1], [2.1, 2.2]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "implies")
+
+
+    def test_always(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, -1.2], [2.1, 1.7]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "always")
+
+    def test_eventually(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 4], [1.3, 1.7], [2.1, 1.7]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "ev")
+
+
+    def test_historically(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically(req)'
+
+        spec.parse()
+
+        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5], [1.3, -1.2], [2.1, -1.2]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "hist")
+
+    def test_once(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once(req)'
+
+        spec.parse()
+
+        op = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5], [0.7, 4], [2.1, 4]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "hist")
+
+
+    def test_since(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since gnt'
+
+        spec.parse()
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        self.assertListEqual(out, expected, "since")
+
+    def test_until(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 1.3], [0.7, 3], [1.3, -1.2], [2.1, -2.2]]
+        self.assertListEqual(out, expected, "until")
+
+    def test_once_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[0:1](req)'
+
+        spec.parse()
+
+        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
+
+        expected = [[0, 4], [6, 2], [10, 5], [16, 3]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "once[0,1]")
+
+    def test_historically_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[0:1](req)'
+
+        spec.parse()
+
+        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
+
+        expected = [[0, 4], [5, 2], [11, 5], [15, 3]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "hist[0,1]")
+
+    def test_always_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0:1](req)'
+
+        spec.parse()
+
+        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
+
+        expected = [[0, 4], [4, 2], [10, 5], [14, 3]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "alw[0,1]")
+
+    def test_eventually_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0:1](req)'
+
+        spec.parse()
+
+        op = [[0, 4], [5, 2], [10, 5], [15, 3]]
+
+        expected = [[0, 4], [5, 2], [9, 5], [15, 3]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "ev[0,1]")
+
+    def test_eventually_0_5_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0:5](req)'
+
+        spec.parse()
+
+        op = [[0, 1], [6, 2], [7, 3], [8, 4], [9, 5], [15, 6]]
+
+        expected = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [10, 6]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "ev[0,5]")
+
+#    def test_eventually_0_5_2(self):
+#        spec = rtamt.StlDenseTimeSpecification()
+#        spec.declare_var('req', 'float')
+#        spec.declare_var('out', 'float')
+#        spec.spec = 'out = eventually[0:5](req)'
+
+#        spec.parse()
+
+#        op = [[0, 1], [6, 2], [7, 3], [8, 4], [9, 5], [15, 3]]
+
+#        expected = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [15, 3]]
+#        computed = spec.evaluate(['req', op])
+
+#        self.assertListEqual(expected, computed, "ev[0,5]")
+
+#    def test_eventually_0_5_3(self):
+#        spec = rtamt.StlDenseTimeSpecification()
+#        spec.declare_var('req', 'float')
+#        spec.declare_var('out', 'float')
+#        spec.spec = 'out = eventually[0:5](req)'
+
+#        spec.parse()
+
+#        op = [[0, 5], [6, 1], [7, 4], [9, 5], [15, 3]]
+
+#        expected = [[0, 5], [4, 3]]
+#        computed = spec.evaluate(['req', op])
+
+#        self.assertListEqual(expected, computed, "ev[0,5]")
+
+    def test_since_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since[0:1] gnt'
+
+        spec.parse()
+        left = [[0, 2], [10, 2]]
+        right = [[0, 4], [10, 4]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 2], [10, 2]]
+        self.assertListEqual(out, expected, "since[0:1]")
+
+    def test_until_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until[0:1] gnt'
+
+        spec.parse()
+        left = [[0, 2], [10, 2]]
+        right = [[0, 4], [10, 4]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 2], [9, 2]]
+        self.assertListEqual(out, expected, "until[0:1]")
+
+
+    def test_addition(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req + gnt'
+
+        spec.parse()
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 1.3 + 2.5], [0.7, 3 + 4], [1.3, 0.1 + -1.2], [2.1, -2.2 + 1.7]]
+        self.assertListEqual(out, expected, "add")
+
+    def test_subtraction(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req - gnt'
+
+        spec.parse()
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, 0.1 - -1.2], [2.1, -2.2 - 1.7]]
+        self.assertListEqual(out, expected, "sub")
+
+    def test_multiplication(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req * gnt'
+
+        spec.parse()
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 1.3 * 2.5], [0.7, 3 * 4], [1.3, 0.1 * -1.2], [2.1, -2.2 * 1.7]]
+        self.assertListEqual(out, expected, "mult")
+
+    def test_division(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req / gnt'
+
+        spec.parse()
+        left = [[0, 1.3], [0.7, 3.], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4.], [1.3, -1.2], [2.1, 1.7]]
+
+        out = spec.evaluate(['req', left], ['gnt', right])
+        expected = [[0, 1.3 / 2.5], [0.7, 3. / 4.], [1.3, 0.1 / -1.2], [2.1, -2.2 / 1.7]]
+        self.assertListEqual(out, expected, "div")
+
+    def test_abs(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = abs(req)'
+
+        spec.parse()
+
+        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
+
+        expected = [[1.3, 4], [3.7, 2.2], [9.4, 33]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "abs")
+
+    def test_sqrt(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = sqrt(abs(req))'
+
+        spec.parse()
+
+        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
+
+        expected = [[1.3, math.sqrt(4)], [3.7, math.sqrt(2.2)], [9.4, math.sqrt(33)]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "sqrt")
+
+    def test_exp(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = exp(req)'
+
+        spec.parse()
+
+        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
+
+        expected = [[1.3, math.exp(4)], [3.7, math.exp(-2.2)], [9.4, math.exp(-33)]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "exp")
+
+    def test_pow(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = pow(2,req)'
+
+        spec.parse()
+
+        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
+
+        expected = [[1.3, math.pow(2,4)], [3.7, math.pow(2,-2.2)], [9.4, math.pow(2,-33)]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "pow")
+
+
+    def test_not(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = not(req)'
+
+        spec.parse()
+
+        op = [[1.3, 4], [3.7, -2.2], [9.4, -33]]
+
+        expected = [[1.3, -4], [3.7, 2.2], [9.4, 33]]
+        computed = spec.evaluate(['req', op])
+
+        self.assertListEqual(expected, computed, "not")
+
+    def test_next(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next req'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_prev(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = prev req'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_rise(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = rise(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_fall(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = fall(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+
+
+    def test_predicate_leq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req <= gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5 - 1.3], [0.7, 4 - 3], [1.3, -1.2-0.1], [2.1, 1.7+2.2]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "leq")
+
+    def test_predicate_less(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req < gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5 - 1.3], [0.7, 4 - 3], [1.3, -1.2 - 0.1], [2.1, 1.7 + 2.2]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "less")
+
+    def test_predicate_geq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req >= gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 1.3-2.5], [0.7, 3-4], [1.3, 0.1+1.2], [2.1, -2.2-1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "geq")
+
+    def test_predicate_greater(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req > gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, 0.1 + 1.2], [2.1, -2.2 - 1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "greater")
+
+    def test_predicate_eq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req == gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 1.3 - 2.5], [0.7, 3 - 4], [1.3, -0.1 - 1.2], [2.1, -2.2 - 1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "eq")
+
+    def test_predicate_neq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req !== gnt'
+
+        spec.parse()
+
+        left = [[0, 1.3], [0.7, 3], [1.3, 0.1], [2.1, -2.2]]
+        right = [[0, 2.5], [0.7, 4], [1.3, -1.2], [2.1, 1.7]]
+
+        expected = [[0, 2.5-1.3], [0.7, 4-3], [1.3, 0.1 + 1.2], [2.1, 2.2+1.7]]
+
+        computed = spec.evaluate(['req', left], ['gnt', right])
+
+        self.assertListEqual(expected, computed, "neq")
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_stl_spec_dense_time_online_evaluation.py` & `rtamt-0.3.5/tests/python/api/test_stl_dense_time_online_specification.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,997 +1,997 @@
-import unittest
-import math
-import rtamt
-
-class TestSTLBooleanAndTemporalOnline(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestSTLBooleanAndTemporalOnline, self).__init__(*args, **kwargs)
-
-    def test_and_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-
-        spec.parse();
-
-        in_data_1_1 = [[2, 2], [3.3, 3], [5.7, 4]]
-        in_data_2_1 = [[2.5, 5], [4.7, 6]]
-
-        in_data_1_2 = []
-        in_data_2_2 = [[5.7, 1]]
-
-        out_expected_1 = [[2.5, 2], [3.3, 3]]
-        out_expected_2 = [[4.7, 3]]
-
-        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
-        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_2, out_computed_2))
-
-    def test_and_2(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-
-        spec.parse();
-
-        in_data_1_1 = [[2, 2]]
-        in_data_2_1 = [[2, 1]]
-
-        out_expected_1 = []
-        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        in_data_1_2 = [[3.3, 3]]
-        in_data_2_2 = [[3.3, 5]]
-
-        out_expected_2 = [[2, 1]]
-        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_2, out_computed_2))
-
-        in_data_1_3 = [[4.7, 5]]
-        in_data_2_3 = [[4.7, 2]]
-
-        out_expected_3 = [[3.3, 3]]
-        out_computed_3 = spec.update(['req', in_data_1_3], ['gnt', in_data_2_3])
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_and_3(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-
-        spec.parse();
-
-        in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
-        in_data_2_1 = [[1.2, 1]]
-        out_expected_1 = []
-        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        in_data_1_2 = []
-        in_data_2_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
-        out_expected_2 = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2]]
-        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_2, out_computed_2))
-
-        in_data_1_3 = [[6.7, 4], [9.9, 5]]
-        in_data_2_3 = [[8.1, 6]]
-        out_expected_3 = [[6.1, 1], [6.7, 3], [7.5, 2]]
-        out_computed_3 = spec.update(['req', in_data_1_3], ['gnt', in_data_2_3])
-
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_or(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req or gnt'
-
-        spec.parse();
-
-        in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
-        in_data_2_1 = [[1.2, 1]]
-        out_expected_1 = []
-        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_1, out_computed_1))
-
-        in_data_1_2 = []
-        in_data_2_2 = [[3.7, 3], [7.5, 2]]
-        out_expected_2 = [[1.2, 2], [3.7, 3]]
-        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_1_3 = [[6.7, 4], [9.9, 5]]
-        in_data_2_3 = [[8.1, 6]]
-        out_expected_3 = [[6.1, 3], [6.7, 4]]
-        out_computed_3 = spec.update(['req', in_data_1_3], ['gnt', in_data_2_3])
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-
-    def test_iff(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req iff gnt'
-
-        spec.parse();
-
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, -1], [4.1, -2], [5, -1], [6.1, -2], [6.7, -1], [7.5, -2]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_xor(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req xor gnt'
-
-        spec.parse();
-
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [4.1, 2], [5, 1], [6.1, 2], [6.7, 1], [7.5, 2]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-
-    def test_implies(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req -> gnt'
-
-        spec.parse();
-
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [3.7, 3], [7.5, 2]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_always_without_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, [])
-
-    def test_always_with_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-
-    def test_historically(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically req'
-
-        spec.parse();
-        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
-        out_expected = [[5, 3], [5.3, 1], [5.75, 1]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[6.5, 1], [6.75, 1], [9, 1], [9.25, 1], [10, 1]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_once(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once req'
-
-        spec.parse();
-
-        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
-        out_expected = [[5, 3], [5.3, 3], [5.75, 3]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[6.5, 5], [6.75, 6]]
-        out_expected = [[6.5, 5], [6.75, 6]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data = [[9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[9, 6], [9.25, 6], [10, 6]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_once_0_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once[0,1] req'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[5, 3]]
-        out_computed_1 = spec.update(['req', in_data_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                                  "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[5.75, 3], [6.3, 2], [6.5, 5], [6.75, 6]]
-        out_computed_2 = spec.update(['req', in_data_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[9, 6]]
-        out_computed_3 = spec.update(['req', in_data_3])
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-    def test_once_1_3(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once[1,3] req'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[6, 3]]
-        out_computed_1 = spec.update(['req', in_data_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                            out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[6.75, 3], [7.5, 5], [7.75, 6]]
-        out_computed_2 = spec.update(['req', in_data_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                            out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[10, 6]]
-        out_computed_3 = spec.update(['req', in_data_3])
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                out_expected_3, out_computed_3))
-
-
-    def test_since_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since gnt'
-
-        spec.parse();
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 3], [7.5, 3]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_since_2(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since gnt'
-
-        spec.parse();
-
-        in_data_1 = [[1, 2], [4.1, 1]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
-        out_expected = [[1.2, 1], [3.7, 2]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data_1 = [[5, 2], [6.1, 1], [6.7, 4]]
-        in_data_2 = []
-        out_expected = [[4.1, 1], [5, 2], [6.1, 1]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-        in_data_1 = [[9.9, 5]]
-        in_data_2 = [[8.1, 6]]
-        out_expected = [[6.7, 3], [7.5, 3]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-
-    def test_historically_1_2_1(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically[1,2] req'
-
-        spec.parse();
-
-        in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[6, 3], [6.3, 1], [7.75, 2], [8.5, 5], [8.75, 6], [10, 5], [10.25, 4]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected, out_computed))
-
-    def test_historically_1_2_2(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically[1,2] req'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[6, 3], [6.3, 2]]
-        out_computed_1 = spec.update(['req', in_data_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[6.75, 1], [8.5, 5], [8.75, 6]]
-        out_computed_2 = spec.update(['req', in_data_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[10, 5], [10.25, 4]]
-        out_computed_3 = spec.update(['req', in_data_3])
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-    def test_addition(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req + gnt'
-
-        spec.parse();
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 3], [3.7, 5], [4.1, 4], [5, 5], [6.1, 4], [6.7, 7], [7.5, 6]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_addition_2(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req + 2'
-
-        spec.parse();
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2]]
-        out_expected = [[1, 4], [4.1, 3]]
-        out_computed = spec.update(['req', in_data_1])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_subtraction(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req - gnt'
-
-        spec.parse();
-
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 1], [3.7, -1], [4.1, -2], [5, -1], [6.1, -2], [6.7, 1], [7.5, 2]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_multiplication(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req * gnt'
-
-        spec.parse();
-
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 2], [3.7, 6], [4.1, 3], [5, 6], [6.1, 3], [6.7, 12], [7.5, 8]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-
-    def test_division(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req / gnt'
-
-        spec.parse();
-        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
-        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
-        out_expected = [[1.2, 2], [3.7, 2. / 3.], [4.1, 1. / 3.], [5, 2. / 3.], [6.1, 1. / 3.], [6.7, 4. / 3.],
-                        [7.5, 2]]
-        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_abs(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = abs(req)'
-
-        spec.parse();
-
-        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_sqrt(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = sqrt(abs(req))'
-
-        spec.parse();
-
-        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[5, math.sqrt(3)], [5.3, math.sqrt(1)], [5.75, math.sqrt(2)], [6.5, math.sqrt(5)], [6.75, math.sqrt(6)], [9, math.sqrt(5)], [9.25, math.sqrt(4)], [10, math.sqrt(2)]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_exp(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = exp(req)'
-
-        spec.parse();
-
-        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[5, math.exp(3)], [5.3, math.exp(-1)], [5.75, math.exp(2)], [6.5, math.exp(-5)], [6.75, math.exp(6)], [9, math.exp(5)], [9.25, math.exp(4)], [10, math.exp(2)]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-    def test_pow(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = pow(3,req)'
-
-        spec.parse();
-
-        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[5, math.pow(3, 3)], [5.3, math.pow(3, -1)], [5.75, math.pow(3, 2)], [6.5, math.pow(3, -5)],
-                        [6.75, math.pow(3, 6)], [9, math.pow(3, 5)], [9.25, math.pow(3, 4)]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected, out_computed))
-
-
-    def test_not(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = not req'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, -3], [5.3, -1]]
-        out_expected_2 = [[5.75, -2], [6.5, -5], [6.75, -6], [9, -5], [9.25, -4]]
-        out_expected_3 = [[10, -2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_until_without_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, [])
-
-    def test_until_with_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_until_0_1_without_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, [])
-
-    def test_until_0_1_with_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_next(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = next req'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_prev(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = prev req'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_rise(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = rise(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_fall(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = fall(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_always_0_1_without_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always[0,1] req'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.STLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_eventually_0_1_without_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually[0,1] req'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.STLNotImplementedException, spec.update, ['req', [0.0, 3.0]])
-
-    def test_eventually_0_1_with_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually[0,1] req'
-
-        spec.parse()
-        spec.pastify()
-
-        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
-        out_expected_1 = [[5, 3]]
-        out_computed_1 = spec.update(['req', in_data_1])
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                                  "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
-        out_expected_2 = [[5.75, 3], [6.3, 2], [6.5, 5], [6.75, 6]]
-        out_computed_2 = spec.update(['req', in_data_2])
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_2, out_computed_2))
-
-        in_data_3 = [[9.25, 4], [10, 2]]
-        out_expected_3 = [[9, 6]]
-        out_computed_3 = spec.update(['req', in_data_3])
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                 out_expected_3, out_computed_3))
-
-    def test_always_0_1_with_pastify(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always[0,1] req'
-
-        spec.parse();
-        spec.pastify()
-
-        in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
-        out_expected = [[5, 3], [5.3, 1], [6.75, 2], [7.5, 5], [7.75, 6], [9, 5], [9.25, 4]]
-        out_computed = spec.update(['req', in_data])
-
-        self.assertListEqual(out_expected, out_computed,
-                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected, out_computed))
-
-
-    def test_predicate_leq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req <= 2'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, -1]]
-        out_expected_2 = [[5.3, 1], [5.75, 0], [6.5, -3], [6.75, -4], [9, -3]]
-        out_expected_3 = [[9.25, -2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_predicate_less(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req < 2'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, -1]]
-        out_expected_2 = [[5.3, 1], [5.75, 0], [6.5, -3], [6.75, -4], [9, -3]]
-        out_expected_3 = [[9.25, -2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_predicate_geq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req >= 2'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, 1]]
-        out_expected_2 = [[5.3, -1], [5.75, 0], [6.5, 3], [6.75, 4], [9, 3]]
-        out_expected_3 = [[9.25, 2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_predicate_greater(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req > 2'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, 1]]
-        out_expected_2 = [[5.3, -1], [5.75, 0], [6.5, 3], [6.75, 4], [9, 3]]
-        out_expected_3 = [[9.25, 2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_predicate_eq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req == 2'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, -1]]
-        out_expected_2 = [[5.3, -1], [5.75, 0], [6.5, -3], [6.75, -4], [9, -3]]
-        out_expected_3 = [[9.25, -2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-    def test_predicate_neq(self):
-        spec = rtamt.STLDenseTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req !== 2'
-
-        spec.parse();
-
-        in_data_1 = [[5, 3], [5.3, 1]]
-        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
-        in_data_3 = [[10, 2]]
-
-        out_expected_1 = [[5, 1]]
-        out_expected_2 = [[5.3, 1], [5.75, 0], [6.5, 3], [6.75, 4], [9, 3]]
-        out_expected_3 = [[9.25, 2]]
-
-        out_computed_1 = spec.update(['req', in_data_1])
-        out_computed_2 = spec.update(['req', in_data_2])
-        out_computed_3 = spec.update(['req', in_data_3])
-
-
-        self.assertListEqual(out_expected_1, out_computed_1,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_1, out_computed_1))
-
-        self.assertListEqual(out_expected_2, out_computed_2,
-                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                             out_expected_2, out_computed_2))
-
-        self.assertListEqual(out_expected_3, out_computed_3,
-                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
-                                  out_expected_3, out_computed_3))
-
-
-
-
-
-
-
-if __name__ == '__main__':
+import unittest
+import math
+import rtamt
+
+class TestStlDenseTimeOnlineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestStlDenseTimeOnlineSpecification, self).__init__(*args, **kwargs)
+
+    def test_and_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        in_data_1_1 = [[2, 2], [3.3, 3], [5.7, 4]]
+        in_data_2_1 = [[2.5, 5], [4.7, 6]]
+
+        in_data_1_2 = []
+        in_data_2_2 = [[5.7, 1]]
+
+        out_expected_1 = [[2.5, 2], [3.3, 3]]
+        out_expected_2 = [[4.7, 3]]
+
+        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
+        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_2, out_computed_2))
+
+    def test_and_2(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        in_data_1_1 = [[2, 2]]
+        in_data_2_1 = [[2, 1]]
+
+        out_expected_1 = []
+        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        in_data_1_2 = [[3.3, 3]]
+        in_data_2_2 = [[3.3, 5]]
+
+        out_expected_2 = [[2, 1]]
+        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_2, out_computed_2))
+
+        in_data_1_3 = [[4.7, 5]]
+        in_data_2_3 = [[4.7, 2]]
+
+        out_expected_3 = [[3.3, 3]]
+        out_computed_3 = spec.update(['req', in_data_1_3], ['gnt', in_data_2_3])
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 2nd example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_and_3(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
+        in_data_2_1 = [[1.2, 1]]
+        out_expected_1 = []
+        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        in_data_1_2 = []
+        in_data_2_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
+        out_expected_2 = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2]]
+        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_2, out_computed_2))
+
+        in_data_1_3 = [[6.7, 4], [9.9, 5]]
+        in_data_2_3 = [[8.1, 6]]
+        out_expected_3 = [[6.1, 1], [6.7, 3], [7.5, 2]]
+        out_computed_3 = spec.update(['req', in_data_1_3], ['gnt', in_data_2_3])
+
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_or(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req or gnt'
+
+        spec.parse()
+
+        in_data_1_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1]]
+        in_data_2_1 = [[1.2, 1]]
+        out_expected_1 = []
+        out_computed_1 = spec.update(['req', in_data_1_1], ['gnt', in_data_2_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_1, out_computed_1))
+
+        in_data_1_2 = []
+        in_data_2_2 = [[3.7, 3], [7.5, 2]]
+        out_expected_2 = [[1.2, 2], [3.7, 3]]
+        out_computed_2 = spec.update(['req', in_data_1_2], ['gnt', in_data_2_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_1_3 = [[6.7, 4], [9.9, 5]]
+        in_data_2_3 = [[8.1, 6]]
+        out_expected_3 = [[6.1, 3], [6.7, 4]]
+        out_computed_3 = spec.update(['req', in_data_1_3], ['gnt', in_data_2_3])
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 6th example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+
+    def test_iff(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req iff gnt'
+
+        spec.parse()
+
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, -1], [4.1, -2], [5, -1], [6.1, -2], [6.7, -1], [7.5, -2]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_xor(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req xor gnt'
+
+        spec.parse()
+
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [4.1, 2], [5, 1], [6.1, 2], [6.7, 1], [7.5, 2]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+
+    def test_implies(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req -> gnt'
+
+        spec.parse()
+
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [3.7, 3], [7.5, 2]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_always_without_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, [])
+
+    def test_always_with_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+
+    def test_historically(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically req'
+
+        spec.parse()
+        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
+        out_expected = [[5, 3], [5.3, 1], [5.75, 1]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[6.5, 1], [6.75, 1], [9, 1], [9.25, 1], [10, 1]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_once(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once req'
+
+        spec.parse()
+
+        in_data = [[5, 3], [5.3, 1], [5.75, 2]]
+        out_expected = [[5, 3], [5.3, 3], [5.75, 3]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[6.5, 5], [6.75, 6]]
+        out_expected = [[6.5, 5], [6.75, 6]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data = [[9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[9, 6], [9.25, 6], [10, 6]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_once_0_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[0,1] req'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[5, 3]]
+        out_computed_1 = spec.update(['req', in_data_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                                  "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[5.75, 3], [6.3, 2], [6.5, 5], [6.75, 6]]
+        out_computed_2 = spec.update(['req', in_data_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[9, 6]]
+        out_computed_3 = spec.update(['req', in_data_3])
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+    def test_once_1_3(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[1,3] req'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[6, 3]]
+        out_computed_1 = spec.update(['req', in_data_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                            out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[6.75, 3], [7.5, 5], [7.75, 6]]
+        out_computed_2 = spec.update(['req', in_data_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                            out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[10, 6]]
+        out_computed_3 = spec.update(['req', in_data_3])
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                            "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                out_expected_3, out_computed_3))
+
+
+    def test_since_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since gnt'
+
+        spec.parse()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [3.7, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 3], [7.5, 3]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_since_2(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since gnt'
+
+        spec.parse()
+
+        in_data_1 = [[1, 2], [4.1, 1]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2]]
+        out_expected = [[1.2, 1], [3.7, 2]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data_1 = [[5, 2], [6.1, 1], [6.7, 4]]
+        in_data_2 = []
+        out_expected = [[4.1, 1], [5, 2], [6.1, 1]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+        in_data_1 = [[9.9, 5]]
+        in_data_2 = [[8.1, 6]]
+        out_expected = [[6.7, 3], [7.5, 3]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 3d example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+
+    def test_historically_1_2_1(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[1,2] req'
+
+        spec.parse()
+
+        in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[6, 3], [6.3, 1], [7.75, 2], [8.5, 5], [8.75, 6], [10, 5], [10.25, 4]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected, out_computed))
+
+    def test_historically_1_2_2(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[1,2] req'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[6, 3], [6.3, 2]]
+        out_computed_1 = spec.update(['req', in_data_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[6.75, 1], [8.5, 5], [8.75, 6]]
+        out_computed_2 = spec.update(['req', in_data_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[10, 5], [10.25, 4]]
+        out_computed_3 = spec.update(['req', in_data_3])
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+    def test_addition(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req + gnt'
+
+        spec.parse()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 3], [3.7, 5], [4.1, 4], [5, 5], [6.1, 4], [6.7, 7], [7.5, 6]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_addition_2(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req + 2'
+
+        spec.parse()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2]]
+        out_expected = [[1, 4], [4.1, 3]]
+        out_computed = spec.update(['req', in_data_1])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_subtraction(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req - gnt'
+
+        spec.parse()
+
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 1], [3.7, -1], [4.1, -2], [5, -1], [6.1, -2], [6.7, 1], [7.5, 2]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_multiplication(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req * gnt'
+
+        spec.parse()
+
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 2], [3.7, 6], [4.1, 3], [5, 6], [6.1, 3], [6.7, 12], [7.5, 8]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+
+    def test_division(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req / gnt'
+
+        spec.parse()
+        in_data_1 = [[1, 2], [4.1, 1], [5, 2], [6.1, 1], [6.7, 4], [9.9, 5]]
+        in_data_2 = [[1.2, 1], [3.7, 3], [7.5, 2], [8.1, 6]]
+        out_expected = [[1.2, 2], [3.7, 2. / 3.], [4.1, 1. / 3.], [5, 2. / 3.], [6.1, 1. / 3.], [6.7, 4. / 3.],
+                        [7.5, 2]]
+        out_computed = spec.update(['req', in_data_1], ['gnt', in_data_2])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_abs(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = abs(req)'
+
+        spec.parse()
+
+        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_sqrt(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = sqrt(abs(req))'
+
+        spec.parse()
+
+        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[5, math.sqrt(3)], [5.3, math.sqrt(1)], [5.75, math.sqrt(2)], [6.5, math.sqrt(5)], [6.75, math.sqrt(6)], [9, math.sqrt(5)], [9.25, math.sqrt(4)], [10, math.sqrt(2)]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_exp(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = exp(req)'
+
+        spec.parse()
+
+        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[5, math.exp(3)], [5.3, math.exp(-1)], [5.75, math.exp(2)], [6.5, math.exp(-5)], [6.75, math.exp(6)], [9, math.exp(5)], [9.25, math.exp(4)], [10, math.exp(2)]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+    def test_pow(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = pow(3,req)'
+
+        spec.parse()
+
+        in_data = [[5, 3], [5.3, -1], [5.75, 2], [6.5, -5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[5, math.pow(3, 3)], [5.3, math.pow(3, -1)], [5.75, math.pow(3, 2)], [6.5, math.pow(3, -5)],
+                        [6.75, math.pow(3, 6)], [9, math.pow(3, 5)], [9.25, math.pow(3, 4)]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected, out_computed))
+
+
+    def test_not(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = not req'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, -3], [5.3, -1]]
+        out_expected_2 = [[5.75, -2], [6.5, -5], [6.75, -6], [9, -5], [9.25, -4]]
+        out_expected_3 = [[10, -2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_until_without_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, [])
+
+    def test_until_with_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_until_0_1_without_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, [])
+
+    def test_until_0_1_with_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_next(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next req'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_prev(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = prev req'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_rise(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = rise(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_fall(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = fall(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_always_0_1_without_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0,1] req'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_eventually_0_1_without_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0,1] req'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, ['req', [0.0, 3.0]])
+
+    def test_eventually_0_1_with_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0,1] req'
+
+        spec.parse()
+        spec.pastify()
+
+        in_data_1 = [[5, 3], [5.3, 2], [5.75, 1]]
+        out_expected_1 = [[5, 3]]
+        out_computed_1 = spec.update(['req', in_data_1])
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                                  "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        in_data_2 = [[6.5, 5], [6.75, 6], [9, 5]]
+        out_expected_2 = [[5.75, 3], [6.3, 2], [6.5, 5], [6.75, 6]]
+        out_computed_2 = spec.update(['req', in_data_2])
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_2, out_computed_2))
+
+        in_data_3 = [[9.25, 4], [10, 2]]
+        out_expected_3 = [[9, 6]]
+        out_computed_3 = spec.update(['req', in_data_3])
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                 out_expected_3, out_computed_3))
+
+    def test_always_0_1_with_pastify(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0,1] req'
+
+        spec.parse()
+        spec.pastify()
+
+        in_data = [[5, 3], [5.3, 1], [5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4], [10, 2]]
+        out_expected = [[5, 3], [5.3, 1], [6.75, 2], [7.5, 5], [7.75, 6], [9, 5], [9.25, 4]]
+        out_computed = spec.update(['req', in_data])
+
+        self.assertListEqual(out_expected, out_computed,
+                             "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected, out_computed))
+
+
+    def test_predicate_leq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req <= 2'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, -1]]
+        out_expected_2 = [[5.3, 1], [5.75, 0], [6.5, -3], [6.75, -4], [9, -3]]
+        out_expected_3 = [[9.25, -2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_predicate_less(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req < 2'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, -1]]
+        out_expected_2 = [[5.3, 1], [5.75, 0], [6.5, -3], [6.75, -4], [9, -3]]
+        out_expected_3 = [[9.25, -2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_predicate_geq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req >= 2'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, 1]]
+        out_expected_2 = [[5.3, -1], [5.75, 0], [6.5, 3], [6.75, 4], [9, 3]]
+        out_expected_3 = [[9.25, 2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_predicate_greater(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req > 2'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, 1]]
+        out_expected_2 = [[5.3, -1], [5.75, 0], [6.5, 3], [6.75, 4], [9, 3]]
+        out_expected_3 = [[9.25, 2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_predicate_eq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req == 2'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, -1]]
+        out_expected_2 = [[5.3, -1], [5.75, 0], [6.5, -3], [6.75, -4], [9, -3]]
+        out_expected_3 = [[9.25, -2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+    def test_predicate_neq(self):
+        spec = rtamt.StlDenseTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req !== 2'
+
+        spec.parse()
+
+        in_data_1 = [[5, 3], [5.3, 1]]
+        in_data_2 = [[5.75, 2], [6.5, 5], [6.75, 6], [9, 5], [9.25, 4]]
+        in_data_3 = [[10, 2]]
+
+        out_expected_1 = [[5, 1]]
+        out_expected_2 = [[5.3, 1], [5.75, 0], [6.5, 3], [6.75, 4], [9, 3]]
+        out_expected_3 = [[9.25, 2]]
+
+        out_computed_1 = spec.update(['req', in_data_1])
+        out_computed_2 = spec.update(['req', in_data_2])
+        out_computed_3 = spec.update(['req', in_data_3])
+
+
+        self.assertListEqual(out_expected_1, out_computed_1,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_1, out_computed_1))
+
+        self.assertListEqual(out_expected_2, out_computed_2,
+                         "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                             out_expected_2, out_computed_2))
+
+        self.assertListEqual(out_expected_3, out_computed_3,
+                              "Problem with 1st example:\nExpected output: %s\nComputed output: %s" % (
+                                  out_expected_3, out_computed_3))
+
+
+
+
+
+
+
+if __name__ == '__main__':
     unittest.main()
```

### Comparing `rtamt-0.3/tests/python/spec/test_stl_spec_discrete_time_online_evaluation.py` & `rtamt-0.3.5/tests/python/api/test_stl_discrete_time_online_specification.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,836 +1,837 @@
-import unittest
-import math
-import rtamt
-
-class TestSTLSpecDiscreteTimeOnlineEvaluation(unittest.TestCase):
-
-    def __init__(self, *args, **kwargs):
-        super(TestSTLSpecDiscreteTimeOnlineEvaluation, self).__init__(*args, **kwargs)
-        self.left1 = 100
-        self.right1 = 20
-
-        self.left2 = -1
-        self.right2 = -2
-
-        self.left3 = -2
-        self.right3 = 10
-
-        self.left4 = 5
-        self.right4 = 4
-
-        self.left5 = -1
-        self.right5 = -1
-
-    def test_constant(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = 5'
-
-        spec.parse();
-        out1 = spec.update(0, [])
-        out2 = spec.update(1, [])
-
-        self.assertEqual(out1, 5, "input 1")
-        self.assertEqual(out2, 5, "input 2")
-
-    def test_constant_2(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_const('c', 'int', 5)
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = c'
-
-        spec.parse();
-        out1 = spec.update(0, [])
-        out2 = spec.update(1, [])
-
-        self.assertEqual(out1, 5, "input 1")
-        self.assertEqual(out2, 5, "input 2")
-
-    def test_addition(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req + gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 120, "input 1")
-        self.assertEqual(out2, -3, "input 2")
-        self.assertEqual(out3, 8, "input 3")
-        self.assertEqual(out4, 9, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_subtraction(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req - gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_multiplication(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req * gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 2000, "input 1")
-        self.assertEqual(out2, 2, "input 2")
-        self.assertEqual(out3, -20, "input 3")
-        self.assertEqual(out4, 20, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_division(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req / gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 100 / 20, "input 1")
-        self.assertEqual(out2, -1 / -2, "input 2")
-        self.assertEqual(out3, -2 / 10, "input 3")
-        self.assertEqual(out4, 5 / 4, "input 4")
-        self.assertEqual(out5, -1 / -1, "input 5")
-
-    def test_abs(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = abs(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 2, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_sqrt(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = sqrt(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', 2)])
-        out2 = spec.update(1, [('req', 3.3)])
-        out3 = spec.update(2, [('req', 4.5)])
-        out4 = spec.update(3, [('req', 0.1)])
-        out5 = spec.update(4, [('req', 1)])
-
-        self.assertEqual(out1, math.sqrt(2), "input 1")
-        self.assertEqual(out2, math.sqrt(3.3), "input 2")
-        self.assertEqual(out3, math.sqrt(4.5), "input 3")
-        self.assertEqual(out4, math.sqrt(0.1), "input 4")
-        self.assertEqual(out5, math.sqrt(1), "input 5")
-
-    def test_previous(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = prev(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_next_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = next(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_next_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = next(req)'
-
-        spec.parse()
-        spec.pastify()
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_and(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req and gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -2, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_or(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req or gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_iff(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req iff gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_xor(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req xor gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_implies(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req -> gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 4, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_always_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_always_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_eventually_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_eventually_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually(req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_historically(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_once(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, 100, "input 3")
-        self.assertEqual(out4, 100, "input 4")
-        self.assertEqual(out5, 100, "input 5")
-
-    def test_since(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_until_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLNotImplementedException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
-
-    def test_always_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification()
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.LTLPastifyException, spec.pastify)
-
-    def test_eventually_0_1_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually[0,1](req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.STLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_eventually_0_1_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = eventually[0,1](req)'
-
-        spec.parse()
-        spec.pastify()
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_once_0_1(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once[0,1](req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_once_1_2(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = once[1,2](req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, -float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, 100, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 5, "input 5")
-
-    def test_always_0_1_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always[0,1](req)'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.STLNotImplementedException, spec.update, 0, [('req', self.left1)])
-
-    def test_always_0_1_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = always[0,1](req)'
-
-        spec.parse();
-        spec.pastify()
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_historically_0_1(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically[0,1](req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_historically_1_2(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = historically[1,2](req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, float("inf"), "input 1")
-        self.assertEqual(out2, 100, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -2, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_until_0_1_without_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until[0,1] gnt'
-
-        spec.parse()
-
-        self.assertRaises(rtamt.STLNotImplementedException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
-
-    def test_until_1_2_with_pastify(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req until[1,2] gnt'
-
-        spec.parse();
-        spec.pastify();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, 20, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, -2, "input 5")
-
-    def test_since_0_1(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req since[0,1] gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 20, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 10, "input 3")
-        self.assertEqual(out4, 5, "input 4")
-        self.assertEqual(out5, -1, "input 5")
-
-    def test_not(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = not(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, -100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 2, "input 3")
-        self.assertEqual(out4, -5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-    def test_rise(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = rise(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, 100, "input 1")
-        self.assertEqual(out2, -100, "input 2")
-        self.assertEqual(out3, -2, "input 3")
-        self.assertEqual(out4, 2, "input 4")
-        self.assertEqual(out5, -5, "input 5")
-
-    def test_fall(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = fall(req)'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1)])
-        out2 = spec.update(1, [('req', self.left2)])
-        out3 = spec.update(2, [('req', self.left3)])
-        out4 = spec.update(3, [('req', self.left4)])
-        out5 = spec.update(4, [('req', self.left5)])
-
-        self.assertEqual(out1, -100, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -1, "input 3")
-        self.assertEqual(out4, -5, "input 4")
-        self.assertEqual(out5, 1, "input 5")
-
-
-    def test_predicate_leq(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req <= gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_less(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req < gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_geq(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req >= gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_greater(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req > gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_eq(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req == gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, -80, "input 1")
-        self.assertEqual(out2, -1, "input 2")
-        self.assertEqual(out3, -12, "input 3")
-        self.assertEqual(out4, -1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-    def test_predicate_neq(self):
-        spec = rtamt.STLDiscreteTimeSpecification();
-        spec.declare_var('req', 'float')
-        spec.declare_var('gnt', 'float')
-        spec.declare_var('out', 'float')
-        spec.spec = 'out = req !== gnt'
-
-        spec.parse();
-
-        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
-        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
-        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
-        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
-        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
-
-        self.assertEqual(out1, 80, "input 1")
-        self.assertEqual(out2, 1, "input 2")
-        self.assertEqual(out3, 12, "input 3")
-        self.assertEqual(out4, 1, "input 4")
-        self.assertEqual(out5, 0, "input 5")
-
-if __name__ == '__main__':
+import unittest
+import math
+import rtamt
+
+class TestStlDiscreteTimeOnlineSpecification(unittest.TestCase):
+
+    def __init__(self, *args, **kwargs):
+        super(TestStlDiscreteTimeOnlineSpecification, self).__init__(*args, **kwargs)
+        self.left1 = 100
+        self.right1 = 20
+
+        self.left2 = -1
+        self.right2 = -2
+
+        self.left3 = -2
+        self.right3 = 10
+
+        self.left4 = 5
+        self.right4 = 4
+
+        self.left5 = -1
+        self.right5 = -1
+
+    def test_constant(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = 5'
+
+        spec.parse()
+        out1 = spec.update(0, [])
+        out2 = spec.update(1, [])
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+    def test_constant_2(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_const('c', 'int', 5)
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = c'
+
+        spec.parse()
+        out1 = spec.update(0, [])
+        out2 = spec.update(1, [])
+
+        self.assertEqual(out1, 5, "input 1")
+        self.assertEqual(out2, 5, "input 2")
+
+    def test_addition(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req + gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 120, "input 1")
+        self.assertEqual(out2, -3, "input 2")
+        self.assertEqual(out3, 8, "input 3")
+        self.assertEqual(out4, 9, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_subtraction(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req - gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_multiplication(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req * gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 2000, "input 1")
+        self.assertEqual(out2, 2, "input 2")
+        self.assertEqual(out3, -20, "input 3")
+        self.assertEqual(out4, 20, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_division(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req / gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 100 / 20, "input 1")
+        self.assertEqual(out2, -1 / -2, "input 2")
+        self.assertEqual(out3, -2 / 10, "input 3")
+        self.assertEqual(out4, 5 / 4, "input 4")
+        self.assertEqual(out5, -1 / -1, "input 5")
+
+    def test_abs(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = abs(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_sqrt(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = sqrt(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', 2)])
+        out2 = spec.update(1, [('req', 3.3)])
+        out3 = spec.update(2, [('req', 4.5)])
+        out4 = spec.update(3, [('req', 0.1)])
+        out5 = spec.update(4, [('req', 1)])
+
+        self.assertEqual(out1, math.sqrt(2), "input 1")
+        self.assertEqual(out2, math.sqrt(3.3), "input 2")
+        self.assertEqual(out3, math.sqrt(4.5), "input 3")
+        self.assertEqual(out4, math.sqrt(0.1), "input 4")
+        self.assertEqual(out5, math.sqrt(1), "input 5")
+
+    def test_previous(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = prev(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_next_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_next_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = next(req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_and(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req and gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -2, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_or(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req or gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_iff(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.set_var_topic('req', 'rtamt/req')
+        spec.spec = 'out = req iff gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_xor(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req xor gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_implies(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req -> gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 4, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_always_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_always_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_eventually_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_eventually_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually(req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_historically(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_once(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, 100, "input 4")
+        self.assertEqual(out5, 100, "input 5")
+
+    def test_since(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_until_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
+
+    def test_always_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.pastify)
+
+    def test_eventually_0_1_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0,1](req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_eventually_0_1_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = eventually[0,1](req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_once_0_1(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[0,1](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_once_1_2(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = once[1,2](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, 100, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 5, "input 5")
+
+    def test_always_0_1_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0,1](req)'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1)])
+
+    def test_always_0_1_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = always[0,1](req)'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_historically_0_1(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[0,1](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_historically_1_2(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = historically[1,2](req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, float("inf"), "input 1")
+        self.assertEqual(out2, 100, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -2, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_until_0_1_without_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until[0,1] gnt'
+
+        spec.parse()
+
+        self.assertRaises(rtamt.RTAMTException, spec.update, 0, [('req', self.left1), ('gnt', self.right1)])
+
+    def test_until_1_2_with_pastify(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req until[1,2] gnt'
+
+        spec.parse()
+        spec.pastify()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, 20, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, -2, "input 5")
+
+    def test_since_0_1(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req since[0,1] gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 20, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 10, "input 3")
+        self.assertEqual(out4, 5, "input 4")
+        self.assertEqual(out5, -1, "input 5")
+
+    def test_not(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = not(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 2, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+    def test_rise(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = rise(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, 100, "input 1")
+        self.assertEqual(out2, -100, "input 2")
+        self.assertEqual(out3, -2, "input 3")
+        self.assertEqual(out4, 2, "input 4")
+        self.assertEqual(out5, -5, "input 5")
+
+    def test_fall(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = fall(req)'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1)])
+        out2 = spec.update(1, [('req', self.left2)])
+        out3 = spec.update(2, [('req', self.left3)])
+        out4 = spec.update(3, [('req', self.left4)])
+        out5 = spec.update(4, [('req', self.left5)])
+
+        self.assertEqual(out1, -100, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -1, "input 3")
+        self.assertEqual(out4, -5, "input 4")
+        self.assertEqual(out5, 1, "input 5")
+
+
+    def test_predicate_leq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req <= gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_less(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req < gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_geq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req >= gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_greater(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req > gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_eq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req == gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, -80, "input 1")
+        self.assertEqual(out2, -1, "input 2")
+        self.assertEqual(out3, -12, "input 3")
+        self.assertEqual(out4, -1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+    def test_predicate_neq(self):
+        spec = rtamt.StlDiscreteTimeSpecification()
+        spec.declare_var('req', 'float')
+        spec.declare_var('gnt', 'float')
+        spec.declare_var('out', 'float')
+        spec.spec = 'out = req !== gnt'
+
+        spec.parse()
+
+        out1 = spec.update(0, [('req', self.left1), ('gnt', self.right1)])
+        out2 = spec.update(1, [('req', self.left2), ('gnt', self.right2)])
+        out3 = spec.update(2, [('req', self.left3), ('gnt', self.right3)])
+        out4 = spec.update(3, [('req', self.left4), ('gnt', self.right4)])
+        out5 = spec.update(4, [('req', self.left5), ('gnt', self.right5)])
+
+        self.assertEqual(out1, 80, "input 1")
+        self.assertEqual(out2, 1, "input 2")
+        self.assertEqual(out3, 12, "input 3")
+        self.assertEqual(out4, 1, "input 4")
+        self.assertEqual(out5, 0, "input 5")
+
+if __name__ == '__main__':
     unittest.main()
```

