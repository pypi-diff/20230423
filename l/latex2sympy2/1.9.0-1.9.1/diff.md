# Comparing `tmp/latex2sympy2-1.9.0-py3-none-any.whl.zip` & `tmp/latex2sympy2-1.9.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,13 +1,13 @@
-Zip file size: 89878 bytes, number of entries: 35
+Zip file size: 89798 bytes, number of entries: 35
 -rw-rw-rw-  2.0 fat     1698 b- defN 22-Mar-15 06:34 asciimath_printer.py
--rw-rw-rw-  2.0 fat    40465 b- defN 23-Apr-18 17:04 latex2sympy2.py
--rw-rw-rw-  2.0 fat   122308 b- defN 23-Apr-18 17:03 gen/PSLexer.py
--rw-rw-rw-  2.0 fat    14716 b- defN 23-Apr-18 17:03 gen/PSListener.py
--rw-rw-rw-  2.0 fat   272010 b- defN 23-Apr-18 17:03 gen/PSParser.py
+-rw-rw-rw-  2.0 fat    40500 b- defN 23-Apr-23 07:43 latex2sympy2.py
+-rw-rw-rw-  2.0 fat   122711 b- defN 23-Apr-18 17:07 gen/PSLexer.py
+-rw-rw-rw-  2.0 fat    14716 b- defN 23-Apr-18 17:05 gen/PSListener.py
+-rw-rw-rw-  2.0 fat   271559 b- defN 23-Apr-18 17:07 gen/PSParser.py
 -rw-rw-rw-  2.0 fat        0 b- defN 22-Mar-15 07:01 gen/__init__.py
 -rw-rw-rw-  2.0 fat        0 b- defN 22-Mar-15 06:34 tests/__init__.py
 -rw-rw-rw-  2.0 fat      773 b- defN 22-Mar-15 06:34 tests/abs_test.py
 -rw-rw-rw-  2.0 fat     1767 b- defN 22-Mar-15 06:34 tests/all_bad_test.py
 -rw-rw-rw-  2.0 fat    13138 b- defN 22-Mar-15 06:34 tests/all_good_test.py
 -rw-rw-rw-  2.0 fat     2245 b- defN 22-Mar-15 06:34 tests/atom_expr_test.py
 -rw-rw-rw-  2.0 fat      902 b- defN 22-Mar-15 06:34 tests/binomial_test.py
@@ -25,13 +25,13 @@
 -rw-rw-rw-  2.0 fat     3756 b- defN 22-Mar-15 06:34 tests/max_test.py
 -rw-rw-rw-  2.0 fat     3756 b- defN 22-Mar-15 06:34 tests/min_test.py
 -rw-rw-rw-  2.0 fat     3261 b- defN 22-Mar-15 06:34 tests/mod_test.py
 -rw-rw-rw-  2.0 fat      221 b- defN 22-Mar-15 06:34 tests/overline_test.py
 -rw-rw-rw-  2.0 fat      404 b- defN 22-Mar-15 06:34 tests/pi_test.py
 -rw-rw-rw-  2.0 fat      526 b- defN 22-Mar-15 06:34 tests/trig_test.py
 -rw-rw-rw-  2.0 fat     4274 b- defN 22-Mar-15 06:34 tests/variable_test.py
--rw-rw-rw-  2.0 fat     1075 b- defN 23-Apr-18 17:05 latex2sympy2-1.9.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat     6557 b- defN 23-Apr-18 17:05 latex2sympy2-1.9.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-18 17:05 latex2sympy2-1.9.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       41 b- defN 23-Apr-18 17:05 latex2sympy2-1.9.0.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     2680 b- defN 23-Apr-18 17:05 latex2sympy2-1.9.0.dist-info/RECORD
-35 files, 527900 bytes uncompressed, 85696 bytes compressed:  83.8%
+-rw-rw-rw-  2.0 fat     1075 b- defN 23-Apr-23 07:43 latex2sympy2-1.9.1.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat     6557 b- defN 23-Apr-23 07:43 latex2sympy2-1.9.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Apr-23 07:43 latex2sympy2-1.9.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       41 b- defN 23-Apr-23 07:43 latex2sympy2-1.9.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     2680 b- defN 23-Apr-23 07:43 latex2sympy2-1.9.1.dist-info/RECORD
+35 files, 527887 bytes uncompressed, 85616 bytes compressed:  83.8%
```

## zipnote {}

```diff
@@ -84,23 +84,23 @@
 
 Filename: tests/trig_test.py
 Comment: 
 
 Filename: tests/variable_test.py
 Comment: 
 
-Filename: latex2sympy2-1.9.0.dist-info/LICENSE.txt
+Filename: latex2sympy2-1.9.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: latex2sympy2-1.9.0.dist-info/METADATA
+Filename: latex2sympy2-1.9.1.dist-info/METADATA
 Comment: 
 
-Filename: latex2sympy2-1.9.0.dist-info/WHEEL
+Filename: latex2sympy2-1.9.1.dist-info/WHEEL
 Comment: 
 
-Filename: latex2sympy2-1.9.0.dist-info/top_level.txt
+Filename: latex2sympy2-1.9.1.dist-info/top_level.txt
 Comment: 
 
-Filename: latex2sympy2-1.9.0.dist-info/RECORD
+Filename: latex2sympy2-1.9.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## latex2sympy2.py

```diff
@@ -470,18 +470,18 @@
             # multiply by next
             rh = convert_postfix_list(arr, i + 1)
 
             if res.is_Matrix or rh.is_Matrix:
                 return mat_mul_flat(res, rh)
             else:
                 return mul_flat(res, rh)
-    elif isinstance(res, tuple) or isinstance(res, list) or isinstance(res, dict):
+    elif ((isinstance(res, tuple) or isinstance(res, list)) and res[0] != 'derivative') or isinstance(res, dict):
         return res
     else:  # must be derivative
-        wrt = res[0]
+        wrt = res[1]
         if i == len(arr) - 1:
             raise Exception("Expected expression for derivative")
         else:
             expr = convert_postfix_list(arr, i + 1)
             return sympy.Derivative(expr, wrt)
 
 
@@ -758,19 +758,19 @@
             wrt = wrt[1:]
 
     if diff_op or partial_op:
         wrt = sympy.Symbol(wrt, real=is_real)
         if (diff_op and frac.upper.start == frac.upper.stop and
             frac.upper.start.type == PSLexer.LETTER_NO_E and
                 frac.upper.start.text == 'd'):
-            return [wrt]
+            return ('derivative', wrt)
         elif (partial_op and frac.upper.start == frac.upper.stop and
               frac.upper.start.type == PSLexer.SYMBOL and
               frac.upper.start.text == '\\partial'):
-            return [wrt]
+            return ('derivative', wrt)
         upper_text = rule2text(frac.upper)
 
         expr_top = None
         if diff_op and upper_text.startswith('d'):
             expr_top = latex2sympy(upper_text[1:])
         elif partial_op and frac.upper.start.text == '\\partial':
             expr_top = latex2sympy(upper_text[len('\\partial'):])
@@ -1145,15 +1145,15 @@
     var[str(lh)] = rh
 
 if __name__ == '__main__':
     # latex2latex(r'A_1=\begin{bmatrix}1 & 2 & 3 & 4 \\ 5 & 6 & 7 & 8\end{bmatrix}')
     # latex2latex(r'b_1=\begin{bmatrix}1 \\ 2 \\ 3 \\ 4\end{bmatrix}')
     # tex = r"(x+2)|_{x=y+1}"
     # tex = r"\operatorname{zeros}(3)"
-    tex = r"\operatorname{rows}(\begin{bmatrix}1 & 2 \\ 3 & 4\end{bmatrix})"
+    tex = r"\frac{\mathrm{d}}{\mathrm{d}x}(x^{2}+x)"
     # print("latex2latex:", latex2latex(tex))
     math = latex2sympy(tex)
     # math = math.subs(variances)
     print("latex:", tex)
     # print("var:", variances)
     print("raw_math:", math)
     # print("math:", latex(math.doit()))
```

## gen/PSLexer.py

```diff
@@ -2,15 +2,14 @@
 # encoding: utf-8
 from __future__ import print_function
 from antlr4 import *
 from io import StringIO
 import sys
 
 
-
 def serializedATN():
     with StringIO() as buf:
         buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\2")
         buf.write(u"\u00c4\u0aed\b\1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6")
         buf.write(u"\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t")
         buf.write(u"\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4")
         buf.write(u"\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27")
@@ -1384,15 +1383,15 @@
         return buf.getvalue()
 
 
 class PSLexer(Lexer):
 
     atn = ATNDeserializer().deserialize(serializedATN())
 
-    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]
+    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]
 
     T__0 = 1
     T__1 = 2
     T__2 = 3
     T__3 = 4
     T__4 = 5
     T__5 = 6
@@ -1581,141 +1580,139 @@
     BANG = 189
     PERCENT_NUMBER = 190
     GREEK_CMD = 191
     OTHER_SYMBOL_CMD = 192
     SYMBOL = 193
     VARIABLE = 194
 
-    channelNames = [ u"DEFAULT_TOKEN_CHANNEL", u"HIDDEN" ]
+    channelNames = [u"DEFAULT_TOKEN_CHANNEL", u"HIDDEN"]
 
-    modeNames = [ u"DEFAULT_MODE" ]
+    modeNames = [u"DEFAULT_MODE"]
 
-    literalNames = [ u"<INVALID>",
-            u"'\\acute'", u"'\\bar'", u"'\\overline'", u"'\\breve'", u"'\\check'", 
-            u"'\\widecheck'", u"'\\dot'", u"'\\ddot'", u"'\\grave'", u"'\\hat'", 
-            u"'\\tilde'", u"'\\widetilde'", u"'\\vec'", u"'\\overrightarrow'", 
-            u"'\\bm'", u"'\\boldsymbol'", u"'\\text'", u"'\\textit'", u"'\\mathbb'", 
-            u"'\\mathbin'", u"'\\mathbf'", u"'\\mathcal'", u"'\\mathclap'", 
-            u"'\\mathclose'", u"'\\mathellipsis'", u"'\\mathfrak'", u"'\\mathinner'", 
-            u"'\\mathnormal'", u"'\\mathop'", u"'\\mathopen'", u"'\\mathord'", 
-            u"'\\mathpunct'", u"'\\mathrel'", u"'\\mathring'", u"'\\mathrlap'", 
-            u"'\\mathrm'", u"'\\mathscr'", u"'\\mathsf'", u"'\\mathsterling'", 
-            u"'\\mathtt'", u"'^T'", u"'^{T}'", u"'^{\\top}'", u"'''", u"'\\$'", 
-            u"'+'", u"'-'", u"'*'", u"'('", u"')'", u"'\\lgroup'", u"'\\rgroup'", 
-            u"'{'", u"'}'", u"'\\{'", u"'\\}'", u"'\\lbrace'", u"'\\rbrace'", 
-            u"'['", u"']'", u"'\\lbrack'", u"'\\rbrack'", u"'|'", u"'\\lvert'", 
-            u"'\\rvert'", u"'\\vert'", u"'\\|'", u"'\\lfloor'", u"'\\rfloor'", 
-            u"'\\llcorner'", u"'\\lrcorner'", u"'\\lceil'", u"'\\rceil'", 
-            u"'\\ulcorner'", u"'\\urcorner'", u"'\\left'", u"'\\right'", 
-            u"'\\mleft'", u"'\\mright'", u"'\\lim'", u"'\\int'", u"'\\sum'", 
-            u"'\\prod'", u"'\\log'", u"'\\ln'", u"'\\exp'", u"'\\sin'", 
-            u"'\\cos'", u"'\\tan'", u"'\\csc'", u"'\\sec'", u"'\\cot'", 
-            u"'\\arcsin'", u"'\\arccos'", u"'\\arctan'", u"'\\arccsc'", 
-            u"'\\arcsec'", u"'\\arccot'", u"'\\sinh'", u"'\\cosh'", u"'\\tanh'", 
-            u"'\\arsinh'", u"'\\arcosh'", u"'\\artanh'", u"'\\arcsinh'", 
-            u"'\\arccosh'", u"'\\arctanh'", u"'arsinh'", u"'arcsinh'", u"'arcosh'", 
-            u"'arccosh'", u"'artanh'", u"'arctanh'", u"'gcd'", u"'lcm'", 
-            u"'floor'", u"'ceil'", u"'\\sqrt'", u"'\\gcd'", u"'\\lcm'", 
-            u"'\\floor'", u"'\\ceil'", u"'\\max'", u"'\\min'", u"'\\det'", 
-            u"'eye'", u"'zeros'", u"'ones'", u"'cols'", u"'rows'", u"'diag'", 
-            u"'norm'", u"'rank'", u"'rref'", u"'hstack'", u"'vstack'", u"'nullspace'", 
-            u"'\\times'", u"'\\cdot'", u"'\\div'", u"'\\frac'", u"'\\choose'", 
-            u"'\\mod'", u"'\\mathit'", u"'\\operatorname'", u"'matrix'", 
-            u"'pmatrix'", u"'bmatrix'", u"'vmatrix'", u"'&'", u"'\\\\'", 
-            u"'_'", u"'^'", u"':'", u"';'", u"','", u"'.'", u"'E'", u"'\\in'", 
-            u"'='", u"'<'", u"'>'", u"'!'" ]
+    literalNames = [u"<INVALID>",
+                    u"'\\acute'", u"'\\bar'", u"'\\overline'", u"'\\breve'", u"'\\check'",
+                    u"'\\widecheck'", u"'\\dot'", u"'\\ddot'", u"'\\grave'", u"'\\hat'",
+                    u"'\\tilde'", u"'\\widetilde'", u"'\\vec'", u"'\\overrightarrow'",
+                    u"'\\bm'", u"'\\boldsymbol'", u"'\\text'", u"'\\textit'", u"'\\mathbb'",
+                    u"'\\mathbin'", u"'\\mathbf'", u"'\\mathcal'", u"'\\mathclap'",
+                    u"'\\mathclose'", u"'\\mathellipsis'", u"'\\mathfrak'", u"'\\mathinner'",
+                    u"'\\mathnormal'", u"'\\mathop'", u"'\\mathopen'", u"'\\mathord'",
+                    u"'\\mathpunct'", u"'\\mathrel'", u"'\\mathring'", u"'\\mathrlap'",
+                    u"'\\mathrm'", u"'\\mathscr'", u"'\\mathsf'", u"'\\mathsterling'",
+                    u"'\\mathtt'", u"'^T'", u"'^{T}'", u"'^{\\top}'", u"'''", u"'\\$'",
+                    u"'+'", u"'-'", u"'*'", u"'('", u"')'", u"'\\lgroup'", u"'\\rgroup'",
+                    u"'{'", u"'}'", u"'\\{'", u"'\\}'", u"'\\lbrace'", u"'\\rbrace'",
+                    u"'['", u"']'", u"'\\lbrack'", u"'\\rbrack'", u"'|'", u"'\\lvert'",
+                    u"'\\rvert'", u"'\\vert'", u"'\\|'", u"'\\lfloor'", u"'\\rfloor'",
+                    u"'\\llcorner'", u"'\\lrcorner'", u"'\\lceil'", u"'\\rceil'",
+                    u"'\\ulcorner'", u"'\\urcorner'", u"'\\left'", u"'\\right'",
+                    u"'\\mleft'", u"'\\mright'", u"'\\lim'", u"'\\int'", u"'\\sum'",
+                    u"'\\prod'", u"'\\log'", u"'\\ln'", u"'\\exp'", u"'\\sin'",
+                    u"'\\cos'", u"'\\tan'", u"'\\csc'", u"'\\sec'", u"'\\cot'",
+                    u"'\\arcsin'", u"'\\arccos'", u"'\\arctan'", u"'\\arccsc'",
+                    u"'\\arcsec'", u"'\\arccot'", u"'\\sinh'", u"'\\cosh'", u"'\\tanh'",
+                    u"'\\arsinh'", u"'\\arcosh'", u"'\\artanh'", u"'\\arcsinh'",
+                    u"'\\arccosh'", u"'\\arctanh'", u"'arsinh'", u"'arcsinh'", u"'arcosh'",
+                    u"'arccosh'", u"'artanh'", u"'arctanh'", u"'gcd'", u"'lcm'",
+                    u"'floor'", u"'ceil'", u"'\\sqrt'", u"'\\gcd'", u"'\\lcm'",
+                    u"'\\floor'", u"'\\ceil'", u"'\\max'", u"'\\min'", u"'\\det'",
+                    u"'eye'", u"'zeros'", u"'ones'", u"'cols'", u"'rows'", u"'diag'",
+                    u"'norm'", u"'rank'", u"'rref'", u"'hstack'", u"'vstack'", u"'nullspace'",
+                    u"'\\times'", u"'\\cdot'", u"'\\div'", u"'\\frac'", u"'\\choose'",
+                    u"'\\mod'", u"'\\mathit'", u"'\\operatorname'", u"'matrix'",
+                    u"'pmatrix'", u"'bmatrix'", u"'vmatrix'", u"'&'", u"'\\\\'",
+                    u"'_'", u"'^'", u"':'", u"';'", u"','", u"'.'", u"'E'", u"'\\in'",
+                    u"'='", u"'<'", u"'>'", u"'!'"]
 
-    symbolicNames = [ u"<INVALID>",
-            u"WS", u"DOLLAR_SIGN", u"ADD", u"SUB", u"MUL", u"DIV", u"L_PAREN", 
-            u"R_PAREN", u"L_GROUP", u"R_GROUP", u"L_BRACE", u"R_BRACE", 
-            u"L_BRACE_VISUAL", u"R_BRACE_VISUAL", u"L_BRACE_CMD", u"R_BRACE_CMD", 
-            u"L_BRACKET", u"R_BRACKET", u"L_BRACK", u"R_BRACK", u"BAR", 
-            u"L_VERT", u"R_VERT", u"VERT", u"NORM", u"L_FLOOR", u"R_FLOOR", 
-            u"LL_CORNER", u"LR_CORNER", u"L_CEIL", u"R_CEIL", u"UL_CORNER", 
-            u"UR_CORNER", u"L_LEFT", u"R_RIGHT", u"ML_LEFT", u"MR_RIGHT", 
-            u"FUNC_LIM", u"LIM_APPROACH_SYM", u"FUNC_INT", u"FUNC_SUM", 
-            u"FUNC_PROD", u"FUNC_LOG", u"FUNC_LN", u"FUNC_EXP", u"FUNC_SIN", 
-            u"FUNC_COS", u"FUNC_TAN", u"FUNC_CSC", u"FUNC_SEC", u"FUNC_COT", 
-            u"FUNC_ARCSIN", u"FUNC_ARCCOS", u"FUNC_ARCTAN", u"FUNC_ARCCSC", 
-            u"FUNC_ARCSEC", u"FUNC_ARCCOT", u"FUNC_SINH", u"FUNC_COSH", 
-            u"FUNC_TANH", u"FUNC_ARSINH", u"FUNC_ARCOSH", u"FUNC_ARTANH", 
-            u"FUNC_ARCSINH", u"FUNC_ARCCOSH", u"FUNC_ARCTANH", u"FUNC_ARSINH_NAME", 
-            u"FUNC_ARCSINH_NAME", u"FUNC_ARCOSH_NAME", u"FUNC_ARCCOSH_NAME", 
-            u"FUNC_ARTANH_NAME", u"FUNC_ARCTANH_NAME", u"FUNC_GCD_NAME", 
-            u"FUNC_LCM_NAME", u"FUNC_FLOOR_NAME", u"FUNC_CEIL_NAME", u"FUNC_SQRT", 
-            u"FUNC_GCD", u"FUNC_LCM", u"FUNC_FLOOR", u"FUNC_CEIL", u"FUNC_MAX", 
-            u"FUNC_MIN", u"FUNC_DET", u"FUNC_EYE_NAME", u"FUNC_ZEROS_NAME", 
-            u"FUNC_ONES_NAME", u"FUNC_COLS_NAME", u"FUNC_ROWS_NAME", u"FUNC_DIAG_NAME", 
-            u"FUNC_NORM_NAME", u"FUNC_RANK_NAME", u"FUNC_TRACE_NAME", u"FUNC_RREF_NAME", 
-            u"FUNC_HSTACK_NAME", u"FUNC_VSTACK_NAME", u"FUNC_ORTHOGONALIZE_NAME", 
-            u"FUNC_NULLSPACE_NAME", u"FUNC_DIAGONALIZE_NAME", u"FUNC_EIGENVALS_NAME", 
-            u"FUNC_EIGENVECTORS_NAME", u"FUNC_SVD_NAME", u"CMD_TIMES", u"CMD_CDOT", 
-            u"CMD_DIV", u"CMD_FRAC", u"CMD_BINOM", u"CMD_CHOOSE", u"CMD_MOD", 
-            u"CMD_MATHIT", u"CMD_OPERATORNAME", u"MATRIX_TYPE_MATRIX", u"MATRIX_TYPE_PMATRIX", 
-            u"MATRIX_TYPE_BMATRIX", u"MATRIX_TYPE_DET", u"MATRIX_TYPES", 
-            u"CMD_MATRIX_START", u"CMD_MATRIX_END", u"CMD_DET_START", u"CMD_DET_END", 
-            u"MATRIX_DEL_COL", u"MATRIX_DEL_ROW", u"UNDERSCORE", u"CARET", 
-            u"COLON", u"SEMICOLON", u"COMMA", u"PERIOD", u"DIFFERENTIAL", 
-            u"EXP_E", u"E_NOTATION_E", u"LETTER_NO_E", u"MATRIX_XRIGHTARROW", 
-            u"TRANSFORM_EXCHANGE", u"NUMBER", u"E_NOTATION", u"IN", u"ASSIGNMENT", 
-            u"EQUAL", u"LT", u"LTE", u"GT", u"GTE", u"UNEQUAL", u"BANG", 
-            u"PERCENT_NUMBER", u"GREEK_CMD", u"OTHER_SYMBOL_CMD", u"SYMBOL", 
-            u"VARIABLE" ]
+    symbolicNames = [u"<INVALID>",
+                     u"WS", u"DOLLAR_SIGN", u"ADD", u"SUB", u"MUL", u"DIV", u"L_PAREN",
+                     u"R_PAREN", u"L_GROUP", u"R_GROUP", u"L_BRACE", u"R_BRACE",
+                     u"L_BRACE_VISUAL", u"R_BRACE_VISUAL", u"L_BRACE_CMD", u"R_BRACE_CMD",
+                     u"L_BRACKET", u"R_BRACKET", u"L_BRACK", u"R_BRACK", u"BAR",
+                     u"L_VERT", u"R_VERT", u"VERT", u"NORM", u"L_FLOOR", u"R_FLOOR",
+                     u"LL_CORNER", u"LR_CORNER", u"L_CEIL", u"R_CEIL", u"UL_CORNER",
+                     u"UR_CORNER", u"L_LEFT", u"R_RIGHT", u"ML_LEFT", u"MR_RIGHT",
+                     u"FUNC_LIM", u"LIM_APPROACH_SYM", u"FUNC_INT", u"FUNC_SUM",
+                     u"FUNC_PROD", u"FUNC_LOG", u"FUNC_LN", u"FUNC_EXP", u"FUNC_SIN",
+                     u"FUNC_COS", u"FUNC_TAN", u"FUNC_CSC", u"FUNC_SEC", u"FUNC_COT",
+                     u"FUNC_ARCSIN", u"FUNC_ARCCOS", u"FUNC_ARCTAN", u"FUNC_ARCCSC",
+                     u"FUNC_ARCSEC", u"FUNC_ARCCOT", u"FUNC_SINH", u"FUNC_COSH",
+                     u"FUNC_TANH", u"FUNC_ARSINH", u"FUNC_ARCOSH", u"FUNC_ARTANH",
+                     u"FUNC_ARCSINH", u"FUNC_ARCCOSH", u"FUNC_ARCTANH", u"FUNC_ARSINH_NAME",
+                     u"FUNC_ARCSINH_NAME", u"FUNC_ARCOSH_NAME", u"FUNC_ARCCOSH_NAME",
+                     u"FUNC_ARTANH_NAME", u"FUNC_ARCTANH_NAME", u"FUNC_GCD_NAME",
+                     u"FUNC_LCM_NAME", u"FUNC_FLOOR_NAME", u"FUNC_CEIL_NAME", u"FUNC_SQRT",
+                     u"FUNC_GCD", u"FUNC_LCM", u"FUNC_FLOOR", u"FUNC_CEIL", u"FUNC_MAX",
+                     u"FUNC_MIN", u"FUNC_DET", u"FUNC_EYE_NAME", u"FUNC_ZEROS_NAME",
+                     u"FUNC_ONES_NAME", u"FUNC_COLS_NAME", u"FUNC_ROWS_NAME", u"FUNC_DIAG_NAME",
+                     u"FUNC_NORM_NAME", u"FUNC_RANK_NAME", u"FUNC_TRACE_NAME", u"FUNC_RREF_NAME",
+                     u"FUNC_HSTACK_NAME", u"FUNC_VSTACK_NAME", u"FUNC_ORTHOGONALIZE_NAME",
+                     u"FUNC_NULLSPACE_NAME", u"FUNC_DIAGONALIZE_NAME", u"FUNC_EIGENVALS_NAME",
+                     u"FUNC_EIGENVECTORS_NAME", u"FUNC_SVD_NAME", u"CMD_TIMES", u"CMD_CDOT",
+                     u"CMD_DIV", u"CMD_FRAC", u"CMD_BINOM", u"CMD_CHOOSE", u"CMD_MOD",
+                     u"CMD_MATHIT", u"CMD_OPERATORNAME", u"MATRIX_TYPE_MATRIX", u"MATRIX_TYPE_PMATRIX",
+                     u"MATRIX_TYPE_BMATRIX", u"MATRIX_TYPE_DET", u"MATRIX_TYPES",
+                     u"CMD_MATRIX_START", u"CMD_MATRIX_END", u"CMD_DET_START", u"CMD_DET_END",
+                     u"MATRIX_DEL_COL", u"MATRIX_DEL_ROW", u"UNDERSCORE", u"CARET",
+                     u"COLON", u"SEMICOLON", u"COMMA", u"PERIOD", u"DIFFERENTIAL",
+                     u"EXP_E", u"E_NOTATION_E", u"LETTER_NO_E", u"MATRIX_XRIGHTARROW",
+                     u"TRANSFORM_EXCHANGE", u"NUMBER", u"E_NOTATION", u"IN", u"ASSIGNMENT",
+                     u"EQUAL", u"LT", u"LTE", u"GT", u"GTE", u"UNEQUAL", u"BANG",
+                     u"PERCENT_NUMBER", u"GREEK_CMD", u"OTHER_SYMBOL_CMD", u"SYMBOL",
+                     u"VARIABLE"]
 
-    ruleNames = [ u"T__0", u"T__1", u"T__2", u"T__3", u"T__4", u"T__5", 
-                  u"T__6", u"T__7", u"T__8", u"T__9", u"T__10", u"T__11", 
-                  u"T__12", u"T__13", u"T__14", u"T__15", u"T__16", u"T__17", 
-                  u"T__18", u"T__19", u"T__20", u"T__21", u"T__22", u"T__23", 
-                  u"T__24", u"T__25", u"T__26", u"T__27", u"T__28", u"T__29", 
-                  u"T__30", u"T__31", u"T__32", u"T__33", u"T__34", u"T__35", 
-                  u"T__36", u"T__37", u"T__38", u"T__39", u"T__40", u"T__41", 
-                  u"T__42", u"T__43", u"WS", u"DOLLAR_SIGN", u"ADD", u"SUB", 
-                  u"MUL", u"DIV", u"L_PAREN", u"R_PAREN", u"L_GROUP", u"R_GROUP", 
-                  u"L_BRACE", u"R_BRACE", u"L_BRACE_VISUAL", u"R_BRACE_VISUAL", 
-                  u"L_BRACE_CMD", u"R_BRACE_CMD", u"L_BRACKET", u"R_BRACKET", 
-                  u"L_BRACK", u"R_BRACK", u"BAR", u"L_VERT", u"R_VERT", 
-                  u"VERT", u"NORM", u"L_FLOOR", u"R_FLOOR", u"LL_CORNER", 
-                  u"LR_CORNER", u"L_CEIL", u"R_CEIL", u"UL_CORNER", u"UR_CORNER", 
-                  u"L_LEFT", u"R_RIGHT", u"ML_LEFT", u"MR_RIGHT", u"FUNC_LIM", 
-                  u"LIM_APPROACH_SYM", u"FUNC_INT", u"FUNC_SUM", u"FUNC_PROD", 
-                  u"FUNC_LOG", u"FUNC_LN", u"FUNC_EXP", u"FUNC_SIN", u"FUNC_COS", 
-                  u"FUNC_TAN", u"FUNC_CSC", u"FUNC_SEC", u"FUNC_COT", u"FUNC_ARCSIN", 
-                  u"FUNC_ARCCOS", u"FUNC_ARCTAN", u"FUNC_ARCCSC", u"FUNC_ARCSEC", 
-                  u"FUNC_ARCCOT", u"FUNC_SINH", u"FUNC_COSH", u"FUNC_TANH", 
-                  u"FUNC_ARSINH", u"FUNC_ARCOSH", u"FUNC_ARTANH", u"FUNC_ARCSINH", 
-                  u"FUNC_ARCCOSH", u"FUNC_ARCTANH", u"FUNC_ARSINH_NAME", 
-                  u"FUNC_ARCSINH_NAME", u"FUNC_ARCOSH_NAME", u"FUNC_ARCCOSH_NAME", 
-                  u"FUNC_ARTANH_NAME", u"FUNC_ARCTANH_NAME", u"FUNC_GCD_NAME", 
-                  u"FUNC_LCM_NAME", u"FUNC_FLOOR_NAME", u"FUNC_CEIL_NAME", 
-                  u"FUNC_SQRT", u"FUNC_GCD", u"FUNC_LCM", u"FUNC_FLOOR", 
-                  u"FUNC_CEIL", u"FUNC_MAX", u"FUNC_MIN", u"FUNC_DET", u"FUNC_EYE_NAME", 
-                  u"FUNC_ZEROS_NAME", u"FUNC_ONES_NAME", u"FUNC_COLS_NAME", 
-                  u"FUNC_ROWS_NAME", u"FUNC_DIAG_NAME", u"FUNC_NORM_NAME", 
-                  u"FUNC_RANK_NAME", u"FUNC_TRACE_NAME", u"FUNC_RREF_NAME", 
-                  u"FUNC_HSTACK_NAME", u"FUNC_VSTACK_NAME", u"FUNC_ORTHOGONALIZE_NAME", 
-                  u"FUNC_NULLSPACE_NAME", u"FUNC_DIAGONALIZE_NAME", u"FUNC_EIGENVALS_NAME", 
-                  u"FUNC_EIGENVECTORS_NAME", u"FUNC_SVD_NAME", u"CMD_TIMES", 
-                  u"CMD_CDOT", u"CMD_DIV", u"CMD_FRAC", u"CMD_BINOM", u"CMD_CHOOSE", 
-                  u"CMD_MOD", u"CMD_MATHIT", u"CMD_OPERATORNAME", u"MATRIX_TYPE_MATRIX", 
-                  u"MATRIX_TYPE_PMATRIX", u"MATRIX_TYPE_BMATRIX", u"MATRIX_TYPE_DET", 
-                  u"MATRIX_TYPES", u"CMD_MATRIX_START", u"CMD_MATRIX_END", 
-                  u"CMD_DET_START", u"CMD_DET_END", u"MATRIX_DEL_COL", u"MATRIX_DEL_ROW", 
-                  u"UNDERSCORE", u"CARET", u"COLON", u"SEMICOLON", u"COMMA", 
-                  u"PERIOD", u"WS_CHAR", u"DIFFERENTIAL", u"EXP_E", u"E_NOTATION_E", 
-                  u"LETTER_NO_E", u"LETTER", u"DIGIT", u"MATRIX_XRIGHTARROW", 
-                  u"TRANSFORM_EXCHANGE", u"NUMBER", u"E_NOTATION", u"IN", 
-                  u"ASSIGNMENT", u"EQUAL", u"LT", u"LTE", u"GT", u"GTE", 
-                  u"UNEQUAL", u"BANG", u"PERCENT_SIGN", u"PERCENT_NUMBER", 
-                  u"GREEK_LETTER", u"GREEK_CMD", u"OTHER_SYMBOL", u"OTHER_SYMBOL_CMD", 
-                  u"PI", u"INFTY_CMD", u"PARTIAL_CMD", u"INFTY", u"EMPTYSET", 
-                  u"SYMBOL", u"VARIABLE_CMD", u"VARIABLE_SYMBOL", u"VARIABLE" ]
+    ruleNames = [u"T__0", u"T__1", u"T__2", u"T__3", u"T__4", u"T__5",
+                 u"T__6", u"T__7", u"T__8", u"T__9", u"T__10", u"T__11",
+                 u"T__12", u"T__13", u"T__14", u"T__15", u"T__16", u"T__17",
+                 u"T__18", u"T__19", u"T__20", u"T__21", u"T__22", u"T__23",
+                 u"T__24", u"T__25", u"T__26", u"T__27", u"T__28", u"T__29",
+                 u"T__30", u"T__31", u"T__32", u"T__33", u"T__34", u"T__35",
+                 u"T__36", u"T__37", u"T__38", u"T__39", u"T__40", u"T__41",
+                 u"T__42", u"T__43", u"WS", u"DOLLAR_SIGN", u"ADD", u"SUB",
+                 u"MUL", u"DIV", u"L_PAREN", u"R_PAREN", u"L_GROUP", u"R_GROUP",
+                 u"L_BRACE", u"R_BRACE", u"L_BRACE_VISUAL", u"R_BRACE_VISUAL",
+                 u"L_BRACE_CMD", u"R_BRACE_CMD", u"L_BRACKET", u"R_BRACKET",
+                 u"L_BRACK", u"R_BRACK", u"BAR", u"L_VERT", u"R_VERT",
+                 u"VERT", u"NORM", u"L_FLOOR", u"R_FLOOR", u"LL_CORNER",
+                 u"LR_CORNER", u"L_CEIL", u"R_CEIL", u"UL_CORNER", u"UR_CORNER",
+                 u"L_LEFT", u"R_RIGHT", u"ML_LEFT", u"MR_RIGHT", u"FUNC_LIM",
+                 u"LIM_APPROACH_SYM", u"FUNC_INT", u"FUNC_SUM", u"FUNC_PROD",
+                 u"FUNC_LOG", u"FUNC_LN", u"FUNC_EXP", u"FUNC_SIN", u"FUNC_COS",
+                 u"FUNC_TAN", u"FUNC_CSC", u"FUNC_SEC", u"FUNC_COT", u"FUNC_ARCSIN",
+                 u"FUNC_ARCCOS", u"FUNC_ARCTAN", u"FUNC_ARCCSC", u"FUNC_ARCSEC",
+                 u"FUNC_ARCCOT", u"FUNC_SINH", u"FUNC_COSH", u"FUNC_TANH",
+                 u"FUNC_ARSINH", u"FUNC_ARCOSH", u"FUNC_ARTANH", u"FUNC_ARCSINH",
+                 u"FUNC_ARCCOSH", u"FUNC_ARCTANH", u"FUNC_ARSINH_NAME",
+                 u"FUNC_ARCSINH_NAME", u"FUNC_ARCOSH_NAME", u"FUNC_ARCCOSH_NAME",
+                 u"FUNC_ARTANH_NAME", u"FUNC_ARCTANH_NAME", u"FUNC_GCD_NAME",
+                 u"FUNC_LCM_NAME", u"FUNC_FLOOR_NAME", u"FUNC_CEIL_NAME",
+                 u"FUNC_SQRT", u"FUNC_GCD", u"FUNC_LCM", u"FUNC_FLOOR",
+                 u"FUNC_CEIL", u"FUNC_MAX", u"FUNC_MIN", u"FUNC_DET", u"FUNC_EYE_NAME",
+                 u"FUNC_ZEROS_NAME", u"FUNC_ONES_NAME", u"FUNC_COLS_NAME",
+                 u"FUNC_ROWS_NAME", u"FUNC_DIAG_NAME", u"FUNC_NORM_NAME",
+                 u"FUNC_RANK_NAME", u"FUNC_TRACE_NAME", u"FUNC_RREF_NAME",
+                 u"FUNC_HSTACK_NAME", u"FUNC_VSTACK_NAME", u"FUNC_ORTHOGONALIZE_NAME",
+                 u"FUNC_NULLSPACE_NAME", u"FUNC_DIAGONALIZE_NAME", u"FUNC_EIGENVALS_NAME",
+                 u"FUNC_EIGENVECTORS_NAME", u"FUNC_SVD_NAME", u"CMD_TIMES",
+                 u"CMD_CDOT", u"CMD_DIV", u"CMD_FRAC", u"CMD_BINOM", u"CMD_CHOOSE",
+                 u"CMD_MOD", u"CMD_MATHIT", u"CMD_OPERATORNAME", u"MATRIX_TYPE_MATRIX",
+                 u"MATRIX_TYPE_PMATRIX", u"MATRIX_TYPE_BMATRIX", u"MATRIX_TYPE_DET",
+                 u"MATRIX_TYPES", u"CMD_MATRIX_START", u"CMD_MATRIX_END",
+                 u"CMD_DET_START", u"CMD_DET_END", u"MATRIX_DEL_COL", u"MATRIX_DEL_ROW",
+                 u"UNDERSCORE", u"CARET", u"COLON", u"SEMICOLON", u"COMMA",
+                 u"PERIOD", u"WS_CHAR", u"DIFFERENTIAL", u"EXP_E", u"E_NOTATION_E",
+                 u"LETTER_NO_E", u"LETTER", u"DIGIT", u"MATRIX_XRIGHTARROW",
+                 u"TRANSFORM_EXCHANGE", u"NUMBER", u"E_NOTATION", u"IN",
+                 u"ASSIGNMENT", u"EQUAL", u"LT", u"LTE", u"GT", u"GTE",
+                 u"UNEQUAL", u"BANG", u"PERCENT_SIGN", u"PERCENT_NUMBER",
+                 u"GREEK_LETTER", u"GREEK_CMD", u"OTHER_SYMBOL", u"OTHER_SYMBOL_CMD",
+                 u"PI", u"INFTY_CMD", u"PARTIAL_CMD", u"INFTY", u"EMPTYSET",
+                 u"SYMBOL", u"VARIABLE_CMD", u"VARIABLE_SYMBOL", u"VARIABLE"]
 
     grammarFileName = u"PS.g4"
 
     def __init__(self, input=None, output=sys.stdout):
         super(PSLexer, self).__init__(input, output=output)
         self.checkVersion("4.7.2")
         self._interp = LexerATNSimulator(self, self.atn, self.decisionsToDFA, PredictionContextCache())
         self._actions = None
         self._predicates = None
-
-
```

## gen/PSListener.py

 * *Ordering differences only*

```diff
@@ -1,573 +1,573 @@
 # Generated from PS.g4 by ANTLR 4.7.2
 from antlr4 import *
 
 # This class defines a complete listener for a parse tree produced by PSParser.
+
+
 class PSListener(ParseTreeListener):
 
     # Enter a parse tree produced by PSParser#accent_symbol.
     def enterAccent_symbol(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#accent_symbol.
     def exitAccent_symbol(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#math.
+
     def enterMath(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#math.
     def exitMath(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#transpose.
+
     def enterTranspose(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#transpose.
     def exitTranspose(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#transform_atom.
+
     def enterTransform_atom(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#transform_atom.
     def exitTransform_atom(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#transform_scale.
+
     def enterTransform_scale(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#transform_scale.
     def exitTransform_scale(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#transform_swap.
+
     def enterTransform_swap(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#transform_swap.
     def exitTransform_swap(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#transform_assignment.
+
     def enterTransform_assignment(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#transform_assignment.
     def exitTransform_assignment(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#elementary_transform.
+
     def enterElementary_transform(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#elementary_transform.
     def exitElementary_transform(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#elementary_transforms.
+
     def enterElementary_transforms(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#elementary_transforms.
     def exitElementary_transforms(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#matrix.
+
     def enterMatrix(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#matrix.
     def exitMatrix(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#det.
+
     def enterDet(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#det.
     def exitDet(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#matrix_row.
+
     def enterMatrix_row(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#matrix_row.
     def exitMatrix_row(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#relation.
+
     def enterRelation(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#relation.
     def exitRelation(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#relation_list.
+
     def enterRelation_list(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#relation_list.
     def exitRelation_list(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#relation_list_content.
+
     def enterRelation_list_content(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#relation_list_content.
     def exitRelation_list_content(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#equality.
+
     def enterEquality(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#equality.
     def exitEquality(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#expr.
+
     def enterExpr(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#expr.
     def exitExpr(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#additive.
+
     def enterAdditive(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#additive.
     def exitAdditive(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#mp.
+
     def enterMp(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#mp.
     def exitMp(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#mp_nofunc.
+
     def enterMp_nofunc(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#mp_nofunc.
     def exitMp_nofunc(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#unary.
+
     def enterUnary(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#unary.
     def exitUnary(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#unary_nofunc.
+
     def enterUnary_nofunc(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#unary_nofunc.
     def exitUnary_nofunc(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#postfix.
+
     def enterPostfix(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#postfix.
     def exitPostfix(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#postfix_nofunc.
+
     def enterPostfix_nofunc(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#postfix_nofunc.
     def exitPostfix_nofunc(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#postfix_op.
+
     def enterPostfix_op(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#postfix_op.
     def exitPostfix_op(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#eval_at.
+
     def enterEval_at(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#eval_at.
     def exitEval_at(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#eval_at_sub.
+
     def enterEval_at_sub(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#eval_at_sub.
     def exitEval_at_sub(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#eval_at_sup.
+
     def enterEval_at_sup(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#eval_at_sup.
     def exitEval_at_sup(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#exp.
+
     def enterExp(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#exp.
     def exitExp(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#exp_nofunc.
+
     def enterExp_nofunc(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#exp_nofunc.
     def exitExp_nofunc(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#comp.
+
     def enterComp(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#comp.
     def exitComp(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#comp_nofunc.
+
     def enterComp_nofunc(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#comp_nofunc.
     def exitComp_nofunc(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#group.
+
     def enterGroup(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#group.
     def exitGroup(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#norm_group.
+
     def enterNorm_group(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#norm_group.
     def exitNorm_group(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#abs_group.
+
     def enterAbs_group(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#abs_group.
     def exitAbs_group(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#floor_group.
+
     def enterFloor_group(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#floor_group.
     def exitFloor_group(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#ceil_group.
+
     def enterCeil_group(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#ceil_group.
     def exitCeil_group(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#accent.
+
     def enterAccent(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#accent.
     def exitAccent(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#atom_expr_no_supexpr.
+
     def enterAtom_expr_no_supexpr(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#atom_expr_no_supexpr.
     def exitAtom_expr_no_supexpr(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#atom_expr.
+
     def enterAtom_expr(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#atom_expr.
     def exitAtom_expr(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#atom.
+
     def enterAtom(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#atom.
     def exitAtom(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#mathit.
+
     def enterMathit(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#mathit.
     def exitMathit(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#mathit_text.
+
     def enterMathit_text(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#mathit_text.
     def exitMathit_text(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#frac.
+
     def enterFrac(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#frac.
     def exitFrac(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#binom.
+
     def enterBinom(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#binom.
     def exitBinom(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_normal_functions_single_arg.
+
     def enterFunc_normal_functions_single_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_normal_functions_single_arg.
     def exitFunc_normal_functions_single_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_normal_functions_multi_arg.
+
     def enterFunc_normal_functions_multi_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_normal_functions_multi_arg.
     def exitFunc_normal_functions_multi_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_operator_names_single_arg.
+
     def enterFunc_operator_names_single_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_operator_names_single_arg.
     def exitFunc_operator_names_single_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_operator_names_multi_arg.
+
     def enterFunc_operator_names_multi_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_operator_names_multi_arg.
     def exitFunc_operator_names_multi_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_normal_single_arg.
+
     def enterFunc_normal_single_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_normal_single_arg.
     def exitFunc_normal_single_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_normal_multi_arg.
+
     def enterFunc_normal_multi_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_normal_multi_arg.
     def exitFunc_normal_multi_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func.
+
     def enterFunc(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func.
     def exitFunc(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#args.
+
     def enterArgs(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#args.
     def exitArgs(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_common_args.
+
     def enterFunc_common_args(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_common_args.
     def exitFunc_common_args(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#limit_sub.
+
     def enterLimit_sub(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#limit_sub.
     def exitLimit_sub(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_single_arg.
+
     def enterFunc_single_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_single_arg.
     def exitFunc_single_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_single_arg_noparens.
+
     def enterFunc_single_arg_noparens(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_single_arg_noparens.
     def exitFunc_single_arg_noparens(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_multi_arg.
+
     def enterFunc_multi_arg(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_multi_arg.
     def exitFunc_multi_arg(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#func_multi_arg_noparens.
+
     def enterFunc_multi_arg_noparens(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#func_multi_arg_noparens.
     def exitFunc_multi_arg_noparens(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#subexpr.
+
     def enterSubexpr(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#subexpr.
     def exitSubexpr(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#supexpr.
+
     def enterSupexpr(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#supexpr.
     def exitSupexpr(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#subeq.
+
     def enterSubeq(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#subeq.
     def exitSubeq(self, ctx):
         pass
 
-
     # Enter a parse tree produced by PSParser#supeq.
+
     def enterSupeq(self, ctx):
         pass
 
     # Exit a parse tree produced by PSParser#supeq.
     def exitSupeq(self, ctx):
         pass
-
-
```

## gen/PSParser.py

```diff
@@ -549,121 +549,121 @@
         buf.write(u"\u0355\u0358\u035a\u035d\u0362\u0367\u036c\u0371\u0375")
         buf.write(u"\u0378\u037e\u0382\u0386\u038c\u03a5\u03a8\u03ad\u03b4")
         buf.write(u"\u03c1\u03cb\u03cd\u03d4\u03de\u03e9\u03f6\u03ff\u0403")
         buf.write(u"\u040b")
         return buf.getvalue()
 
 
-class PSParser ( Parser ):
+class PSParser (Parser):
 
     grammarFileName = "PS.g4"
 
     atn = ATNDeserializer().deserialize(serializedATN())
 
-    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]
+    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]
 
     sharedContextCache = PredictionContextCache()
 
-    literalNames = [ u"<INVALID>", u"'\\acute'", u"'\\bar'", u"'\\overline'", 
-                     u"'\\breve'", u"'\\check'", u"'\\widecheck'", u"'\\dot'", 
-                     u"'\\ddot'", u"'\\grave'", u"'\\hat'", u"'\\tilde'", 
-                     u"'\\widetilde'", u"'\\vec'", u"'\\overrightarrow'", 
-                     u"'\\bm'", u"'\\boldsymbol'", u"'\\text'", u"'\\textit'", 
-                     u"'\\mathbb'", u"'\\mathbin'", u"'\\mathbf'", u"'\\mathcal'", 
-                     u"'\\mathclap'", u"'\\mathclose'", u"'\\mathellipsis'", 
-                     u"'\\mathfrak'", u"'\\mathinner'", u"'\\mathnormal'", 
-                     u"'\\mathop'", u"'\\mathopen'", u"'\\mathord'", u"'\\mathpunct'", 
-                     u"'\\mathrel'", u"'\\mathring'", u"'\\mathrlap'", u"'\\mathrm'", 
-                     u"'\\mathscr'", u"'\\mathsf'", u"'\\mathsterling'", 
-                     u"'\\mathtt'", u"'^T'", u"'^{T}'", u"'^{\\top}'", u"'''", 
-                     u"<INVALID>", u"'\\$'", u"'+'", u"'-'", u"'*'", u"<INVALID>", 
-                     u"'('", u"')'", u"'\\lgroup'", u"'\\rgroup'", u"'{'", 
-                     u"'}'", u"'\\{'", u"'\\}'", u"'\\lbrace'", u"'\\rbrace'", 
-                     u"'['", u"']'", u"'\\lbrack'", u"'\\rbrack'", u"'|'", 
-                     u"'\\lvert'", u"'\\rvert'", u"'\\vert'", u"'\\|'", 
-                     u"'\\lfloor'", u"'\\rfloor'", u"'\\llcorner'", u"'\\lrcorner'", 
-                     u"'\\lceil'", u"'\\rceil'", u"'\\ulcorner'", u"'\\urcorner'", 
-                     u"'\\left'", u"'\\right'", u"'\\mleft'", u"'\\mright'", 
-                     u"'\\lim'", u"<INVALID>", u"'\\int'", u"'\\sum'", u"'\\prod'", 
-                     u"'\\log'", u"'\\ln'", u"'\\exp'", u"'\\sin'", u"'\\cos'", 
-                     u"'\\tan'", u"'\\csc'", u"'\\sec'", u"'\\cot'", u"'\\arcsin'", 
-                     u"'\\arccos'", u"'\\arctan'", u"'\\arccsc'", u"'\\arcsec'", 
-                     u"'\\arccot'", u"'\\sinh'", u"'\\cosh'", u"'\\tanh'", 
-                     u"'\\arsinh'", u"'\\arcosh'", u"'\\artanh'", u"'\\arcsinh'", 
-                     u"'\\arccosh'", u"'\\arctanh'", u"'arsinh'", u"'arcsinh'", 
-                     u"'arcosh'", u"'arccosh'", u"'artanh'", u"'arctanh'", 
-                     u"'gcd'", u"'lcm'", u"'floor'", u"'ceil'", u"'\\sqrt'", 
-                     u"'\\gcd'", u"'\\lcm'", u"'\\floor'", u"'\\ceil'", 
-                     u"'\\max'", u"'\\min'", u"'\\det'", u"'eye'", u"'zeros'", 
-                     u"'ones'", u"'cols'", u"'rows'", u"'diag'", u"'norm'", 
-                     u"'rank'", u"<INVALID>", u"'rref'", u"'hstack'", u"'vstack'", 
-                     u"<INVALID>", u"'nullspace'", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"<INVALID>", u"'\\times'", u"'\\cdot'", 
-                     u"'\\div'", u"'\\frac'", u"<INVALID>", u"'\\choose'", 
-                     u"'\\mod'", u"'\\mathit'", u"'\\operatorname'", u"'matrix'", 
-                     u"'pmatrix'", u"'bmatrix'", u"'vmatrix'", u"<INVALID>", 
-                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"'&'", u"'\\\\'", u"'_'", u"'^'", u"':'", u"';'", 
-                     u"','", u"'.'", u"<INVALID>", u"<INVALID>", u"'E'", 
-                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                     u"<INVALID>", u"'\\in'", u"'='", u"<INVALID>", u"'<'", 
-                     u"<INVALID>", u"'>'", u"<INVALID>", u"<INVALID>", u"'!'" ]
-
-    symbolicNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
-                      u"<INVALID>", u"WS", u"DOLLAR_SIGN", u"ADD", u"SUB", 
-                      u"MUL", u"DIV", u"L_PAREN", u"R_PAREN", u"L_GROUP", 
-                      u"R_GROUP", u"L_BRACE", u"R_BRACE", u"L_BRACE_VISUAL", 
-                      u"R_BRACE_VISUAL", u"L_BRACE_CMD", u"R_BRACE_CMD", 
-                      u"L_BRACKET", u"R_BRACKET", u"L_BRACK", u"R_BRACK", 
-                      u"BAR", u"L_VERT", u"R_VERT", u"VERT", u"NORM", u"L_FLOOR", 
-                      u"R_FLOOR", u"LL_CORNER", u"LR_CORNER", u"L_CEIL", 
-                      u"R_CEIL", u"UL_CORNER", u"UR_CORNER", u"L_LEFT", 
-                      u"R_RIGHT", u"ML_LEFT", u"MR_RIGHT", u"FUNC_LIM", 
-                      u"LIM_APPROACH_SYM", u"FUNC_INT", u"FUNC_SUM", u"FUNC_PROD", 
-                      u"FUNC_LOG", u"FUNC_LN", u"FUNC_EXP", u"FUNC_SIN", 
-                      u"FUNC_COS", u"FUNC_TAN", u"FUNC_CSC", u"FUNC_SEC", 
-                      u"FUNC_COT", u"FUNC_ARCSIN", u"FUNC_ARCCOS", u"FUNC_ARCTAN", 
-                      u"FUNC_ARCCSC", u"FUNC_ARCSEC", u"FUNC_ARCCOT", u"FUNC_SINH", 
-                      u"FUNC_COSH", u"FUNC_TANH", u"FUNC_ARSINH", u"FUNC_ARCOSH", 
-                      u"FUNC_ARTANH", u"FUNC_ARCSINH", u"FUNC_ARCCOSH", 
-                      u"FUNC_ARCTANH", u"FUNC_ARSINH_NAME", u"FUNC_ARCSINH_NAME", 
-                      u"FUNC_ARCOSH_NAME", u"FUNC_ARCCOSH_NAME", u"FUNC_ARTANH_NAME", 
-                      u"FUNC_ARCTANH_NAME", u"FUNC_GCD_NAME", u"FUNC_LCM_NAME", 
-                      u"FUNC_FLOOR_NAME", u"FUNC_CEIL_NAME", u"FUNC_SQRT", 
-                      u"FUNC_GCD", u"FUNC_LCM", u"FUNC_FLOOR", u"FUNC_CEIL", 
-                      u"FUNC_MAX", u"FUNC_MIN", u"FUNC_DET", u"FUNC_EYE_NAME", 
-                      u"FUNC_ZEROS_NAME", u"FUNC_ONES_NAME", u"FUNC_COLS_NAME", 
-                      u"FUNC_ROWS_NAME", u"FUNC_DIAG_NAME", u"FUNC_NORM_NAME", 
-                      u"FUNC_RANK_NAME", u"FUNC_TRACE_NAME", u"FUNC_RREF_NAME", 
-                      u"FUNC_HSTACK_NAME", u"FUNC_VSTACK_NAME", u"FUNC_ORTHOGONALIZE_NAME", 
-                      u"FUNC_NULLSPACE_NAME", u"FUNC_DIAGONALIZE_NAME", 
-                      u"FUNC_EIGENVALS_NAME", u"FUNC_EIGENVECTORS_NAME", 
-                      u"FUNC_SVD_NAME", u"CMD_TIMES", u"CMD_CDOT", u"CMD_DIV", 
-                      u"CMD_FRAC", u"CMD_BINOM", u"CMD_CHOOSE", u"CMD_MOD", 
-                      u"CMD_MATHIT", u"CMD_OPERATORNAME", u"MATRIX_TYPE_MATRIX", 
-                      u"MATRIX_TYPE_PMATRIX", u"MATRIX_TYPE_BMATRIX", u"MATRIX_TYPE_DET", 
-                      u"MATRIX_TYPES", u"CMD_MATRIX_START", u"CMD_MATRIX_END", 
-                      u"CMD_DET_START", u"CMD_DET_END", u"MATRIX_DEL_COL", 
-                      u"MATRIX_DEL_ROW", u"UNDERSCORE", u"CARET", u"COLON", 
-                      u"SEMICOLON", u"COMMA", u"PERIOD", u"DIFFERENTIAL", 
-                      u"EXP_E", u"E_NOTATION_E", u"LETTER_NO_E", u"MATRIX_XRIGHTARROW", 
-                      u"TRANSFORM_EXCHANGE", u"NUMBER", u"E_NOTATION", u"IN", 
-                      u"ASSIGNMENT", u"EQUAL", u"LT", u"LTE", u"GT", u"GTE", 
-                      u"UNEQUAL", u"BANG", u"PERCENT_NUMBER", u"GREEK_CMD", 
-                      u"OTHER_SYMBOL_CMD", u"SYMBOL", u"VARIABLE" ]
+    literalNames = [u"<INVALID>", u"'\\acute'", u"'\\bar'", u"'\\overline'",
+                    u"'\\breve'", u"'\\check'", u"'\\widecheck'", u"'\\dot'",
+                    u"'\\ddot'", u"'\\grave'", u"'\\hat'", u"'\\tilde'",
+                    u"'\\widetilde'", u"'\\vec'", u"'\\overrightarrow'",
+                    u"'\\bm'", u"'\\boldsymbol'", u"'\\text'", u"'\\textit'",
+                    u"'\\mathbb'", u"'\\mathbin'", u"'\\mathbf'", u"'\\mathcal'",
+                    u"'\\mathclap'", u"'\\mathclose'", u"'\\mathellipsis'",
+                    u"'\\mathfrak'", u"'\\mathinner'", u"'\\mathnormal'",
+                    u"'\\mathop'", u"'\\mathopen'", u"'\\mathord'", u"'\\mathpunct'",
+                    u"'\\mathrel'", u"'\\mathring'", u"'\\mathrlap'", u"'\\mathrm'",
+                    u"'\\mathscr'", u"'\\mathsf'", u"'\\mathsterling'",
+                    u"'\\mathtt'", u"'^T'", u"'^{T}'", u"'^{\\top}'", u"'''",
+                    u"<INVALID>", u"'\\$'", u"'+'", u"'-'", u"'*'", u"<INVALID>",
+                    u"'('", u"')'", u"'\\lgroup'", u"'\\rgroup'", u"'{'",
+                    u"'}'", u"'\\{'", u"'\\}'", u"'\\lbrace'", u"'\\rbrace'",
+                    u"'['", u"']'", u"'\\lbrack'", u"'\\rbrack'", u"'|'",
+                    u"'\\lvert'", u"'\\rvert'", u"'\\vert'", u"'\\|'",
+                    u"'\\lfloor'", u"'\\rfloor'", u"'\\llcorner'", u"'\\lrcorner'",
+                    u"'\\lceil'", u"'\\rceil'", u"'\\ulcorner'", u"'\\urcorner'",
+                    u"'\\left'", u"'\\right'", u"'\\mleft'", u"'\\mright'",
+                    u"'\\lim'", u"<INVALID>", u"'\\int'", u"'\\sum'", u"'\\prod'",
+                    u"'\\log'", u"'\\ln'", u"'\\exp'", u"'\\sin'", u"'\\cos'",
+                    u"'\\tan'", u"'\\csc'", u"'\\sec'", u"'\\cot'", u"'\\arcsin'",
+                    u"'\\arccos'", u"'\\arctan'", u"'\\arccsc'", u"'\\arcsec'",
+                    u"'\\arccot'", u"'\\sinh'", u"'\\cosh'", u"'\\tanh'",
+                    u"'\\arsinh'", u"'\\arcosh'", u"'\\artanh'", u"'\\arcsinh'",
+                    u"'\\arccosh'", u"'\\arctanh'", u"'arsinh'", u"'arcsinh'",
+                    u"'arcosh'", u"'arccosh'", u"'artanh'", u"'arctanh'",
+                    u"'gcd'", u"'lcm'", u"'floor'", u"'ceil'", u"'\\sqrt'",
+                    u"'\\gcd'", u"'\\lcm'", u"'\\floor'", u"'\\ceil'",
+                    u"'\\max'", u"'\\min'", u"'\\det'", u"'eye'", u"'zeros'",
+                    u"'ones'", u"'cols'", u"'rows'", u"'diag'", u"'norm'",
+                    u"'rank'", u"<INVALID>", u"'rref'", u"'hstack'", u"'vstack'",
+                    u"<INVALID>", u"'nullspace'", u"<INVALID>", u"<INVALID>",
+                    u"<INVALID>", u"<INVALID>", u"'\\times'", u"'\\cdot'",
+                    u"'\\div'", u"'\\frac'", u"<INVALID>", u"'\\choose'",
+                    u"'\\mod'", u"'\\mathit'", u"'\\operatorname'", u"'matrix'",
+                    u"'pmatrix'", u"'bmatrix'", u"'vmatrix'", u"<INVALID>",
+                    u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                    u"'&'", u"'\\\\'", u"'_'", u"'^'", u"':'", u"';'",
+                    u"','", u"'.'", u"<INVALID>", u"<INVALID>", u"'E'",
+                    u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                    u"<INVALID>", u"'\\in'", u"'='", u"<INVALID>", u"'<'",
+                    u"<INVALID>", u"'>'", u"<INVALID>", u"<INVALID>", u"'!'"]
+
+    symbolicNames = [u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>",
+                     u"<INVALID>", u"WS", u"DOLLAR_SIGN", u"ADD", u"SUB",
+                     u"MUL", u"DIV", u"L_PAREN", u"R_PAREN", u"L_GROUP",
+                     u"R_GROUP", u"L_BRACE", u"R_BRACE", u"L_BRACE_VISUAL",
+                     u"R_BRACE_VISUAL", u"L_BRACE_CMD", u"R_BRACE_CMD",
+                     u"L_BRACKET", u"R_BRACKET", u"L_BRACK", u"R_BRACK",
+                     u"BAR", u"L_VERT", u"R_VERT", u"VERT", u"NORM", u"L_FLOOR",
+                     u"R_FLOOR", u"LL_CORNER", u"LR_CORNER", u"L_CEIL",
+                     u"R_CEIL", u"UL_CORNER", u"UR_CORNER", u"L_LEFT",
+                     u"R_RIGHT", u"ML_LEFT", u"MR_RIGHT", u"FUNC_LIM",
+                     u"LIM_APPROACH_SYM", u"FUNC_INT", u"FUNC_SUM", u"FUNC_PROD",
+                     u"FUNC_LOG", u"FUNC_LN", u"FUNC_EXP", u"FUNC_SIN",
+                     u"FUNC_COS", u"FUNC_TAN", u"FUNC_CSC", u"FUNC_SEC",
+                     u"FUNC_COT", u"FUNC_ARCSIN", u"FUNC_ARCCOS", u"FUNC_ARCTAN",
+                     u"FUNC_ARCCSC", u"FUNC_ARCSEC", u"FUNC_ARCCOT", u"FUNC_SINH",
+                     u"FUNC_COSH", u"FUNC_TANH", u"FUNC_ARSINH", u"FUNC_ARCOSH",
+                     u"FUNC_ARTANH", u"FUNC_ARCSINH", u"FUNC_ARCCOSH",
+                     u"FUNC_ARCTANH", u"FUNC_ARSINH_NAME", u"FUNC_ARCSINH_NAME",
+                     u"FUNC_ARCOSH_NAME", u"FUNC_ARCCOSH_NAME", u"FUNC_ARTANH_NAME",
+                     u"FUNC_ARCTANH_NAME", u"FUNC_GCD_NAME", u"FUNC_LCM_NAME",
+                     u"FUNC_FLOOR_NAME", u"FUNC_CEIL_NAME", u"FUNC_SQRT",
+                     u"FUNC_GCD", u"FUNC_LCM", u"FUNC_FLOOR", u"FUNC_CEIL",
+                     u"FUNC_MAX", u"FUNC_MIN", u"FUNC_DET", u"FUNC_EYE_NAME",
+                     u"FUNC_ZEROS_NAME", u"FUNC_ONES_NAME", u"FUNC_COLS_NAME",
+                     u"FUNC_ROWS_NAME", u"FUNC_DIAG_NAME", u"FUNC_NORM_NAME",
+                     u"FUNC_RANK_NAME", u"FUNC_TRACE_NAME", u"FUNC_RREF_NAME",
+                     u"FUNC_HSTACK_NAME", u"FUNC_VSTACK_NAME", u"FUNC_ORTHOGONALIZE_NAME",
+                     u"FUNC_NULLSPACE_NAME", u"FUNC_DIAGONALIZE_NAME",
+                     u"FUNC_EIGENVALS_NAME", u"FUNC_EIGENVECTORS_NAME",
+                     u"FUNC_SVD_NAME", u"CMD_TIMES", u"CMD_CDOT", u"CMD_DIV",
+                     u"CMD_FRAC", u"CMD_BINOM", u"CMD_CHOOSE", u"CMD_MOD",
+                     u"CMD_MATHIT", u"CMD_OPERATORNAME", u"MATRIX_TYPE_MATRIX",
+                     u"MATRIX_TYPE_PMATRIX", u"MATRIX_TYPE_BMATRIX", u"MATRIX_TYPE_DET",
+                     u"MATRIX_TYPES", u"CMD_MATRIX_START", u"CMD_MATRIX_END",
+                     u"CMD_DET_START", u"CMD_DET_END", u"MATRIX_DEL_COL",
+                     u"MATRIX_DEL_ROW", u"UNDERSCORE", u"CARET", u"COLON",
+                     u"SEMICOLON", u"COMMA", u"PERIOD", u"DIFFERENTIAL",
+                     u"EXP_E", u"E_NOTATION_E", u"LETTER_NO_E", u"MATRIX_XRIGHTARROW",
+                     u"TRANSFORM_EXCHANGE", u"NUMBER", u"E_NOTATION", u"IN",
+                     u"ASSIGNMENT", u"EQUAL", u"LT", u"LTE", u"GT", u"GTE",
+                     u"UNEQUAL", u"BANG", u"PERCENT_NUMBER", u"GREEK_CMD",
+                     u"OTHER_SYMBOL_CMD", u"SYMBOL", u"VARIABLE"]
 
     RULE_accent_symbol = 0
     RULE_math = 1
     RULE_transpose = 2
     RULE_transform_atom = 3
     RULE_transform_scale = 4
     RULE_transform_swap = 5
@@ -721,238 +721,235 @@
     RULE_func_multi_arg = 57
     RULE_func_multi_arg_noparens = 58
     RULE_subexpr = 59
     RULE_supexpr = 60
     RULE_subeq = 61
     RULE_supeq = 62
 
-    ruleNames =  [ u"accent_symbol", u"math", u"transpose", u"transform_atom", 
-                   u"transform_scale", u"transform_swap", u"transform_assignment", 
-                   u"elementary_transform", u"elementary_transforms", u"matrix", 
-                   u"det", u"matrix_row", u"relation", u"relation_list", 
-                   u"relation_list_content", u"equality", u"expr", u"additive", 
-                   u"mp", u"mp_nofunc", u"unary", u"unary_nofunc", u"postfix", 
-                   u"postfix_nofunc", u"postfix_op", u"eval_at", u"eval_at_sub", 
-                   u"eval_at_sup", u"exp", u"exp_nofunc", u"comp", u"comp_nofunc", 
-                   u"group", u"norm_group", u"abs_group", u"floor_group", 
-                   u"ceil_group", u"accent", u"atom_expr_no_supexpr", u"atom_expr", 
-                   u"atom", u"mathit", u"mathit_text", u"frac", u"binom", 
-                   u"func_normal_functions_single_arg", u"func_normal_functions_multi_arg", 
-                   u"func_operator_names_single_arg", u"func_operator_names_multi_arg", 
-                   u"func_normal_single_arg", u"func_normal_multi_arg", 
-                   u"func", u"args", u"func_common_args", u"limit_sub", 
-                   u"func_single_arg", u"func_single_arg_noparens", u"func_multi_arg", 
-                   u"func_multi_arg_noparens", u"subexpr", u"supexpr", u"subeq", 
-                   u"supeq" ]
+    ruleNames = [u"accent_symbol", u"math", u"transpose", u"transform_atom",
+                 u"transform_scale", u"transform_swap", u"transform_assignment",
+                 u"elementary_transform", u"elementary_transforms", u"matrix",
+                 u"det", u"matrix_row", u"relation", u"relation_list",
+                 u"relation_list_content", u"equality", u"expr", u"additive",
+                 u"mp", u"mp_nofunc", u"unary", u"unary_nofunc", u"postfix",
+                 u"postfix_nofunc", u"postfix_op", u"eval_at", u"eval_at_sub",
+                 u"eval_at_sup", u"exp", u"exp_nofunc", u"comp", u"comp_nofunc",
+                 u"group", u"norm_group", u"abs_group", u"floor_group",
+                 u"ceil_group", u"accent", u"atom_expr_no_supexpr", u"atom_expr",
+                 u"atom", u"mathit", u"mathit_text", u"frac", u"binom",
+                 u"func_normal_functions_single_arg", u"func_normal_functions_multi_arg",
+                 u"func_operator_names_single_arg", u"func_operator_names_multi_arg",
+                 u"func_normal_single_arg", u"func_normal_multi_arg",
+                 u"func", u"args", u"func_common_args", u"limit_sub",
+                 u"func_single_arg", u"func_single_arg_noparens", u"func_multi_arg",
+                 u"func_multi_arg_noparens", u"subexpr", u"supexpr", u"subeq",
+                 u"supeq"]
 
     EOF = Token.EOF
-    T__0=1
-    T__1=2
-    T__2=3
-    T__3=4
-    T__4=5
-    T__5=6
-    T__6=7
-    T__7=8
-    T__8=9
-    T__9=10
-    T__10=11
-    T__11=12
-    T__12=13
-    T__13=14
-    T__14=15
-    T__15=16
-    T__16=17
-    T__17=18
-    T__18=19
-    T__19=20
-    T__20=21
-    T__21=22
-    T__22=23
-    T__23=24
-    T__24=25
-    T__25=26
-    T__26=27
-    T__27=28
-    T__28=29
-    T__29=30
-    T__30=31
-    T__31=32
-    T__32=33
-    T__33=34
-    T__34=35
-    T__35=36
-    T__36=37
-    T__37=38
-    T__38=39
-    T__39=40
-    T__40=41
-    T__41=42
-    T__42=43
-    T__43=44
-    WS=45
-    DOLLAR_SIGN=46
-    ADD=47
-    SUB=48
-    MUL=49
-    DIV=50
-    L_PAREN=51
-    R_PAREN=52
-    L_GROUP=53
-    R_GROUP=54
-    L_BRACE=55
-    R_BRACE=56
-    L_BRACE_VISUAL=57
-    R_BRACE_VISUAL=58
-    L_BRACE_CMD=59
-    R_BRACE_CMD=60
-    L_BRACKET=61
-    R_BRACKET=62
-    L_BRACK=63
-    R_BRACK=64
-    BAR=65
-    L_VERT=66
-    R_VERT=67
-    VERT=68
-    NORM=69
-    L_FLOOR=70
-    R_FLOOR=71
-    LL_CORNER=72
-    LR_CORNER=73
-    L_CEIL=74
-    R_CEIL=75
-    UL_CORNER=76
-    UR_CORNER=77
-    L_LEFT=78
-    R_RIGHT=79
-    ML_LEFT=80
-    MR_RIGHT=81
-    FUNC_LIM=82
-    LIM_APPROACH_SYM=83
-    FUNC_INT=84
-    FUNC_SUM=85
-    FUNC_PROD=86
-    FUNC_LOG=87
-    FUNC_LN=88
-    FUNC_EXP=89
-    FUNC_SIN=90
-    FUNC_COS=91
-    FUNC_TAN=92
-    FUNC_CSC=93
-    FUNC_SEC=94
-    FUNC_COT=95
-    FUNC_ARCSIN=96
-    FUNC_ARCCOS=97
-    FUNC_ARCTAN=98
-    FUNC_ARCCSC=99
-    FUNC_ARCSEC=100
-    FUNC_ARCCOT=101
-    FUNC_SINH=102
-    FUNC_COSH=103
-    FUNC_TANH=104
-    FUNC_ARSINH=105
-    FUNC_ARCOSH=106
-    FUNC_ARTANH=107
-    FUNC_ARCSINH=108
-    FUNC_ARCCOSH=109
-    FUNC_ARCTANH=110
-    FUNC_ARSINH_NAME=111
-    FUNC_ARCSINH_NAME=112
-    FUNC_ARCOSH_NAME=113
-    FUNC_ARCCOSH_NAME=114
-    FUNC_ARTANH_NAME=115
-    FUNC_ARCTANH_NAME=116
-    FUNC_GCD_NAME=117
-    FUNC_LCM_NAME=118
-    FUNC_FLOOR_NAME=119
-    FUNC_CEIL_NAME=120
-    FUNC_SQRT=121
-    FUNC_GCD=122
-    FUNC_LCM=123
-    FUNC_FLOOR=124
-    FUNC_CEIL=125
-    FUNC_MAX=126
-    FUNC_MIN=127
-    FUNC_DET=128
-    FUNC_EYE_NAME=129
-    FUNC_ZEROS_NAME=130
-    FUNC_ONES_NAME=131
-    FUNC_COLS_NAME=132
-    FUNC_ROWS_NAME=133
-    FUNC_DIAG_NAME=134
-    FUNC_NORM_NAME=135
-    FUNC_RANK_NAME=136
-    FUNC_TRACE_NAME=137
-    FUNC_RREF_NAME=138
-    FUNC_HSTACK_NAME=139
-    FUNC_VSTACK_NAME=140
-    FUNC_ORTHOGONALIZE_NAME=141
-    FUNC_NULLSPACE_NAME=142
-    FUNC_DIAGONALIZE_NAME=143
-    FUNC_EIGENVALS_NAME=144
-    FUNC_EIGENVECTORS_NAME=145
-    FUNC_SVD_NAME=146
-    CMD_TIMES=147
-    CMD_CDOT=148
-    CMD_DIV=149
-    CMD_FRAC=150
-    CMD_BINOM=151
-    CMD_CHOOSE=152
-    CMD_MOD=153
-    CMD_MATHIT=154
-    CMD_OPERATORNAME=155
-    MATRIX_TYPE_MATRIX=156
-    MATRIX_TYPE_PMATRIX=157
-    MATRIX_TYPE_BMATRIX=158
-    MATRIX_TYPE_DET=159
-    MATRIX_TYPES=160
-    CMD_MATRIX_START=161
-    CMD_MATRIX_END=162
-    CMD_DET_START=163
-    CMD_DET_END=164
-    MATRIX_DEL_COL=165
-    MATRIX_DEL_ROW=166
-    UNDERSCORE=167
-    CARET=168
-    COLON=169
-    SEMICOLON=170
-    COMMA=171
-    PERIOD=172
-    DIFFERENTIAL=173
-    EXP_E=174
-    E_NOTATION_E=175
-    LETTER_NO_E=176
-    MATRIX_XRIGHTARROW=177
-    TRANSFORM_EXCHANGE=178
-    NUMBER=179
-    E_NOTATION=180
-    IN=181
-    ASSIGNMENT=182
-    EQUAL=183
-    LT=184
-    LTE=185
-    GT=186
-    GTE=187
-    UNEQUAL=188
-    BANG=189
-    PERCENT_NUMBER=190
-    GREEK_CMD=191
-    OTHER_SYMBOL_CMD=192
-    SYMBOL=193
-    VARIABLE=194
+    T__0 = 1
+    T__1 = 2
+    T__2 = 3
+    T__3 = 4
+    T__4 = 5
+    T__5 = 6
+    T__6 = 7
+    T__7 = 8
+    T__8 = 9
+    T__9 = 10
+    T__10 = 11
+    T__11 = 12
+    T__12 = 13
+    T__13 = 14
+    T__14 = 15
+    T__15 = 16
+    T__16 = 17
+    T__17 = 18
+    T__18 = 19
+    T__19 = 20
+    T__20 = 21
+    T__21 = 22
+    T__22 = 23
+    T__23 = 24
+    T__24 = 25
+    T__25 = 26
+    T__26 = 27
+    T__27 = 28
+    T__28 = 29
+    T__29 = 30
+    T__30 = 31
+    T__31 = 32
+    T__32 = 33
+    T__33 = 34
+    T__34 = 35
+    T__35 = 36
+    T__36 = 37
+    T__37 = 38
+    T__38 = 39
+    T__39 = 40
+    T__40 = 41
+    T__41 = 42
+    T__42 = 43
+    T__43 = 44
+    WS = 45
+    DOLLAR_SIGN = 46
+    ADD = 47
+    SUB = 48
+    MUL = 49
+    DIV = 50
+    L_PAREN = 51
+    R_PAREN = 52
+    L_GROUP = 53
+    R_GROUP = 54
+    L_BRACE = 55
+    R_BRACE = 56
+    L_BRACE_VISUAL = 57
+    R_BRACE_VISUAL = 58
+    L_BRACE_CMD = 59
+    R_BRACE_CMD = 60
+    L_BRACKET = 61
+    R_BRACKET = 62
+    L_BRACK = 63
+    R_BRACK = 64
+    BAR = 65
+    L_VERT = 66
+    R_VERT = 67
+    VERT = 68
+    NORM = 69
+    L_FLOOR = 70
+    R_FLOOR = 71
+    LL_CORNER = 72
+    LR_CORNER = 73
+    L_CEIL = 74
+    R_CEIL = 75
+    UL_CORNER = 76
+    UR_CORNER = 77
+    L_LEFT = 78
+    R_RIGHT = 79
+    ML_LEFT = 80
+    MR_RIGHT = 81
+    FUNC_LIM = 82
+    LIM_APPROACH_SYM = 83
+    FUNC_INT = 84
+    FUNC_SUM = 85
+    FUNC_PROD = 86
+    FUNC_LOG = 87
+    FUNC_LN = 88
+    FUNC_EXP = 89
+    FUNC_SIN = 90
+    FUNC_COS = 91
+    FUNC_TAN = 92
+    FUNC_CSC = 93
+    FUNC_SEC = 94
+    FUNC_COT = 95
+    FUNC_ARCSIN = 96
+    FUNC_ARCCOS = 97
+    FUNC_ARCTAN = 98
+    FUNC_ARCCSC = 99
+    FUNC_ARCSEC = 100
+    FUNC_ARCCOT = 101
+    FUNC_SINH = 102
+    FUNC_COSH = 103
+    FUNC_TANH = 104
+    FUNC_ARSINH = 105
+    FUNC_ARCOSH = 106
+    FUNC_ARTANH = 107
+    FUNC_ARCSINH = 108
+    FUNC_ARCCOSH = 109
+    FUNC_ARCTANH = 110
+    FUNC_ARSINH_NAME = 111
+    FUNC_ARCSINH_NAME = 112
+    FUNC_ARCOSH_NAME = 113
+    FUNC_ARCCOSH_NAME = 114
+    FUNC_ARTANH_NAME = 115
+    FUNC_ARCTANH_NAME = 116
+    FUNC_GCD_NAME = 117
+    FUNC_LCM_NAME = 118
+    FUNC_FLOOR_NAME = 119
+    FUNC_CEIL_NAME = 120
+    FUNC_SQRT = 121
+    FUNC_GCD = 122
+    FUNC_LCM = 123
+    FUNC_FLOOR = 124
+    FUNC_CEIL = 125
+    FUNC_MAX = 126
+    FUNC_MIN = 127
+    FUNC_DET = 128
+    FUNC_EYE_NAME = 129
+    FUNC_ZEROS_NAME = 130
+    FUNC_ONES_NAME = 131
+    FUNC_COLS_NAME = 132
+    FUNC_ROWS_NAME = 133
+    FUNC_DIAG_NAME = 134
+    FUNC_NORM_NAME = 135
+    FUNC_RANK_NAME = 136
+    FUNC_TRACE_NAME = 137
+    FUNC_RREF_NAME = 138
+    FUNC_HSTACK_NAME = 139
+    FUNC_VSTACK_NAME = 140
+    FUNC_ORTHOGONALIZE_NAME = 141
+    FUNC_NULLSPACE_NAME = 142
+    FUNC_DIAGONALIZE_NAME = 143
+    FUNC_EIGENVALS_NAME = 144
+    FUNC_EIGENVECTORS_NAME = 145
+    FUNC_SVD_NAME = 146
+    CMD_TIMES = 147
+    CMD_CDOT = 148
+    CMD_DIV = 149
+    CMD_FRAC = 150
+    CMD_BINOM = 151
+    CMD_CHOOSE = 152
+    CMD_MOD = 153
+    CMD_MATHIT = 154
+    CMD_OPERATORNAME = 155
+    MATRIX_TYPE_MATRIX = 156
+    MATRIX_TYPE_PMATRIX = 157
+    MATRIX_TYPE_BMATRIX = 158
+    MATRIX_TYPE_DET = 159
+    MATRIX_TYPES = 160
+    CMD_MATRIX_START = 161
+    CMD_MATRIX_END = 162
+    CMD_DET_START = 163
+    CMD_DET_END = 164
+    MATRIX_DEL_COL = 165
+    MATRIX_DEL_ROW = 166
+    UNDERSCORE = 167
+    CARET = 168
+    COLON = 169
+    SEMICOLON = 170
+    COMMA = 171
+    PERIOD = 172
+    DIFFERENTIAL = 173
+    EXP_E = 174
+    E_NOTATION_E = 175
+    LETTER_NO_E = 176
+    MATRIX_XRIGHTARROW = 177
+    TRANSFORM_EXCHANGE = 178
+    NUMBER = 179
+    E_NOTATION = 180
+    IN = 181
+    ASSIGNMENT = 182
+    EQUAL = 183
+    LT = 184
+    LTE = 185
+    GT = 186
+    GTE = 187
+    UNEQUAL = 188
+    BANG = 189
+    PERCENT_NUMBER = 190
+    GREEK_CMD = 191
+    OTHER_SYMBOL_CMD = 192
+    SYMBOL = 193
+    VARIABLE = 194
 
     def __init__(self, input, output=sys.stdout):
         super(PSParser, self).__init__(input, output=output)
         self.checkVersion("4.7.2")
         self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
         self._predicates = None
 
-
-
-
     class Accent_symbolContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Accent_symbolContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def CMD_MATHIT(self):
@@ -965,124 +962,109 @@
             if hasattr(listener, "enterAccent_symbol"):
                 listener.enterAccent_symbol(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAccent_symbol"):
                 listener.exitAccent_symbol(self)
 
-
-
-
     def accent_symbol(self):
 
         localctx = PSParser.Accent_symbolContext(self, self._ctx, self.state)
         self.enterRule(localctx, 0, self.RULE_accent_symbol)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 126
             _la = self._input.LA(1)
-            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PSParser.T__0) | (1 << PSParser.T__1) | (1 << PSParser.T__2) | (1 << PSParser.T__3) | (1 << PSParser.T__4) | (1 << PSParser.T__5) | (1 << PSParser.T__6) | (1 << PSParser.T__7) | (1 << PSParser.T__8) | (1 << PSParser.T__9) | (1 << PSParser.T__10) | (1 << PSParser.T__11) | (1 << PSParser.T__12) | (1 << PSParser.T__13) | (1 << PSParser.T__14) | (1 << PSParser.T__15) | (1 << PSParser.T__16) | (1 << PSParser.T__17) | (1 << PSParser.T__18) | (1 << PSParser.T__19) | (1 << PSParser.T__20) | (1 << PSParser.T__21) | (1 << PSParser.T__22) | (1 << PSParser.T__23) | (1 << PSParser.T__24) | (1 << PSParser.T__25) | (1 << PSParser.T__26) | (1 << PSParser.T__27) | (1 << PSParser.T__28) | (1 << PSParser.T__29) | (1 << PSParser.T__30) | (1 << PSParser.T__31) | (1 << PSParser.T__32) | (1 << PSParser.T__33) | (1 << PSParser.T__34) | (1 << PSParser.T__35) | (1 << PSParser.T__36) | (1 << PSParser.T__37) | (1 << PSParser.T__38) | (1 << PSParser.T__39))) != 0) or _la==PSParser.CMD_MATHIT):
+            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PSParser.T__0) | (1 << PSParser.T__1) | (1 << PSParser.T__2) | (1 << PSParser.T__3) | (1 << PSParser.T__4) | (1 << PSParser.T__5) | (1 << PSParser.T__6) | (1 << PSParser.T__7) | (1 << PSParser.T__8) | (1 << PSParser.T__9) | (1 << PSParser.T__10) | (1 << PSParser.T__11) | (1 << PSParser.T__12) | (1 << PSParser.T__13) | (1 << PSParser.T__14) | (1 << PSParser.T__15) | (1 << PSParser.T__16) | (1 << PSParser.T__17) | (1 << PSParser.T__18) | (1 << PSParser.T__19) | (1 << PSParser.T__20) | (1 << PSParser.T__21) | (1 << PSParser.T__22) | (1 << PSParser.T__23) | (1 << PSParser.T__24) | (1 << PSParser.T__25) | (1 << PSParser.T__26) | (1 << PSParser.T__27) | (1 << PSParser.T__28) | (1 << PSParser.T__29) | (1 << PSParser.T__30) | (1 << PSParser.T__31) | (1 << PSParser.T__32) | (1 << PSParser.T__33) | (1 << PSParser.T__34) | (1 << PSParser.T__35) | (1 << PSParser.T__36) | (1 << PSParser.T__37) | (1 << PSParser.T__38) | (1 << PSParser.T__39))) != 0) or _la == PSParser.CMD_MATHIT):
                 self._errHandler.recoverInline(self)
             else:
                 self._errHandler.reportMatch(self)
                 self.consume()
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class MathContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.MathContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def relation(self):
-            return self.getTypedRuleContext(PSParser.RelationContext,0)
-
+            return self.getTypedRuleContext(PSParser.RelationContext, 0)
 
         def relation_list(self):
-            return self.getTypedRuleContext(PSParser.Relation_listContext,0)
-
+            return self.getTypedRuleContext(PSParser.Relation_listContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_math
 
         def enterRule(self, listener):
             if hasattr(listener, "enterMath"):
                 listener.enterMath(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMath"):
                 listener.exitMath(self)
 
-
-
-
     def math(self):
 
         localctx = PSParser.MathContext(self, self._ctx, self.state)
         self.enterRule(localctx, 2, self.RULE_math)
         try:
             self.state = 130
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 0, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 128
                 self.relation(0)
                 pass
 
             elif la_ == 2:
                 self.enterOuterAlt(localctx, 2)
                 self.state = 129
                 self.relation_list()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class TransposeContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.TransposeContext, self).__init__(parent, invokingState)
             self.parser = parser
 
-
         def getRuleIndex(self):
             return PSParser.RULE_transpose
 
         def enterRule(self, listener):
             if hasattr(listener, "enterTranspose"):
                 listener.enterTranspose(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitTranspose"):
                 listener.exitTranspose(self)
 
-
-
-
     def transpose(self):
 
         localctx = PSParser.TransposeContext(self, self._ctx, self.state)
         self.enterRule(localctx, 4, self.RULE_transpose)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 132
             _la = self._input.LA(1)
             if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PSParser.T__40) | (1 << PSParser.T__41) | (1 << PSParser.T__42) | (1 << PSParser.T__43))) != 0)):
                 self._errHandler.recoverInline(self)
             else:
@@ -1092,15 +1074,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Transform_atomContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Transform_atomContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def LETTER_NO_E(self):
@@ -1125,17 +1106,14 @@
             if hasattr(listener, "enterTransform_atom"):
                 listener.enterTransform_atom(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitTransform_atom"):
                 listener.exitTransform_atom(self)
 
-
-
-
     def transform_atom(self):
 
         localctx = PSParser.Transform_atomContext(self, self._ctx, self.state)
         self.enterRule(localctx, 6, self.RULE_transform_atom)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 134
@@ -1164,32 +1142,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Transform_scaleContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Transform_scaleContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def transform_atom(self):
-            return self.getTypedRuleContext(PSParser.Transform_atomContext,0)
-
+            return self.getTypedRuleContext(PSParser.Transform_atomContext, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def group(self):
-            return self.getTypedRuleContext(PSParser.GroupContext,0)
-
+            return self.getTypedRuleContext(PSParser.GroupContext, 0)
 
         def ADD(self):
             return self.getToken(PSParser.ADD, 0)
 
         def SUB(self):
             return self.getToken(PSParser.SUB, 0)
 
@@ -1200,26 +1174,23 @@
             if hasattr(listener, "enterTransform_scale"):
                 listener.enterTransform_scale(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitTransform_scale"):
                 listener.exitTransform_scale(self)
 
-
-
-
     def transform_scale(self):
 
         localctx = PSParser.Transform_scaleContext(self, self._ctx, self.state)
         self.enterRule(localctx, 8, self.RULE_transform_scale)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 146
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 2, self._ctx)
             if la_ == 1:
                 self.state = 142
                 self.expr()
                 pass
 
             elif la_ == 2:
                 self.state = 143
@@ -1232,38 +1203,35 @@
                 pass
 
             elif la_ == 4:
                 self.state = 145
                 self.match(PSParser.SUB)
                 pass
 
-
             self.state = 148
             self.transform_atom()
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Transform_swapContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Transform_swapContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def transform_atom(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Transform_atomContext)
             else:
-                return self.getTypedRuleContext(PSParser.Transform_atomContext,i)
-
+                return self.getTypedRuleContext(PSParser.Transform_atomContext, i)
 
         def TRANSFORM_EXCHANGE(self):
             return self.getToken(PSParser.TRANSFORM_EXCHANGE, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_transform_swap
 
@@ -1271,17 +1239,14 @@
             if hasattr(listener, "enterTransform_swap"):
                 listener.enterTransform_swap(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitTransform_swap"):
                 listener.exitTransform_swap(self)
 
-
-
-
     def transform_swap(self):
 
         localctx = PSParser.Transform_swapContext(self, self._ctx, self.state)
         self.enterRule(localctx, 10, self.RULE_transform_swap)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 150
@@ -1294,43 +1259,37 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Transform_assignmentContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Transform_assignmentContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def transform_atom(self):
-            return self.getTypedRuleContext(PSParser.Transform_atomContext,0)
-
+            return self.getTypedRuleContext(PSParser.Transform_atomContext, 0)
 
         def transform_scale(self):
-            return self.getTypedRuleContext(PSParser.Transform_scaleContext,0)
-
+            return self.getTypedRuleContext(PSParser.Transform_scaleContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_transform_assignment
 
         def enterRule(self, listener):
             if hasattr(listener, "enterTransform_assignment"):
                 listener.enterTransform_assignment(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitTransform_assignment"):
                 listener.exitTransform_assignment(self)
 
-
-
-
     def transform_assignment(self):
 
         localctx = PSParser.Transform_assignmentContext(self, self._ctx, self.state)
         self.enterRule(localctx, 12, self.RULE_transform_assignment)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 154
@@ -1341,55 +1300,48 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Elementary_transformContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Elementary_transformContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def transform_assignment(self):
-            return self.getTypedRuleContext(PSParser.Transform_assignmentContext,0)
-
+            return self.getTypedRuleContext(PSParser.Transform_assignmentContext, 0)
 
         def transform_scale(self):
-            return self.getTypedRuleContext(PSParser.Transform_scaleContext,0)
-
+            return self.getTypedRuleContext(PSParser.Transform_scaleContext, 0)
 
         def transform_swap(self):
-            return self.getTypedRuleContext(PSParser.Transform_swapContext,0)
-
+            return self.getTypedRuleContext(PSParser.Transform_swapContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_elementary_transform
 
         def enterRule(self, listener):
             if hasattr(listener, "enterElementary_transform"):
                 listener.enterElementary_transform(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitElementary_transform"):
                 listener.exitElementary_transform(self)
 
-
-
-
     def elementary_transform(self):
 
         localctx = PSParser.Elementary_transformContext(self, self._ctx, self.state)
         self.enterRule(localctx, 14, self.RULE_elementary_transform)
         try:
             self.state = 160
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 3, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 157
                 self.transform_assignment()
                 pass
 
             elif la_ == 2:
@@ -1400,36 +1352,33 @@
 
             elif la_ == 3:
                 self.enterOuterAlt(localctx, 3)
                 self.state = 159
                 self.transform_swap()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Elementary_transformsContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Elementary_transformsContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def elementary_transform(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Elementary_transformContext)
             else:
-                return self.getTypedRuleContext(PSParser.Elementary_transformContext,i)
-
+                return self.getTypedRuleContext(PSParser.Elementary_transformContext, i)
 
         def COMMA(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.COMMA)
             else:
                 return self.getToken(PSParser.COMMA, i)
 
@@ -1440,30 +1389,27 @@
             if hasattr(listener, "enterElementary_transforms"):
                 listener.enterElementary_transforms(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitElementary_transforms"):
                 listener.exitElementary_transforms(self)
 
-
-
-
     def elementary_transforms(self):
 
         localctx = PSParser.Elementary_transformsContext(self, self._ctx, self.state)
         self.enterRule(localctx, 16, self.RULE_elementary_transforms)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 162
             self.elementary_transform()
             self.state = 167
             self._errHandler.sync(self)
             _la = self._input.LA(1)
-            while _la==PSParser.COMMA:
+            while _la == PSParser.COMMA:
                 self.state = 163
                 self.match(PSParser.COMMA)
                 self.state = 164
                 self.elementary_transform()
                 self.state = 169
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
@@ -1472,30 +1418,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class MatrixContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.MatrixContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def CMD_MATRIX_START(self):
             return self.getToken(PSParser.CMD_MATRIX_START, 0)
 
         def matrix_row(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Matrix_rowContext)
             else:
-                return self.getTypedRuleContext(PSParser.Matrix_rowContext,i)
-
+                return self.getTypedRuleContext(PSParser.Matrix_rowContext, i)
 
         def CMD_MATRIX_END(self):
             return self.getToken(PSParser.CMD_MATRIX_END, 0)
 
         def MATRIX_DEL_ROW(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.MATRIX_DEL_ROW)
@@ -1508,16 +1452,15 @@
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def elementary_transforms(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Elementary_transformsContext)
             else:
-                return self.getTypedRuleContext(PSParser.Elementary_transformsContext,i)
-
+                return self.getTypedRuleContext(PSParser.Elementary_transformsContext, i)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def L_BRACKET(self):
             return self.getToken(PSParser.L_BRACKET, 0)
 
@@ -1531,101 +1474,93 @@
             if hasattr(listener, "enterMatrix"):
                 listener.enterMatrix(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMatrix"):
                 listener.exitMatrix(self)
 
-
-
-
     def matrix(self):
 
         localctx = PSParser.MatrixContext(self, self._ctx, self.state)
         self.enterRule(localctx, 18, self.RULE_matrix)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 170
             self.match(PSParser.CMD_MATRIX_START)
             self.state = 171
             self.matrix_row()
             self.state = 176
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 5, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     self.state = 172
                     self.match(PSParser.MATRIX_DEL_ROW)
                     self.state = 173
-                    self.matrix_row() 
+                    self.matrix_row()
                 self.state = 178
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 5, self._ctx)
 
             self.state = 180
             self._errHandler.sync(self)
             _la = self._input.LA(1)
-            if _la==PSParser.MATRIX_DEL_ROW:
+            if _la == PSParser.MATRIX_DEL_ROW:
                 self.state = 179
                 self.match(PSParser.MATRIX_DEL_ROW)
 
-
             self.state = 182
             self.match(PSParser.CMD_MATRIX_END)
             self.state = 194
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 8, self._ctx)
             if la_ == 1:
                 self.state = 183
                 self.match(PSParser.MATRIX_XRIGHTARROW)
                 self.state = 188
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.L_BRACKET:
+                if _la == PSParser.L_BRACKET:
                     self.state = 184
                     self.match(PSParser.L_BRACKET)
                     self.state = 185
                     self.elementary_transforms()
                     self.state = 186
                     self.match(PSParser.R_BRACKET)
 
-
                 self.state = 190
                 self.match(PSParser.L_BRACE)
                 self.state = 191
                 self.elementary_transforms()
                 self.state = 192
                 self.match(PSParser.R_BRACE)
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class DetContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.DetContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def CMD_DET_START(self):
             return self.getToken(PSParser.CMD_DET_START, 0)
 
         def matrix_row(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Matrix_rowContext)
             else:
-                return self.getTypedRuleContext(PSParser.Matrix_rowContext,i)
-
+                return self.getTypedRuleContext(PSParser.Matrix_rowContext, i)
 
         def CMD_DET_END(self):
             return self.getToken(PSParser.CMD_DET_END, 0)
 
         def MATRIX_DEL_ROW(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.MATRIX_DEL_ROW)
@@ -1639,72 +1574,66 @@
             if hasattr(listener, "enterDet"):
                 listener.enterDet(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitDet"):
                 listener.exitDet(self)
 
-
-
-
     def det(self):
 
         localctx = PSParser.DetContext(self, self._ctx, self.state)
         self.enterRule(localctx, 20, self.RULE_det)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 196
             self.match(PSParser.CMD_DET_START)
             self.state = 197
             self.matrix_row()
             self.state = 202
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 9, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     self.state = 198
                     self.match(PSParser.MATRIX_DEL_ROW)
                     self.state = 199
-                    self.matrix_row() 
+                    self.matrix_row()
                 self.state = 204
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 9, self._ctx)
 
             self.state = 206
             self._errHandler.sync(self)
             _la = self._input.LA(1)
-            if _la==PSParser.MATRIX_DEL_ROW:
+            if _la == PSParser.MATRIX_DEL_ROW:
                 self.state = 205
                 self.match(PSParser.MATRIX_DEL_ROW)
 
-
             self.state = 208
             self.match(PSParser.CMD_DET_END)
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Matrix_rowContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Matrix_rowContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def expr(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.ExprContext)
             else:
-                return self.getTypedRuleContext(PSParser.ExprContext,i)
-
+                return self.getTypedRuleContext(PSParser.ExprContext, i)
 
         def MATRIX_DEL_COL(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.MATRIX_DEL_COL)
             else:
                 return self.getToken(PSParser.MATRIX_DEL_COL, i)
 
@@ -1715,30 +1644,27 @@
             if hasattr(listener, "enterMatrix_row"):
                 listener.enterMatrix_row(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMatrix_row"):
                 listener.exitMatrix_row(self)
 
-
-
-
     def matrix_row(self):
 
         localctx = PSParser.Matrix_rowContext(self, self._ctx, self.state)
         self.enterRule(localctx, 22, self.RULE_matrix_row)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 210
             self.expr()
             self.state = 215
             self._errHandler.sync(self)
             _la = self._input.LA(1)
-            while _la==PSParser.MATRIX_DEL_COL:
+            while _la == PSParser.MATRIX_DEL_COL:
                 self.state = 211
                 self.match(PSParser.MATRIX_DEL_COL)
                 self.state = 212
                 self.expr()
                 self.state = 217
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
@@ -1747,31 +1673,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class RelationContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.RelationContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def relation(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.RelationContext)
             else:
-                return self.getTypedRuleContext(PSParser.RelationContext,i)
-
+                return self.getTypedRuleContext(PSParser.RelationContext, i)
 
         def IN(self):
             return self.getToken(PSParser.IN, 0)
 
         def ASSIGNMENT(self):
             return self.getToken(PSParser.ASSIGNMENT, 0)
 
@@ -1800,34 +1723,32 @@
             if hasattr(listener, "enterRelation"):
                 listener.enterRelation(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitRelation"):
                 listener.exitRelation(self)
 
-
-
     def relation(self, _p=0):
         _parentctx = self._ctx
         _parentState = self.state
         localctx = PSParser.RelationContext(self, self._ctx, _parentState)
         _prevctx = localctx
         _startState = 24
         self.enterRecursionRule(localctx, 24, self.RULE_relation, _p)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 219
             self.expr()
             self._ctx.stop = self._input.LT(-1)
             self.state = 226
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 12, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     if self._parseListeners is not None:
                         self.triggerExitRuleEvent()
                     _prevctx = localctx
                     localctx = PSParser.RelationContext(self, _parentctx, _parentState)
                     self.pushNewRecursionContext(localctx, _startState, self.RULE_relation)
                     self.state = 221
                     if not self.precpred(self._ctx, 2):
@@ -1837,37 +1758,35 @@
                     _la = self._input.LA(1)
                     if not(((((_la - 181)) & ~0x3f) == 0 and ((1 << (_la - 181)) & ((1 << (PSParser.IN - 181)) | (1 << (PSParser.ASSIGNMENT - 181)) | (1 << (PSParser.EQUAL - 181)) | (1 << (PSParser.LT - 181)) | (1 << (PSParser.LTE - 181)) | (1 << (PSParser.GT - 181)) | (1 << (PSParser.GTE - 181)) | (1 << (PSParser.UNEQUAL - 181)))) != 0)):
                         self._errHandler.recoverInline(self)
                     else:
                         self._errHandler.reportMatch(self)
                         self.consume()
                     self.state = 223
-                    self.relation(3) 
+                    self.relation(3)
                 self.state = 228
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 12, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.unrollRecursionContexts(_parentctx)
         return localctx
 
-
     class Relation_listContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Relation_listContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def relation_list_content(self):
-            return self.getTypedRuleContext(PSParser.Relation_list_contentContext,0)
-
+            return self.getTypedRuleContext(PSParser.Relation_list_contentContext, 0)
 
         def L_BRACKET(self):
             return self.getToken(PSParser.L_BRACKET, 0)
 
         def R_BRACKET(self):
             return self.getToken(PSParser.R_BRACKET, 0)
 
@@ -1902,25 +1821,22 @@
             if hasattr(listener, "enterRelation_list"):
                 listener.enterRelation_list(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitRelation_list"):
                 listener.exitRelation_list(self)
 
-
-
-
     def relation_list(self):
 
         localctx = PSParser.Relation_listContext(self, self._ctx, self.state)
         self.enterRule(localctx, 26, self.RULE_relation_list)
         try:
             self.state = 266
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 13, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 229
                 self.relation_list_content()
                 pass
 
             elif la_ == 2:
@@ -2005,36 +1921,33 @@
                 self.relation_list_content()
                 self.state = 263
                 self.match(PSParser.MR_RIGHT)
                 self.state = 264
                 self.match(PSParser.R_BRACE_VISUAL)
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Relation_list_contentContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Relation_list_contentContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def relation(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.RelationContext)
             else:
-                return self.getTypedRuleContext(PSParser.RelationContext,i)
-
+                return self.getTypedRuleContext(PSParser.RelationContext, i)
 
         def COMMA(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.COMMA)
             else:
                 return self.getToken(PSParser.COMMA, i)
 
@@ -2051,38 +1964,35 @@
             if hasattr(listener, "enterRelation_list_content"):
                 listener.enterRelation_list_content(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitRelation_list_content"):
                 listener.exitRelation_list_content(self)
 
-
-
-
     def relation_list_content(self):
 
         localctx = PSParser.Relation_list_contentContext(self, self._ctx, self.state)
         self.enterRule(localctx, 28, self.RULE_relation_list_content)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.state = 288
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 16, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 268
                 self.relation(0)
                 self.state = 269
                 self.match(PSParser.COMMA)
                 self.state = 270
                 self.relation(0)
                 self.state = 275
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                while _la==PSParser.COMMA:
+                while _la == PSParser.COMMA:
                     self.state = 271
                     self.match(PSParser.COMMA)
                     self.state = 272
                     self.relation(0)
                     self.state = 277
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
@@ -2096,47 +2006,44 @@
                 self.state = 279
                 self.match(PSParser.SEMICOLON)
                 self.state = 280
                 self.relation(0)
                 self.state = 285
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                while _la==PSParser.SEMICOLON:
+                while _la == PSParser.SEMICOLON:
                     self.state = 281
                     self.match(PSParser.SEMICOLON)
                     self.state = 282
                     self.relation(0)
                     self.state = 287
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
 
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class EqualityContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.EqualityContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def expr(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.ExprContext)
             else:
-                return self.getTypedRuleContext(PSParser.ExprContext,i)
-
+                return self.getTypedRuleContext(PSParser.ExprContext, i)
 
         def EQUAL(self):
             return self.getToken(PSParser.EQUAL, 0)
 
         def ASSIGNMENT(self):
             return self.getToken(PSParser.ASSIGNMENT, 0)
 
@@ -2147,68 +2054,60 @@
             if hasattr(listener, "enterEquality"):
                 listener.enterEquality(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitEquality"):
                 listener.exitEquality(self)
 
-
-
-
     def equality(self):
 
         localctx = PSParser.EqualityContext(self, self._ctx, self.state)
         self.enterRule(localctx, 30, self.RULE_equality)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 290
             self.expr()
             self.state = 291
             _la = self._input.LA(1)
-            if not(_la==PSParser.ASSIGNMENT or _la==PSParser.EQUAL):
+            if not(_la == PSParser.ASSIGNMENT or _la == PSParser.EQUAL):
                 self._errHandler.recoverInline(self)
             else:
                 self._errHandler.reportMatch(self)
                 self.consume()
             self.state = 292
             self.expr()
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class ExprContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.ExprContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def additive(self):
-            return self.getTypedRuleContext(PSParser.AdditiveContext,0)
-
+            return self.getTypedRuleContext(PSParser.AdditiveContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_expr
 
         def enterRule(self, listener):
             if hasattr(listener, "enterExpr"):
                 listener.enterExpr(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitExpr"):
                 listener.exitExpr(self)
 
-
-
-
     def expr(self):
 
         localctx = PSParser.ExprContext(self, self._ctx, self.state)
         self.enterRule(localctx, 32, self.RULE_expr)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 294
@@ -2217,31 +2116,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class AdditiveContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.AdditiveContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def mp(self):
-            return self.getTypedRuleContext(PSParser.MpContext,0)
-
+            return self.getTypedRuleContext(PSParser.MpContext, 0)
 
         def additive(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.AdditiveContext)
             else:
-                return self.getTypedRuleContext(PSParser.AdditiveContext,i)
-
+                return self.getTypedRuleContext(PSParser.AdditiveContext, i)
 
         def ADD(self):
             return self.getToken(PSParser.ADD, 0)
 
         def SUB(self):
             return self.getToken(PSParser.SUB, 0)
 
@@ -2252,81 +2148,76 @@
             if hasattr(listener, "enterAdditive"):
                 listener.enterAdditive(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAdditive"):
                 listener.exitAdditive(self)
 
-
-
     def additive(self, _p=0):
         _parentctx = self._ctx
         _parentState = self.state
         localctx = PSParser.AdditiveContext(self, self._ctx, _parentState)
         _prevctx = localctx
         _startState = 34
         self.enterRecursionRule(localctx, 34, self.RULE_additive, _p)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 297
             self.mp(0)
             self._ctx.stop = self._input.LT(-1)
             self.state = 304
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 17, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     if self._parseListeners is not None:
                         self.triggerExitRuleEvent()
                     _prevctx = localctx
                     localctx = PSParser.AdditiveContext(self, _parentctx, _parentState)
                     self.pushNewRecursionContext(localctx, _startState, self.RULE_additive)
                     self.state = 299
                     if not self.precpred(self._ctx, 2):
                         from antlr4.error.Errors import FailedPredicateException
                         raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                     self.state = 300
                     _la = self._input.LA(1)
-                    if not(_la==PSParser.ADD or _la==PSParser.SUB):
+                    if not(_la == PSParser.ADD or _la == PSParser.SUB):
                         self._errHandler.recoverInline(self)
                     else:
                         self._errHandler.reportMatch(self)
                         self.consume()
                     self.state = 301
-                    self.additive(3) 
+                    self.additive(3)
                 self.state = 306
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 17, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.unrollRecursionContexts(_parentctx)
         return localctx
 
-
     class MpContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.MpContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def unary(self):
-            return self.getTypedRuleContext(PSParser.UnaryContext,0)
-
+            return self.getTypedRuleContext(PSParser.UnaryContext, 0)
 
         def mp(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.MpContext)
             else:
-                return self.getTypedRuleContext(PSParser.MpContext,i)
-
+                return self.getTypedRuleContext(PSParser.MpContext, i)
 
         def MUL(self):
             return self.getToken(PSParser.MUL, 0)
 
         def CMD_TIMES(self):
             return self.getToken(PSParser.CMD_TIMES, 0)
 
@@ -2352,81 +2243,76 @@
             if hasattr(listener, "enterMp"):
                 listener.enterMp(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMp"):
                 listener.exitMp(self)
 
-
-
     def mp(self, _p=0):
         _parentctx = self._ctx
         _parentState = self.state
         localctx = PSParser.MpContext(self, self._ctx, _parentState)
         _prevctx = localctx
         _startState = 36
         self.enterRecursionRule(localctx, 36, self.RULE_mp, _p)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 308
             self.unary()
             self._ctx.stop = self._input.LT(-1)
             self.state = 315
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 18, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     if self._parseListeners is not None:
                         self.triggerExitRuleEvent()
                     _prevctx = localctx
                     localctx = PSParser.MpContext(self, _parentctx, _parentState)
                     self.pushNewRecursionContext(localctx, _startState, self.RULE_mp)
                     self.state = 310
                     if not self.precpred(self._ctx, 2):
                         from antlr4.error.Errors import FailedPredicateException
                         raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                     self.state = 311
                     _la = self._input.LA(1)
-                    if not(_la==PSParser.MUL or _la==PSParser.DIV or ((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & ((1 << (PSParser.CMD_TIMES - 147)) | (1 << (PSParser.CMD_CDOT - 147)) | (1 << (PSParser.CMD_DIV - 147)) | (1 << (PSParser.CMD_MOD - 147)) | (1 << (PSParser.COLON - 147)))) != 0)):
+                    if not(_la == PSParser.MUL or _la == PSParser.DIV or ((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & ((1 << (PSParser.CMD_TIMES - 147)) | (1 << (PSParser.CMD_CDOT - 147)) | (1 << (PSParser.CMD_DIV - 147)) | (1 << (PSParser.CMD_MOD - 147)) | (1 << (PSParser.COLON - 147)))) != 0)):
                         self._errHandler.recoverInline(self)
                     else:
                         self._errHandler.reportMatch(self)
                         self.consume()
                     self.state = 312
-                    self.mp(3) 
+                    self.mp(3)
                 self.state = 317
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 18, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.unrollRecursionContexts(_parentctx)
         return localctx
 
-
     class Mp_nofuncContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Mp_nofuncContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def unary_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Unary_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Unary_nofuncContext, 0)
 
         def mp_nofunc(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Mp_nofuncContext)
             else:
-                return self.getTypedRuleContext(PSParser.Mp_nofuncContext,i)
-
+                return self.getTypedRuleContext(PSParser.Mp_nofuncContext, i)
 
         def MUL(self):
             return self.getToken(PSParser.MUL, 0)
 
         def CMD_TIMES(self):
             return self.getToken(PSParser.CMD_TIMES, 0)
 
@@ -2452,391 +2338,358 @@
             if hasattr(listener, "enterMp_nofunc"):
                 listener.enterMp_nofunc(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMp_nofunc"):
                 listener.exitMp_nofunc(self)
 
-
-
     def mp_nofunc(self, _p=0):
         _parentctx = self._ctx
         _parentState = self.state
         localctx = PSParser.Mp_nofuncContext(self, self._ctx, _parentState)
         _prevctx = localctx
         _startState = 38
         self.enterRecursionRule(localctx, 38, self.RULE_mp_nofunc, _p)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 319
             self.unary_nofunc()
             self._ctx.stop = self._input.LT(-1)
             self.state = 326
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 19, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     if self._parseListeners is not None:
                         self.triggerExitRuleEvent()
                     _prevctx = localctx
                     localctx = PSParser.Mp_nofuncContext(self, _parentctx, _parentState)
                     self.pushNewRecursionContext(localctx, _startState, self.RULE_mp_nofunc)
                     self.state = 321
                     if not self.precpred(self._ctx, 2):
                         from antlr4.error.Errors import FailedPredicateException
                         raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                     self.state = 322
                     _la = self._input.LA(1)
-                    if not(_la==PSParser.MUL or _la==PSParser.DIV or ((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & ((1 << (PSParser.CMD_TIMES - 147)) | (1 << (PSParser.CMD_CDOT - 147)) | (1 << (PSParser.CMD_DIV - 147)) | (1 << (PSParser.CMD_MOD - 147)) | (1 << (PSParser.COLON - 147)))) != 0)):
+                    if not(_la == PSParser.MUL or _la == PSParser.DIV or ((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & ((1 << (PSParser.CMD_TIMES - 147)) | (1 << (PSParser.CMD_CDOT - 147)) | (1 << (PSParser.CMD_DIV - 147)) | (1 << (PSParser.CMD_MOD - 147)) | (1 << (PSParser.COLON - 147)))) != 0)):
                         self._errHandler.recoverInline(self)
                     else:
                         self._errHandler.reportMatch(self)
                         self.consume()
                     self.state = 323
-                    self.mp_nofunc(3) 
+                    self.mp_nofunc(3)
                 self.state = 328
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 19, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.unrollRecursionContexts(_parentctx)
         return localctx
 
-
     class UnaryContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.UnaryContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def unary(self):
-            return self.getTypedRuleContext(PSParser.UnaryContext,0)
-
+            return self.getTypedRuleContext(PSParser.UnaryContext, 0)
 
         def ADD(self):
             return self.getToken(PSParser.ADD, 0)
 
         def SUB(self):
             return self.getToken(PSParser.SUB, 0)
 
         def postfix(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.PostfixContext)
             else:
-                return self.getTypedRuleContext(PSParser.PostfixContext,i)
-
+                return self.getTypedRuleContext(PSParser.PostfixContext, i)
 
         def getRuleIndex(self):
             return PSParser.RULE_unary
 
         def enterRule(self, listener):
             if hasattr(listener, "enterUnary"):
                 listener.enterUnary(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitUnary"):
                 listener.exitUnary(self)
 
-
-
-
     def unary(self):
 
         localctx = PSParser.UnaryContext(self, self._ctx, self.state)
         self.enterRule(localctx, 40, self.RULE_unary)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.state = 336
             self._errHandler.sync(self)
             token = self._input.LA(1)
             if token in [PSParser.ADD, PSParser.SUB]:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 329
                 _la = self._input.LA(1)
-                if not(_la==PSParser.ADD or _la==PSParser.SUB):
+                if not(_la == PSParser.ADD or _la == PSParser.SUB):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 330
                 self.unary()
                 pass
             elif token in [PSParser.T__0, PSParser.T__1, PSParser.T__2, PSParser.T__3, PSParser.T__4, PSParser.T__5, PSParser.T__6, PSParser.T__7, PSParser.T__8, PSParser.T__9, PSParser.T__10, PSParser.T__11, PSParser.T__12, PSParser.T__13, PSParser.T__14, PSParser.T__15, PSParser.T__16, PSParser.T__17, PSParser.T__18, PSParser.T__19, PSParser.T__20, PSParser.T__21, PSParser.T__22, PSParser.T__23, PSParser.T__24, PSParser.T__25, PSParser.T__26, PSParser.T__27, PSParser.T__28, PSParser.T__29, PSParser.T__30, PSParser.T__31, PSParser.T__32, PSParser.T__33, PSParser.T__34, PSParser.T__35, PSParser.T__36, PSParser.T__37, PSParser.T__38, PSParser.T__39, PSParser.L_PAREN, PSParser.L_GROUP, PSParser.L_BRACE, PSParser.L_BRACE_VISUAL, PSParser.L_BRACE_CMD, PSParser.L_BRACKET, PSParser.L_BRACK, PSParser.BAR, PSParser.L_VERT, PSParser.VERT, PSParser.NORM, PSParser.L_FLOOR, PSParser.LL_CORNER, PSParser.L_CEIL, PSParser.UL_CORNER, PSParser.L_LEFT, PSParser.ML_LEFT, PSParser.FUNC_LIM, PSParser.FUNC_INT, PSParser.FUNC_SUM, PSParser.FUNC_PROD, PSParser.FUNC_LOG, PSParser.FUNC_LN, PSParser.FUNC_EXP, PSParser.FUNC_SIN, PSParser.FUNC_COS, PSParser.FUNC_TAN, PSParser.FUNC_CSC, PSParser.FUNC_SEC, PSParser.FUNC_COT, PSParser.FUNC_ARCSIN, PSParser.FUNC_ARCCOS, PSParser.FUNC_ARCTAN, PSParser.FUNC_ARCCSC, PSParser.FUNC_ARCSEC, PSParser.FUNC_ARCCOT, PSParser.FUNC_SINH, PSParser.FUNC_COSH, PSParser.FUNC_TANH, PSParser.FUNC_ARSINH, PSParser.FUNC_ARCOSH, PSParser.FUNC_ARTANH, PSParser.FUNC_ARCSINH, PSParser.FUNC_ARCCOSH, PSParser.FUNC_ARCTANH, PSParser.FUNC_SQRT, PSParser.FUNC_GCD, PSParser.FUNC_LCM, PSParser.FUNC_FLOOR, PSParser.FUNC_CEIL, PSParser.FUNC_MAX, PSParser.FUNC_MIN, PSParser.FUNC_DET, PSParser.CMD_FRAC, PSParser.CMD_BINOM, PSParser.CMD_MATHIT, PSParser.CMD_OPERATORNAME, PSParser.CMD_MATRIX_START, PSParser.CMD_DET_START, PSParser.DIFFERENTIAL, PSParser.EXP_E, PSParser.LETTER_NO_E, PSParser.NUMBER, PSParser.E_NOTATION, PSParser.PERCENT_NUMBER, PSParser.GREEK_CMD, PSParser.OTHER_SYMBOL_CMD, PSParser.SYMBOL, PSParser.VARIABLE]:
                 self.enterOuterAlt(localctx, 2)
-                self.state = 332 
+                self.state = 332
                 self._errHandler.sync(self)
                 _alt = 1
-                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
+                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                     if _alt == 1:
                         self.state = 331
                         self.postfix()
 
                     else:
                         raise NoViableAltException(self)
-                    self.state = 334 
+                    self.state = 334
                     self._errHandler.sync(self)
-                    _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
+                    _alt = self._interp.adaptivePredict(self._input, 20, self._ctx)
 
                 pass
             else:
                 raise NoViableAltException(self)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Unary_nofuncContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Unary_nofuncContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def unary_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Unary_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Unary_nofuncContext, 0)
 
         def ADD(self):
             return self.getToken(PSParser.ADD, 0)
 
         def SUB(self):
             return self.getToken(PSParser.SUB, 0)
 
         def postfix(self):
-            return self.getTypedRuleContext(PSParser.PostfixContext,0)
-
+            return self.getTypedRuleContext(PSParser.PostfixContext, 0)
 
         def postfix_nofunc(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Postfix_nofuncContext)
             else:
-                return self.getTypedRuleContext(PSParser.Postfix_nofuncContext,i)
-
+                return self.getTypedRuleContext(PSParser.Postfix_nofuncContext, i)
 
         def getRuleIndex(self):
             return PSParser.RULE_unary_nofunc
 
         def enterRule(self, listener):
             if hasattr(listener, "enterUnary_nofunc"):
                 listener.enterUnary_nofunc(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitUnary_nofunc"):
                 listener.exitUnary_nofunc(self)
 
-
-
-
     def unary_nofunc(self):
 
         localctx = PSParser.Unary_nofuncContext(self, self._ctx, self.state)
         self.enterRule(localctx, 42, self.RULE_unary_nofunc)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.state = 347
             self._errHandler.sync(self)
             token = self._input.LA(1)
             if token in [PSParser.ADD, PSParser.SUB]:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 338
                 _la = self._input.LA(1)
-                if not(_la==PSParser.ADD or _la==PSParser.SUB):
+                if not(_la == PSParser.ADD or _la == PSParser.SUB):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 339
                 self.unary_nofunc()
                 pass
             elif token in [PSParser.T__0, PSParser.T__1, PSParser.T__2, PSParser.T__3, PSParser.T__4, PSParser.T__5, PSParser.T__6, PSParser.T__7, PSParser.T__8, PSParser.T__9, PSParser.T__10, PSParser.T__11, PSParser.T__12, PSParser.T__13, PSParser.T__14, PSParser.T__15, PSParser.T__16, PSParser.T__17, PSParser.T__18, PSParser.T__19, PSParser.T__20, PSParser.T__21, PSParser.T__22, PSParser.T__23, PSParser.T__24, PSParser.T__25, PSParser.T__26, PSParser.T__27, PSParser.T__28, PSParser.T__29, PSParser.T__30, PSParser.T__31, PSParser.T__32, PSParser.T__33, PSParser.T__34, PSParser.T__35, PSParser.T__36, PSParser.T__37, PSParser.T__38, PSParser.T__39, PSParser.L_PAREN, PSParser.L_GROUP, PSParser.L_BRACE, PSParser.L_BRACE_VISUAL, PSParser.L_BRACE_CMD, PSParser.L_BRACKET, PSParser.L_BRACK, PSParser.BAR, PSParser.L_VERT, PSParser.VERT, PSParser.NORM, PSParser.L_FLOOR, PSParser.LL_CORNER, PSParser.L_CEIL, PSParser.UL_CORNER, PSParser.L_LEFT, PSParser.ML_LEFT, PSParser.FUNC_LIM, PSParser.FUNC_INT, PSParser.FUNC_SUM, PSParser.FUNC_PROD, PSParser.FUNC_LOG, PSParser.FUNC_LN, PSParser.FUNC_EXP, PSParser.FUNC_SIN, PSParser.FUNC_COS, PSParser.FUNC_TAN, PSParser.FUNC_CSC, PSParser.FUNC_SEC, PSParser.FUNC_COT, PSParser.FUNC_ARCSIN, PSParser.FUNC_ARCCOS, PSParser.FUNC_ARCTAN, PSParser.FUNC_ARCCSC, PSParser.FUNC_ARCSEC, PSParser.FUNC_ARCCOT, PSParser.FUNC_SINH, PSParser.FUNC_COSH, PSParser.FUNC_TANH, PSParser.FUNC_ARSINH, PSParser.FUNC_ARCOSH, PSParser.FUNC_ARTANH, PSParser.FUNC_ARCSINH, PSParser.FUNC_ARCCOSH, PSParser.FUNC_ARCTANH, PSParser.FUNC_SQRT, PSParser.FUNC_GCD, PSParser.FUNC_LCM, PSParser.FUNC_FLOOR, PSParser.FUNC_CEIL, PSParser.FUNC_MAX, PSParser.FUNC_MIN, PSParser.FUNC_DET, PSParser.CMD_FRAC, PSParser.CMD_BINOM, PSParser.CMD_MATHIT, PSParser.CMD_OPERATORNAME, PSParser.CMD_MATRIX_START, PSParser.CMD_DET_START, PSParser.DIFFERENTIAL, PSParser.EXP_E, PSParser.LETTER_NO_E, PSParser.NUMBER, PSParser.E_NOTATION, PSParser.PERCENT_NUMBER, PSParser.GREEK_CMD, PSParser.OTHER_SYMBOL_CMD, PSParser.SYMBOL, PSParser.VARIABLE]:
                 self.enterOuterAlt(localctx, 2)
                 self.state = 340
                 self.postfix()
                 self.state = 344
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
-                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                    if _alt==1:
+                _alt = self._interp.adaptivePredict(self._input, 22, self._ctx)
+                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                    if _alt == 1:
                         self.state = 341
-                        self.postfix_nofunc() 
+                        self.postfix_nofunc()
                     self.state = 346
                     self._errHandler.sync(self)
-                    _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
+                    _alt = self._interp.adaptivePredict(self._input, 22, self._ctx)
 
                 pass
             else:
                 raise NoViableAltException(self)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class PostfixContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.PostfixContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def exp(self):
-            return self.getTypedRuleContext(PSParser.ExpContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExpContext, 0)
 
         def postfix_op(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Postfix_opContext)
             else:
-                return self.getTypedRuleContext(PSParser.Postfix_opContext,i)
-
+                return self.getTypedRuleContext(PSParser.Postfix_opContext, i)
 
         def getRuleIndex(self):
             return PSParser.RULE_postfix
 
         def enterRule(self, listener):
             if hasattr(listener, "enterPostfix"):
                 listener.enterPostfix(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitPostfix"):
                 listener.exitPostfix(self)
 
-
-
-
     def postfix(self):
 
         localctx = PSParser.PostfixContext(self, self._ctx, self.state)
         self.enterRule(localctx, 44, self.RULE_postfix)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 349
             self.exp(0)
             self.state = 353
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,24,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 24, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     self.state = 350
-                    self.postfix_op() 
+                    self.postfix_op()
                 self.state = 355
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,24,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 24, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Postfix_nofuncContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Postfix_nofuncContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def exp_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Exp_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Exp_nofuncContext, 0)
 
         def postfix_op(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.Postfix_opContext)
             else:
-                return self.getTypedRuleContext(PSParser.Postfix_opContext,i)
-
+                return self.getTypedRuleContext(PSParser.Postfix_opContext, i)
 
         def getRuleIndex(self):
             return PSParser.RULE_postfix_nofunc
 
         def enterRule(self, listener):
             if hasattr(listener, "enterPostfix_nofunc"):
                 listener.enterPostfix_nofunc(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitPostfix_nofunc"):
                 listener.exitPostfix_nofunc(self)
 
-
-
-
     def postfix_nofunc(self):
 
         localctx = PSParser.Postfix_nofuncContext(self, self._ctx, self.state)
         self.enterRule(localctx, 46, self.RULE_postfix_nofunc)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 356
             self.exp_nofunc(0)
             self.state = 360
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 25, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     self.state = 357
-                    self.postfix_op() 
+                    self.postfix_op()
                 self.state = 362
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 25, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Postfix_opContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Postfix_opContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def BANG(self):
             return self.getToken(PSParser.BANG, 0)
 
         def eval_at(self):
-            return self.getTypedRuleContext(PSParser.Eval_atContext,0)
-
+            return self.getTypedRuleContext(PSParser.Eval_atContext, 0)
 
         def transpose(self):
-            return self.getTypedRuleContext(PSParser.TransposeContext,0)
-
+            return self.getTypedRuleContext(PSParser.TransposeContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_postfix_op
 
         def enterRule(self, listener):
             if hasattr(listener, "enterPostfix_op"):
                 listener.enterPostfix_op(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitPostfix_op"):
                 listener.exitPostfix_op(self)
 
-
-
-
     def postfix_op(self):
 
         localctx = PSParser.Postfix_opContext(self, self._ctx, self.state)
         self.enterRule(localctx, 48, self.RULE_postfix_op)
         try:
             self.state = 366
             self._errHandler.sync(self)
@@ -2863,57 +2716,51 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Eval_atContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Eval_atContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def BAR(self):
             return self.getToken(PSParser.BAR, 0)
 
         def eval_at_sup(self):
-            return self.getTypedRuleContext(PSParser.Eval_at_supContext,0)
-
+            return self.getTypedRuleContext(PSParser.Eval_at_supContext, 0)
 
         def eval_at_sub(self):
-            return self.getTypedRuleContext(PSParser.Eval_at_subContext,0)
-
+            return self.getTypedRuleContext(PSParser.Eval_at_subContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_eval_at
 
         def enterRule(self, listener):
             if hasattr(listener, "enterEval_at"):
                 listener.enterEval_at(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitEval_at"):
                 listener.exitEval_at(self)
 
-
-
-
     def eval_at(self):
 
         localctx = PSParser.Eval_atContext(self, self._ctx, self.state)
         self.enterRule(localctx, 50, self.RULE_eval_at)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 368
             self.match(PSParser.BAR)
             self.state = 374
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 27, self._ctx)
             if la_ == 1:
                 self.state = 369
                 self.eval_at_sup()
                 pass
 
             elif la_ == 2:
                 self.state = 370
@@ -2923,24 +2770,22 @@
             elif la_ == 3:
                 self.state = 371
                 self.eval_at_sup()
                 self.state = 372
                 self.eval_at_sub()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Eval_at_subContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Eval_at_subContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def UNDERSCORE(self):
@@ -2949,70 +2794,63 @@
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def equality(self):
-            return self.getTypedRuleContext(PSParser.EqualityContext,0)
-
+            return self.getTypedRuleContext(PSParser.EqualityContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_eval_at_sub
 
         def enterRule(self, listener):
             if hasattr(listener, "enterEval_at_sub"):
                 listener.enterEval_at_sub(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitEval_at_sub"):
                 listener.exitEval_at_sub(self)
 
-
-
-
     def eval_at_sub(self):
 
         localctx = PSParser.Eval_at_subContext(self, self._ctx, self.state)
         self.enterRule(localctx, 52, self.RULE_eval_at_sub)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 376
             self.match(PSParser.UNDERSCORE)
             self.state = 377
             self.match(PSParser.L_BRACE)
             self.state = 380
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 28, self._ctx)
             if la_ == 1:
                 self.state = 378
                 self.expr()
                 pass
 
             elif la_ == 2:
                 self.state = 379
                 self.equality()
                 pass
 
-
             self.state = 382
             self.match(PSParser.R_BRACE)
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Eval_at_supContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Eval_at_supContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def CARET(self):
@@ -3021,135 +2859,121 @@
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def equality(self):
-            return self.getTypedRuleContext(PSParser.EqualityContext,0)
-
+            return self.getTypedRuleContext(PSParser.EqualityContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_eval_at_sup
 
         def enterRule(self, listener):
             if hasattr(listener, "enterEval_at_sup"):
                 listener.enterEval_at_sup(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitEval_at_sup"):
                 listener.exitEval_at_sup(self)
 
-
-
-
     def eval_at_sup(self):
 
         localctx = PSParser.Eval_at_supContext(self, self._ctx, self.state)
         self.enterRule(localctx, 54, self.RULE_eval_at_sup)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 384
             self.match(PSParser.CARET)
             self.state = 385
             self.match(PSParser.L_BRACE)
             self.state = 388
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 29, self._ctx)
             if la_ == 1:
                 self.state = 386
                 self.expr()
                 pass
 
             elif la_ == 2:
                 self.state = 387
                 self.equality()
                 pass
 
-
             self.state = 390
             self.match(PSParser.R_BRACE)
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class ExpContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.ExpContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def comp(self):
-            return self.getTypedRuleContext(PSParser.CompContext,0)
-
+            return self.getTypedRuleContext(PSParser.CompContext, 0)
 
         def exp(self):
-            return self.getTypedRuleContext(PSParser.ExpContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExpContext, 0)
 
         def CARET(self):
             return self.getToken(PSParser.CARET, 0)
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def subexpr(self):
-            return self.getTypedRuleContext(PSParser.SubexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SubexprContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_exp
 
         def enterRule(self, listener):
             if hasattr(listener, "enterExp"):
                 listener.enterExp(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitExp"):
                 listener.exitExp(self)
 
-
-
     def exp(self, _p=0):
         _parentctx = self._ctx
         _parentState = self.state
         localctx = PSParser.ExpContext(self, self._ctx, _parentState)
         _prevctx = localctx
         _startState = 56
         self.enterRecursionRule(localctx, 56, self.RULE_exp, _p)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 393
             self.comp()
             self._ctx.stop = self._input.LT(-1)
             self.state = 409
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 32, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     if self._parseListeners is not None:
                         self.triggerExitRuleEvent()
                     _prevctx = localctx
                     localctx = PSParser.ExpContext(self, _parentctx, _parentState)
                     self.pushNewRecursionContext(localctx, _startState, self.RULE_exp)
                     self.state = 395
                     if not self.precpred(self._ctx, 2):
@@ -3173,98 +2997,89 @@
                         self.match(PSParser.R_BRACE)
                         pass
                     else:
                         raise NoViableAltException(self)
 
                     self.state = 405
                     self._errHandler.sync(self)
-                    la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
+                    la_ = self._interp.adaptivePredict(self._input, 31, self._ctx)
                     if la_ == 1:
                         self.state = 404
                         self.subexpr()
 
-             
                 self.state = 411
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 32, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.unrollRecursionContexts(_parentctx)
         return localctx
 
-
     class Exp_nofuncContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Exp_nofuncContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def comp_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Comp_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Comp_nofuncContext, 0)
 
         def exp_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Exp_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Exp_nofuncContext, 0)
 
         def CARET(self):
             return self.getToken(PSParser.CARET, 0)
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def subexpr(self):
-            return self.getTypedRuleContext(PSParser.SubexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SubexprContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_exp_nofunc
 
         def enterRule(self, listener):
             if hasattr(listener, "enterExp_nofunc"):
                 listener.enterExp_nofunc(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitExp_nofunc"):
                 listener.exitExp_nofunc(self)
 
-
-
     def exp_nofunc(self, _p=0):
         _parentctx = self._ctx
         _parentState = self.state
         localctx = PSParser.Exp_nofuncContext(self, self._ctx, _parentState)
         _prevctx = localctx
         _startState = 58
         self.enterRecursionRule(localctx, 58, self.RULE_exp_nofunc, _p)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 413
             self.comp_nofunc()
             self._ctx.stop = self._input.LT(-1)
             self.state = 429
             self._errHandler.sync(self)
-            _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
-            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
-                if _alt==1:
+            _alt = self._interp.adaptivePredict(self._input, 35, self._ctx)
+            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
+                if _alt == 1:
                     if self._parseListeners is not None:
                         self.triggerExitRuleEvent()
                     _prevctx = localctx
                     localctx = PSParser.Exp_nofuncContext(self, _parentctx, _parentState)
                     self.pushNewRecursionContext(localctx, _startState, self.RULE_exp_nofunc)
                     self.state = 415
                     if not self.precpred(self._ctx, 2):
@@ -3288,105 +3103,89 @@
                         self.match(PSParser.R_BRACE)
                         pass
                     else:
                         raise NoViableAltException(self)
 
                     self.state = 425
                     self._errHandler.sync(self)
-                    la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
+                    la_ = self._interp.adaptivePredict(self._input, 34, self._ctx)
                     if la_ == 1:
                         self.state = 424
                         self.subexpr()
 
-             
                 self.state = 431
                 self._errHandler.sync(self)
-                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
+                _alt = self._interp.adaptivePredict(self._input, 35, self._ctx)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.unrollRecursionContexts(_parentctx)
         return localctx
 
-
     class CompContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.CompContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def group(self):
-            return self.getTypedRuleContext(PSParser.GroupContext,0)
-
+            return self.getTypedRuleContext(PSParser.GroupContext, 0)
 
         def norm_group(self):
-            return self.getTypedRuleContext(PSParser.Norm_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Norm_groupContext, 0)
 
         def abs_group(self):
-            return self.getTypedRuleContext(PSParser.Abs_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Abs_groupContext, 0)
 
         def floor_group(self):
-            return self.getTypedRuleContext(PSParser.Floor_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Floor_groupContext, 0)
 
         def ceil_group(self):
-            return self.getTypedRuleContext(PSParser.Ceil_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Ceil_groupContext, 0)
 
         def func(self):
-            return self.getTypedRuleContext(PSParser.FuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.FuncContext, 0)
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def frac(self):
-            return self.getTypedRuleContext(PSParser.FracContext,0)
-
+            return self.getTypedRuleContext(PSParser.FracContext, 0)
 
         def binom(self):
-            return self.getTypedRuleContext(PSParser.BinomContext,0)
-
+            return self.getTypedRuleContext(PSParser.BinomContext, 0)
 
         def matrix(self):
-            return self.getTypedRuleContext(PSParser.MatrixContext,0)
-
+            return self.getTypedRuleContext(PSParser.MatrixContext, 0)
 
         def det(self):
-            return self.getTypedRuleContext(PSParser.DetContext,0)
-
+            return self.getTypedRuleContext(PSParser.DetContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_comp
 
         def enterRule(self, listener):
             if hasattr(listener, "enterComp"):
                 listener.enterComp(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitComp"):
                 listener.exitComp(self)
 
-
-
-
     def comp(self):
 
         localctx = PSParser.CompContext(self, self._ctx, self.state)
         self.enterRule(localctx, 60, self.RULE_comp)
         try:
             self.state = 443
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 36, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 432
                 self.group()
                 pass
 
             elif la_ == 2:
@@ -3445,92 +3244,77 @@
 
             elif la_ == 11:
                 self.enterOuterAlt(localctx, 11)
                 self.state = 442
                 self.det()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Comp_nofuncContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Comp_nofuncContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def group(self):
-            return self.getTypedRuleContext(PSParser.GroupContext,0)
-
+            return self.getTypedRuleContext(PSParser.GroupContext, 0)
 
         def norm_group(self):
-            return self.getTypedRuleContext(PSParser.Norm_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Norm_groupContext, 0)
 
         def abs_group(self):
-            return self.getTypedRuleContext(PSParser.Abs_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Abs_groupContext, 0)
 
         def floor_group(self):
-            return self.getTypedRuleContext(PSParser.Floor_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Floor_groupContext, 0)
 
         def ceil_group(self):
-            return self.getTypedRuleContext(PSParser.Ceil_groupContext,0)
-
+            return self.getTypedRuleContext(PSParser.Ceil_groupContext, 0)
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def frac(self):
-            return self.getTypedRuleContext(PSParser.FracContext,0)
-
+            return self.getTypedRuleContext(PSParser.FracContext, 0)
 
         def binom(self):
-            return self.getTypedRuleContext(PSParser.BinomContext,0)
-
+            return self.getTypedRuleContext(PSParser.BinomContext, 0)
 
         def matrix(self):
-            return self.getTypedRuleContext(PSParser.MatrixContext,0)
-
+            return self.getTypedRuleContext(PSParser.MatrixContext, 0)
 
         def det(self):
-            return self.getTypedRuleContext(PSParser.DetContext,0)
-
+            return self.getTypedRuleContext(PSParser.DetContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_comp_nofunc
 
         def enterRule(self, listener):
             if hasattr(listener, "enterComp_nofunc"):
                 listener.enterComp_nofunc(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitComp_nofunc"):
                 listener.exitComp_nofunc(self)
 
-
-
-
     def comp_nofunc(self):
 
         localctx = PSParser.Comp_nofuncContext(self, self._ctx, self.state)
         self.enterRule(localctx, 62, self.RULE_comp_nofunc)
         try:
             self.state = 455
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 37, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 445
                 self.group()
                 pass
 
             elif la_ == 2:
@@ -3583,36 +3367,33 @@
 
             elif la_ == 10:
                 self.enterOuterAlt(localctx, 10)
                 self.state = 454
                 self.det()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class GroupContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.GroupContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def L_PAREN(self):
             return self.getToken(PSParser.L_PAREN, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_PAREN(self):
             return self.getToken(PSParser.R_PAREN, 0)
 
         def L_GROUP(self):
             return self.getToken(PSParser.L_GROUP, 0)
 
@@ -3668,25 +3449,22 @@
             if hasattr(listener, "enterGroup"):
                 listener.enterGroup(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitGroup"):
                 listener.exitGroup(self)
 
-
-
-
     def group(self):
 
         localctx = PSParser.GroupContext(self, self._ctx, self.state)
         self.enterRule(localctx, 64, self.RULE_group)
         try:
             self.state = 569
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 38, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 457
                 self.match(PSParser.L_PAREN)
                 self.state = 458
                 self.expr()
                 self.state = 459
@@ -3945,39 +3723,36 @@
                 self.expr()
                 self.state = 566
                 self.match(PSParser.MR_RIGHT)
                 self.state = 567
                 self.match(PSParser.R_BRACK)
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Norm_groupContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Norm_groupContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def NORM(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.NORM)
             else:
                 return self.getToken(PSParser.NORM, i)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def L_LEFT(self):
             return self.getToken(PSParser.L_LEFT, 0)
 
         def R_RIGHT(self):
             return self.getToken(PSParser.R_RIGHT, 0)
 
@@ -3994,17 +3769,14 @@
             if hasattr(listener, "enterNorm_group"):
                 listener.enterNorm_group(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitNorm_group"):
                 listener.exitNorm_group(self)
 
-
-
-
     def norm_group(self):
 
         localctx = PSParser.Norm_groupContext(self, self._ctx, self.state)
         self.enterRule(localctx, 66, self.RULE_norm_group)
         try:
             self.state = 587
             self._errHandler.sync(self)
@@ -4051,30 +3823,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Abs_groupContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Abs_groupContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def BAR(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.BAR)
             else:
                 return self.getToken(PSParser.BAR, i)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def L_VERT(self):
             return self.getToken(PSParser.L_VERT, 0)
 
         def R_VERT(self):
             return self.getToken(PSParser.R_VERT, 0)
 
@@ -4103,25 +3873,22 @@
             if hasattr(listener, "enterAbs_group"):
                 listener.enterAbs_group(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAbs_group"):
                 listener.exitAbs_group(self)
 
-
-
-
     def abs_group(self):
 
         localctx = PSParser.Abs_groupContext(self, self._ctx, self.state)
         self.enterRule(localctx, 68, self.RULE_abs_group)
         try:
             self.state = 637
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 40, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 589
                 self.match(PSParser.BAR)
                 self.state = 590
                 self.expr()
                 self.state = 591
@@ -4228,36 +3995,33 @@
                 self.expr()
                 self.state = 634
                 self.match(PSParser.MR_RIGHT)
                 self.state = 635
                 self.match(PSParser.VERT)
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Floor_groupContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Floor_groupContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def L_FLOOR(self):
             return self.getToken(PSParser.L_FLOOR, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_FLOOR(self):
             return self.getToken(PSParser.R_FLOOR, 0)
 
         def LL_CORNER(self):
             return self.getToken(PSParser.LL_CORNER, 0)
 
@@ -4283,25 +4047,22 @@
             if hasattr(listener, "enterFloor_group"):
                 listener.enterFloor_group(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFloor_group"):
                 listener.exitFloor_group(self)
 
-
-
-
     def floor_group(self):
 
         localctx = PSParser.Floor_groupContext(self, self._ctx, self.state)
         self.enterRule(localctx, 70, self.RULE_floor_group)
         try:
             self.state = 671
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 41, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 639
                 self.match(PSParser.L_FLOOR)
                 self.state = 640
                 self.expr()
                 self.state = 641
@@ -4370,36 +4131,33 @@
                 self.expr()
                 self.state = 668
                 self.match(PSParser.MR_RIGHT)
                 self.state = 669
                 self.match(PSParser.LR_CORNER)
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Ceil_groupContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Ceil_groupContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def L_CEIL(self):
             return self.getToken(PSParser.L_CEIL, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_CEIL(self):
             return self.getToken(PSParser.R_CEIL, 0)
 
         def UL_CORNER(self):
             return self.getToken(PSParser.UL_CORNER, 0)
 
@@ -4425,25 +4183,22 @@
             if hasattr(listener, "enterCeil_group"):
                 listener.enterCeil_group(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitCeil_group"):
                 listener.exitCeil_group(self)
 
-
-
-
     def ceil_group(self):
 
         localctx = PSParser.Ceil_groupContext(self, self._ctx, self.state)
         self.enterRule(localctx, 72, self.RULE_ceil_group)
         try:
             self.state = 705
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 42, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 673
                 self.match(PSParser.L_CEIL)
                 self.state = 674
                 self.expr()
                 self.state = 675
@@ -4512,59 +4267,52 @@
                 self.expr()
                 self.state = 702
                 self.match(PSParser.MR_RIGHT)
                 self.state = 703
                 self.match(PSParser.UR_CORNER)
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class AccentContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.AccentContext, self).__init__(parent, invokingState)
             self.parser = parser
-            self.base = None # ExprContext
+            self.base = None  # ExprContext
 
         def accent_symbol(self):
-            return self.getTypedRuleContext(PSParser.Accent_symbolContext,0)
-
+            return self.getTypedRuleContext(PSParser.Accent_symbolContext, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_accent
 
         def enterRule(self, listener):
             if hasattr(listener, "enterAccent"):
                 listener.enterAccent(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAccent"):
                 listener.exitAccent(self)
 
-
-
-
     def accent(self):
 
         localctx = PSParser.AccentContext(self, self._ctx, self.state)
         self.enterRule(localctx, 74, self.RULE_accent)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 707
@@ -4579,15 +4327,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Atom_expr_no_supexprContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Atom_expr_no_supexprContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def LETTER_NO_E(self):
@@ -4596,40 +4343,35 @@
         def GREEK_CMD(self):
             return self.getToken(PSParser.GREEK_CMD, 0)
 
         def OTHER_SYMBOL_CMD(self):
             return self.getToken(PSParser.OTHER_SYMBOL_CMD, 0)
 
         def accent(self):
-            return self.getTypedRuleContext(PSParser.AccentContext,0)
-
+            return self.getTypedRuleContext(PSParser.AccentContext, 0)
 
         def subexpr(self):
-            return self.getTypedRuleContext(PSParser.SubexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SubexprContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_atom_expr_no_supexpr
 
         def enterRule(self, listener):
             if hasattr(listener, "enterAtom_expr_no_supexpr"):
                 listener.enterAtom_expr_no_supexpr(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAtom_expr_no_supexpr"):
                 listener.exitAtom_expr_no_supexpr(self)
 
-
-
-
     def atom_expr_no_supexpr(self):
 
         localctx = PSParser.Atom_expr_no_supexprContext(self, self._ctx, self.state)
         self.enterRule(localctx, 76, self.RULE_atom_expr_no_supexpr)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 716
             self._errHandler.sync(self)
             token = self._input.LA(1)
             if token in [PSParser.LETTER_NO_E]:
                 self.state = 712
@@ -4649,28 +4391,26 @@
                 pass
             else:
                 raise NoViableAltException(self)
 
             self.state = 719
             self._errHandler.sync(self)
             _la = self._input.LA(1)
-            if _la==PSParser.UNDERSCORE:
+            if _la == PSParser.UNDERSCORE:
                 self.state = 718
                 self.subexpr()
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Atom_exprContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Atom_exprContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def LETTER_NO_E(self):
@@ -4679,39 +4419,33 @@
         def GREEK_CMD(self):
             return self.getToken(PSParser.GREEK_CMD, 0)
 
         def OTHER_SYMBOL_CMD(self):
             return self.getToken(PSParser.OTHER_SYMBOL_CMD, 0)
 
         def accent(self):
-            return self.getTypedRuleContext(PSParser.AccentContext,0)
-
+            return self.getTypedRuleContext(PSParser.AccentContext, 0)
 
         def supexpr(self):
-            return self.getTypedRuleContext(PSParser.SupexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SupexprContext, 0)
 
         def subexpr(self):
-            return self.getTypedRuleContext(PSParser.SubexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SubexprContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_atom_expr
 
         def enterRule(self, listener):
             if hasattr(listener, "enterAtom_expr"):
                 listener.enterAtom_expr(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAtom_expr"):
                 listener.exitAtom_expr(self)
 
-
-
-
     def atom_expr(self):
 
         localctx = PSParser.Atom_exprContext(self, self._ctx, self.state)
         self.enterRule(localctx, 78, self.RULE_atom_expr)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 725
@@ -4734,15 +4468,15 @@
                 self.accent()
                 pass
             else:
                 raise NoViableAltException(self)
 
             self.state = 735
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 46, self._ctx)
             if la_ == 1:
                 self.state = 727
                 self.supexpr()
                 self.state = 728
                 self.subexpr()
 
             elif la_ == 2:
@@ -4755,33 +4489,30 @@
                 self.state = 733
                 self.subexpr()
 
             elif la_ == 4:
                 self.state = 734
                 self.supexpr()
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class AtomContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.AtomContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def atom_expr(self):
-            return self.getTypedRuleContext(PSParser.Atom_exprContext,0)
-
+            return self.getTypedRuleContext(PSParser.Atom_exprContext, 0)
 
         def SYMBOL(self):
             return self.getToken(PSParser.SYMBOL, 0)
 
         def NUMBER(self):
             return self.getToken(PSParser.NUMBER, 0)
 
@@ -4791,16 +4522,15 @@
         def E_NOTATION(self):
             return self.getToken(PSParser.E_NOTATION, 0)
 
         def DIFFERENTIAL(self):
             return self.getToken(PSParser.DIFFERENTIAL, 0)
 
         def mathit(self):
-            return self.getTypedRuleContext(PSParser.MathitContext,0)
-
+            return self.getTypedRuleContext(PSParser.MathitContext, 0)
 
         def VARIABLE(self):
             return self.getToken(PSParser.VARIABLE, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_atom
 
@@ -4808,25 +4538,22 @@
             if hasattr(listener, "enterAtom"):
                 listener.enterAtom(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitAtom"):
                 listener.exitAtom(self)
 
-
-
-
     def atom(self):
 
         localctx = PSParser.AtomContext(self, self._ctx, self.state)
         self.enterRule(localctx, 80, self.RULE_atom)
         try:
             self.state = 745
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 47, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 737
                 self.atom_expr()
                 pass
 
             elif la_ == 2:
@@ -4867,39 +4594,36 @@
 
             elif la_ == 8:
                 self.enterOuterAlt(localctx, 8)
                 self.state = 744
                 self.match(PSParser.VARIABLE)
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class MathitContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.MathitContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def CMD_MATHIT(self):
             return self.getToken(PSParser.CMD_MATHIT, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def mathit_text(self):
-            return self.getTypedRuleContext(PSParser.Mathit_textContext,0)
-
+            return self.getTypedRuleContext(PSParser.Mathit_textContext, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_mathit
 
@@ -4907,17 +4631,14 @@
             if hasattr(listener, "enterMathit"):
                 listener.enterMathit(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMathit"):
                 listener.exitMathit(self)
 
-
-
-
     def mathit(self):
 
         localctx = PSParser.MathitContext(self, self._ctx, self.state)
         self.enterRule(localctx, 82, self.RULE_mathit)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 747
@@ -4932,15 +4653,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Mathit_textContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Mathit_textContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def LETTER_NO_E(self, i=None):
@@ -4968,57 +4688,53 @@
             if hasattr(listener, "enterMathit_text"):
                 listener.enterMathit_text(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitMathit_text"):
                 listener.exitMathit_text(self)
 
-
-
-
     def mathit_text(self):
 
         localctx = PSParser.Mathit_textContext(self, self._ctx, self.state)
         self.enterRule(localctx, 84, self.RULE_mathit_text)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
-            self.state = 753 
+            self.state = 753
             self._errHandler.sync(self)
             _la = self._input.LA(1)
             while True:
                 self.state = 752
                 _la = self._input.LA(1)
                 if not(((((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & ((1 << (PSParser.EXP_E - 174)) | (1 << (PSParser.E_NOTATION_E - 174)) | (1 << (PSParser.LETTER_NO_E - 174)))) != 0)):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
-                self.state = 755 
+                self.state = 755
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
                 if not (((((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & ((1 << (PSParser.EXP_E - 174)) | (1 << (PSParser.E_NOTATION_E - 174)) | (1 << (PSParser.LETTER_NO_E - 174)))) != 0)):
                     break
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class FracContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.FracContext, self).__init__(parent, invokingState)
             self.parser = parser
-            self.upper = None # ExprContext
-            self.lower = None # ExprContext
+            self.upper = None  # ExprContext
+            self.lower = None  # ExprContext
 
         def CMD_FRAC(self):
             return self.getToken(PSParser.CMD_FRAC, 0)
 
         def L_BRACE(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.L_BRACE)
@@ -5031,31 +4747,27 @@
             else:
                 return self.getToken(PSParser.R_BRACE, i)
 
         def expr(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.ExprContext)
             else:
-                return self.getTypedRuleContext(PSParser.ExprContext,i)
-
+                return self.getTypedRuleContext(PSParser.ExprContext, i)
 
         def getRuleIndex(self):
             return PSParser.RULE_frac
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFrac"):
                 listener.enterFrac(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFrac"):
                 listener.exitFrac(self)
 
-
-
-
     def frac(self):
 
         localctx = PSParser.FracContext(self, self._ctx, self.state)
         self.enterRule(localctx, 86, self.RULE_frac)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 757
@@ -5076,22 +4788,21 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class BinomContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.BinomContext, self).__init__(parent, invokingState)
             self.parser = parser
-            self.upper = None # ExprContext
-            self.lower = None # ExprContext
+            self.upper = None  # ExprContext
+            self.lower = None  # ExprContext
 
         def L_BRACE(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.L_BRACE)
             else:
                 return self.getToken(PSParser.L_BRACE, i)
 
@@ -5104,16 +4815,15 @@
             else:
                 return self.getToken(PSParser.R_BRACE, i)
 
         def expr(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.ExprContext)
             else:
-                return self.getTypedRuleContext(PSParser.ExprContext,i)
-
+                return self.getTypedRuleContext(PSParser.ExprContext, i)
 
         def CMD_BINOM(self):
             return self.getToken(PSParser.CMD_BINOM, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_binom
 
@@ -5121,17 +4831,14 @@
             if hasattr(listener, "enterBinom"):
                 listener.enterBinom(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitBinom"):
                 listener.exitBinom(self)
 
-
-
-
     def binom(self):
 
         localctx = PSParser.BinomContext(self, self._ctx, self.state)
         self.enterRule(localctx, 88, self.RULE_binom)
         try:
             self.state = 779
             self._errHandler.sync(self)
@@ -5173,15 +4880,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_normal_functions_single_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_normal_functions_single_argContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def FUNC_LOG(self):
@@ -5272,22 +4978,19 @@
             if hasattr(listener, "enterFunc_normal_functions_single_arg"):
                 listener.enterFunc_normal_functions_single_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_normal_functions_single_arg"):
                 listener.exitFunc_normal_functions_single_arg(self)
 
-
-
-
     def func_normal_functions_single_arg(self):
 
         localctx = PSParser.Func_normal_functions_single_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 90, self.RULE_func_normal_functions_single_arg)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 781
             _la = self._input.LA(1)
             if not(((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (PSParser.FUNC_LOG - 87)) | (1 << (PSParser.FUNC_LN - 87)) | (1 << (PSParser.FUNC_EXP - 87)) | (1 << (PSParser.FUNC_SIN - 87)) | (1 << (PSParser.FUNC_COS - 87)) | (1 << (PSParser.FUNC_TAN - 87)) | (1 << (PSParser.FUNC_CSC - 87)) | (1 << (PSParser.FUNC_SEC - 87)) | (1 << (PSParser.FUNC_COT - 87)) | (1 << (PSParser.FUNC_ARCSIN - 87)) | (1 << (PSParser.FUNC_ARCCOS - 87)) | (1 << (PSParser.FUNC_ARCTAN - 87)) | (1 << (PSParser.FUNC_ARCCSC - 87)) | (1 << (PSParser.FUNC_ARCSEC - 87)) | (1 << (PSParser.FUNC_ARCCOT - 87)) | (1 << (PSParser.FUNC_SINH - 87)) | (1 << (PSParser.FUNC_COSH - 87)) | (1 << (PSParser.FUNC_TANH - 87)) | (1 << (PSParser.FUNC_ARSINH - 87)) | (1 << (PSParser.FUNC_ARCOSH - 87)) | (1 << (PSParser.FUNC_ARTANH - 87)) | (1 << (PSParser.FUNC_ARCSINH - 87)) | (1 << (PSParser.FUNC_ARCCOSH - 87)) | (1 << (PSParser.FUNC_ARCTANH - 87)) | (1 << (PSParser.FUNC_FLOOR - 87)) | (1 << (PSParser.FUNC_CEIL - 87)) | (1 << (PSParser.FUNC_DET - 87)))) != 0)):
                 self._errHandler.recoverInline(self)
             else:
@@ -5297,15 +5000,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_normal_functions_multi_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_normal_functions_multi_argContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def FUNC_GCD(self):
@@ -5327,22 +5029,19 @@
             if hasattr(listener, "enterFunc_normal_functions_multi_arg"):
                 listener.enterFunc_normal_functions_multi_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_normal_functions_multi_arg"):
                 listener.exitFunc_normal_functions_multi_arg(self)
 
-
-
-
     def func_normal_functions_multi_arg(self):
 
         localctx = PSParser.Func_normal_functions_multi_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 92, self.RULE_func_normal_functions_multi_arg)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 783
             _la = self._input.LA(1)
             if not(((((_la - 122)) & ~0x3f) == 0 and ((1 << (_la - 122)) & ((1 << (PSParser.FUNC_GCD - 122)) | (1 << (PSParser.FUNC_LCM - 122)) | (1 << (PSParser.FUNC_MAX - 122)) | (1 << (PSParser.FUNC_MIN - 122)))) != 0)):
                 self._errHandler.recoverInline(self)
             else:
@@ -5352,15 +5051,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_operator_names_single_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_operator_names_single_argContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def FUNC_ARSINH_NAME(self):
@@ -5430,22 +5128,19 @@
             if hasattr(listener, "enterFunc_operator_names_single_arg"):
                 listener.enterFunc_operator_names_single_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_operator_names_single_arg"):
                 listener.exitFunc_operator_names_single_arg(self)
 
-
-
-
     def func_operator_names_single_arg(self):
 
         localctx = PSParser.Func_operator_names_single_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 94, self.RULE_func_operator_names_single_arg)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 785
             _la = self._input.LA(1)
             if not(((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (PSParser.FUNC_ARSINH_NAME - 111)) | (1 << (PSParser.FUNC_ARCSINH_NAME - 111)) | (1 << (PSParser.FUNC_ARCOSH_NAME - 111)) | (1 << (PSParser.FUNC_ARCCOSH_NAME - 111)) | (1 << (PSParser.FUNC_ARTANH_NAME - 111)) | (1 << (PSParser.FUNC_ARCTANH_NAME - 111)) | (1 << (PSParser.FUNC_FLOOR_NAME - 111)) | (1 << (PSParser.FUNC_CEIL_NAME - 111)) | (1 << (PSParser.FUNC_EYE_NAME - 111)) | (1 << (PSParser.FUNC_COLS_NAME - 111)) | (1 << (PSParser.FUNC_ROWS_NAME - 111)) | (1 << (PSParser.FUNC_NORM_NAME - 111)) | (1 << (PSParser.FUNC_RANK_NAME - 111)) | (1 << (PSParser.FUNC_TRACE_NAME - 111)) | (1 << (PSParser.FUNC_RREF_NAME - 111)) | (1 << (PSParser.FUNC_NULLSPACE_NAME - 111)) | (1 << (PSParser.FUNC_DIAGONALIZE_NAME - 111)) | (1 << (PSParser.FUNC_EIGENVALS_NAME - 111)) | (1 << (PSParser.FUNC_EIGENVECTORS_NAME - 111)) | (1 << (PSParser.FUNC_SVD_NAME - 111)))) != 0)):
                 self._errHandler.recoverInline(self)
             else:
@@ -5455,15 +5150,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_operator_names_multi_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_operator_names_multi_argContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def FUNC_GCD_NAME(self):
@@ -5497,22 +5191,19 @@
             if hasattr(listener, "enterFunc_operator_names_multi_arg"):
                 listener.enterFunc_operator_names_multi_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_operator_names_multi_arg"):
                 listener.exitFunc_operator_names_multi_arg(self)
 
-
-
-
     def func_operator_names_multi_arg(self):
 
         localctx = PSParser.Func_operator_names_multi_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 96, self.RULE_func_operator_names_multi_arg)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 787
             _la = self._input.LA(1)
             if not(((((_la - 117)) & ~0x3f) == 0 and ((1 << (_la - 117)) & ((1 << (PSParser.FUNC_GCD_NAME - 117)) | (1 << (PSParser.FUNC_LCM_NAME - 117)) | (1 << (PSParser.FUNC_ZEROS_NAME - 117)) | (1 << (PSParser.FUNC_ONES_NAME - 117)) | (1 << (PSParser.FUNC_DIAG_NAME - 117)) | (1 << (PSParser.FUNC_HSTACK_NAME - 117)) | (1 << (PSParser.FUNC_VSTACK_NAME - 117)) | (1 << (PSParser.FUNC_ORTHOGONALIZE_NAME - 117)))) != 0)):
                 self._errHandler.recoverInline(self)
             else:
@@ -5522,53 +5213,47 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_normal_single_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_normal_single_argContext, self).__init__(parent, invokingState)
             self.parser = parser
-            self.func_operator_name = None # Func_operator_names_single_argContext
+            self.func_operator_name = None  # Func_operator_names_single_argContext
 
         def func_normal_functions_single_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_normal_functions_single_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_normal_functions_single_argContext, 0)
 
         def CMD_OPERATORNAME(self):
             return self.getToken(PSParser.CMD_OPERATORNAME, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def func_operator_names_single_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_operator_names_single_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_operator_names_single_argContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_normal_single_arg
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_normal_single_arg"):
                 listener.enterFunc_normal_single_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_normal_single_arg"):
                 listener.exitFunc_normal_single_arg(self)
 
-
-
-
     def func_normal_single_arg(self):
 
         localctx = PSParser.Func_normal_single_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 98, self.RULE_func_normal_single_arg)
         try:
             self.state = 795
             self._errHandler.sync(self)
@@ -5596,53 +5281,47 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_normal_multi_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_normal_multi_argContext, self).__init__(parent, invokingState)
             self.parser = parser
-            self.func_operator_name = None # Func_operator_names_multi_argContext
+            self.func_operator_name = None  # Func_operator_names_multi_argContext
 
         def func_normal_functions_multi_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_normal_functions_multi_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_normal_functions_multi_argContext, 0)
 
         def CMD_OPERATORNAME(self):
             return self.getToken(PSParser.CMD_OPERATORNAME, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def func_operator_names_multi_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_operator_names_multi_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_operator_names_multi_argContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_normal_multi_arg
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_normal_multi_arg"):
                 listener.enterFunc_normal_multi_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_normal_multi_arg"):
                 listener.exitFunc_normal_multi_arg(self)
 
-
-
-
     def func_normal_multi_arg(self):
 
         localctx = PSParser.Func_normal_multi_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 100, self.RULE_func_normal_multi_arg)
         try:
             self.state = 803
             self._errHandler.sync(self)
@@ -5670,80 +5349,69 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class FuncContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.FuncContext, self).__init__(parent, invokingState)
             self.parser = parser
-            self.root = None # ExprContext
-            self.base = None # ExprContext
+            self.root = None  # ExprContext
+            self.base = None  # ExprContext
 
         def func_normal_single_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_normal_single_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_normal_single_argContext, 0)
 
         def L_PAREN(self):
             return self.getToken(PSParser.L_PAREN, 0)
 
         def func_single_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_single_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_single_argContext, 0)
 
         def R_PAREN(self):
             return self.getToken(PSParser.R_PAREN, 0)
 
         def func_single_arg_noparens(self):
-            return self.getTypedRuleContext(PSParser.Func_single_arg_noparensContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_single_arg_noparensContext, 0)
 
         def subexpr(self):
-            return self.getTypedRuleContext(PSParser.SubexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SubexprContext, 0)
 
         def supexpr(self):
-            return self.getTypedRuleContext(PSParser.SupexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.SupexprContext, 0)
 
         def L_LEFT(self):
             return self.getToken(PSParser.L_LEFT, 0)
 
         def R_RIGHT(self):
             return self.getToken(PSParser.R_RIGHT, 0)
 
         def ML_LEFT(self):
             return self.getToken(PSParser.ML_LEFT, 0)
 
         def MR_RIGHT(self):
             return self.getToken(PSParser.MR_RIGHT, 0)
 
         def func_normal_multi_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_normal_multi_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_normal_multi_argContext, 0)
 
         def func_multi_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_multi_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_multi_argContext, 0)
 
         def func_multi_arg_noparens(self):
-            return self.getTypedRuleContext(PSParser.Func_multi_arg_noparensContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_multi_arg_noparensContext, 0)
 
         def atom_expr_no_supexpr(self):
-            return self.getTypedRuleContext(PSParser.Atom_expr_no_supexprContext,0)
-
+            return self.getTypedRuleContext(PSParser.Atom_expr_no_supexprContext, 0)
 
         def func_common_args(self):
-            return self.getTypedRuleContext(PSParser.Func_common_argsContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_common_argsContext, 0)
 
         def L_BRACKET(self):
             return self.getToken(PSParser.L_BRACKET, 0)
 
         def R_BRACKET(self):
             return self.getToken(PSParser.R_BRACKET, 0)
 
@@ -5762,57 +5430,51 @@
         def FUNC_INT(self):
             return self.getToken(PSParser.FUNC_INT, 0)
 
         def DIFFERENTIAL(self):
             return self.getToken(PSParser.DIFFERENTIAL, 0)
 
         def frac(self):
-            return self.getTypedRuleContext(PSParser.FracContext,0)
-
+            return self.getTypedRuleContext(PSParser.FracContext, 0)
 
         def additive(self):
-            return self.getTypedRuleContext(PSParser.AdditiveContext,0)
-
+            return self.getTypedRuleContext(PSParser.AdditiveContext, 0)
 
         def UNDERSCORE(self):
             return self.getToken(PSParser.UNDERSCORE, 0)
 
         def CARET(self):
             return self.getToken(PSParser.CARET, 0)
 
         def FUNC_SQRT(self):
             return self.getToken(PSParser.FUNC_SQRT, 0)
 
         def expr(self, i=None):
             if i is None:
                 return self.getTypedRuleContexts(PSParser.ExprContext)
             else:
-                return self.getTypedRuleContext(PSParser.ExprContext,i)
-
+                return self.getTypedRuleContext(PSParser.ExprContext, i)
 
         def mp(self):
-            return self.getTypedRuleContext(PSParser.MpContext,0)
-
+            return self.getTypedRuleContext(PSParser.MpContext, 0)
 
         def FUNC_SUM(self):
             return self.getToken(PSParser.FUNC_SUM, 0)
 
         def FUNC_PROD(self):
             return self.getToken(PSParser.FUNC_PROD, 0)
 
         def subeq(self):
-            return self.getTypedRuleContext(PSParser.SubeqContext,0)
-
+            return self.getTypedRuleContext(PSParser.SubeqContext, 0)
 
         def FUNC_LIM(self):
             return self.getToken(PSParser.FUNC_LIM, 0)
 
         def limit_sub(self):
-            return self.getTypedRuleContext(PSParser.Limit_subContext,0)
-
+            return self.getTypedRuleContext(PSParser.Limit_subContext, 0)
 
         def EXP_E(self):
             return self.getToken(PSParser.EXP_E, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func
 
@@ -5820,343 +5482,314 @@
             if hasattr(listener, "enterFunc"):
                 listener.enterFunc(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc"):
                 listener.exitFunc(self)
 
-
-
-
     def func(self):
 
         localctx = PSParser.FuncContext(self, self._ctx, self.state)
         self.enterRule(localctx, 102, self.RULE_func)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.state = 971
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 84, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 805
                 self.func_normal_single_arg()
                 self.state = 818
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 56, self._ctx)
                 if la_ == 1:
                     self.state = 807
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.UNDERSCORE:
+                    if _la == PSParser.UNDERSCORE:
                         self.state = 806
                         self.subexpr()
 
-
                     self.state = 810
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.CARET:
+                    if _la == PSParser.CARET:
                         self.state = 809
                         self.supexpr()
 
-
                     pass
 
                 elif la_ == 2:
                     self.state = 813
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.CARET:
+                    if _la == PSParser.CARET:
                         self.state = 812
                         self.supexpr()
 
-
                     self.state = 816
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.UNDERSCORE:
+                    if _la == PSParser.UNDERSCORE:
                         self.state = 815
                         self.subexpr()
 
-
                     pass
 
-
                 self.state = 841
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 61, self._ctx)
                 if la_ == 1:
                     self.state = 821
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.L_LEFT:
+                    if _la == PSParser.L_LEFT:
                         self.state = 820
                         self.match(PSParser.L_LEFT)
 
-
                     self.state = 823
                     self.match(PSParser.L_PAREN)
                     self.state = 824
                     self.func_single_arg()
                     self.state = 826
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.R_RIGHT:
+                    if _la == PSParser.R_RIGHT:
                         self.state = 825
                         self.match(PSParser.R_RIGHT)
 
-
                     self.state = 828
                     self.match(PSParser.R_PAREN)
                     pass
 
                 elif la_ == 2:
                     self.state = 831
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.ML_LEFT:
+                    if _la == PSParser.ML_LEFT:
                         self.state = 830
                         self.match(PSParser.ML_LEFT)
 
-
                     self.state = 833
                     self.match(PSParser.L_PAREN)
                     self.state = 834
                     self.func_single_arg()
                     self.state = 836
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.MR_RIGHT:
+                    if _la == PSParser.MR_RIGHT:
                         self.state = 835
                         self.match(PSParser.MR_RIGHT)
 
-
                     self.state = 838
                     self.match(PSParser.R_PAREN)
                     pass
 
                 elif la_ == 3:
                     self.state = 840
                     self.func_single_arg_noparens()
                     pass
 
-
                 pass
 
             elif la_ == 2:
                 self.enterOuterAlt(localctx, 2)
                 self.state = 843
                 self.func_normal_multi_arg()
                 self.state = 856
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 66, self._ctx)
                 if la_ == 1:
                     self.state = 845
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.UNDERSCORE:
+                    if _la == PSParser.UNDERSCORE:
                         self.state = 844
                         self.subexpr()
 
-
                     self.state = 848
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.CARET:
+                    if _la == PSParser.CARET:
                         self.state = 847
                         self.supexpr()
 
-
                     pass
 
                 elif la_ == 2:
                     self.state = 851
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.CARET:
+                    if _la == PSParser.CARET:
                         self.state = 850
                         self.supexpr()
 
-
                     self.state = 854
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.UNDERSCORE:
+                    if _la == PSParser.UNDERSCORE:
                         self.state = 853
                         self.subexpr()
 
-
                     pass
 
-
                 self.state = 879
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 71, self._ctx)
                 if la_ == 1:
                     self.state = 859
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.L_LEFT:
+                    if _la == PSParser.L_LEFT:
                         self.state = 858
                         self.match(PSParser.L_LEFT)
 
-
                     self.state = 861
                     self.match(PSParser.L_PAREN)
                     self.state = 862
                     self.func_multi_arg()
                     self.state = 864
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.R_RIGHT:
+                    if _la == PSParser.R_RIGHT:
                         self.state = 863
                         self.match(PSParser.R_RIGHT)
 
-
                     self.state = 866
                     self.match(PSParser.R_PAREN)
                     pass
 
                 elif la_ == 2:
                     self.state = 869
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.ML_LEFT:
+                    if _la == PSParser.ML_LEFT:
                         self.state = 868
                         self.match(PSParser.ML_LEFT)
 
-
                     self.state = 871
                     self.match(PSParser.L_PAREN)
                     self.state = 872
                     self.func_multi_arg()
                     self.state = 874
                     self._errHandler.sync(self)
                     _la = self._input.LA(1)
-                    if _la==PSParser.MR_RIGHT:
+                    if _la == PSParser.MR_RIGHT:
                         self.state = 873
                         self.match(PSParser.MR_RIGHT)
 
-
                     self.state = 876
                     self.match(PSParser.R_PAREN)
                     pass
 
                 elif la_ == 3:
                     self.state = 878
                     self.func_multi_arg_noparens()
                     pass
 
-
                 pass
 
             elif la_ == 3:
                 self.enterOuterAlt(localctx, 3)
                 self.state = 881
                 self.atom_expr_no_supexpr()
                 self.state = 883
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.CARET:
+                if _la == PSParser.CARET:
                     self.state = 882
                     self.supexpr()
 
-
                 self.state = 886
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.L_LEFT:
+                if _la == PSParser.L_LEFT:
                     self.state = 885
                     self.match(PSParser.L_LEFT)
 
-
                 self.state = 888
                 _la = self._input.LA(1)
-                if not(_la==PSParser.L_PAREN or _la==PSParser.L_BRACKET):
+                if not(_la == PSParser.L_PAREN or _la == PSParser.L_BRACKET):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 889
                 self.func_common_args()
                 self.state = 890
                 _la = self._input.LA(1)
-                if not(_la==PSParser.R_PAREN or _la==PSParser.R_BRACKET):
+                if not(_la == PSParser.R_PAREN or _la == PSParser.R_BRACKET):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 892
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 74, self._ctx)
                 if la_ == 1:
                     self.state = 891
                     self.match(PSParser.R_RIGHT)
 
-
                 pass
 
             elif la_ == 4:
                 self.enterOuterAlt(localctx, 4)
                 self.state = 894
                 self.atom_expr_no_supexpr()
                 self.state = 896
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.CARET:
+                if _la == PSParser.CARET:
                     self.state = 895
                     self.supexpr()
 
-
                 self.state = 898
                 self.match(PSParser.L_BRACE)
                 self.state = 900
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.L_LEFT:
+                if _la == PSParser.L_LEFT:
                     self.state = 899
                     self.match(PSParser.L_LEFT)
 
-
                 self.state = 902
                 _la = self._input.LA(1)
-                if not(_la==PSParser.L_PAREN or _la==PSParser.L_BRACKET):
+                if not(_la == PSParser.L_PAREN or _la == PSParser.L_BRACKET):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 903
                 self.func_common_args()
                 self.state = 904
                 _la = self._input.LA(1)
-                if not(_la==PSParser.R_PAREN or _la==PSParser.R_BRACKET):
+                if not(_la == PSParser.R_PAREN or _la == PSParser.R_BRACKET):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 906
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.R_RIGHT:
+                if _la == PSParser.R_RIGHT:
                     self.state = 905
                     self.match(PSParser.R_RIGHT)
 
-
                 self.state = 908
                 self.match(PSParser.R_BRACE)
                 pass
 
             elif la_ == 5:
                 self.enterOuterAlt(localctx, 5)
                 self.state = 910
                 self.match(PSParser.FUNC_INT)
                 self.state = 931
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 78, self._ctx)
                 if la_ == 1:
                     self.state = 911
                     self.subexpr()
                     self.state = 912
                     self.supexpr()
 
                 elif la_ == 2:
@@ -6191,73 +5824,69 @@
                     self.state = 928
                     self.match(PSParser.UNDERSCORE)
                     self.state = 929
                     self.match(PSParser.L_BRACE)
                     self.state = 930
                     self.match(PSParser.R_BRACE)
 
-
                 self.state = 939
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 80, self._ctx)
                 if la_ == 1:
                     self.state = 934
                     self._errHandler.sync(self)
-                    la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
+                    la_ = self._interp.adaptivePredict(self._input, 79, self._ctx)
                     if la_ == 1:
                         self.state = 933
                         self.additive(0)
 
-
                     self.state = 936
                     self.match(PSParser.DIFFERENTIAL)
                     pass
 
                 elif la_ == 2:
                     self.state = 937
                     self.frac()
                     pass
 
                 elif la_ == 3:
                     self.state = 938
                     self.additive(0)
                     pass
 
-
                 pass
 
             elif la_ == 6:
                 self.enterOuterAlt(localctx, 6)
                 self.state = 941
                 self.match(PSParser.FUNC_SQRT)
                 self.state = 946
                 self._errHandler.sync(self)
                 _la = self._input.LA(1)
-                if _la==PSParser.L_BRACKET:
+                if _la == PSParser.L_BRACKET:
                     self.state = 942
                     self.match(PSParser.L_BRACKET)
                     self.state = 943
                     localctx.root = self.expr()
                     self.state = 944
                     self.match(PSParser.R_BRACKET)
 
-
                 self.state = 948
                 self.match(PSParser.L_BRACE)
                 self.state = 949
                 localctx.base = self.expr()
                 self.state = 950
                 self.match(PSParser.R_BRACE)
                 pass
 
             elif la_ == 7:
                 self.enterOuterAlt(localctx, 7)
                 self.state = 952
                 _la = self._input.LA(1)
-                if not(_la==PSParser.FUNC_SUM or _la==PSParser.FUNC_PROD):
+                if not(_la == PSParser.FUNC_SUM or _la == PSParser.FUNC_PROD):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 959
                 self._errHandler.sync(self)
                 token = self._input.LA(1)
@@ -6292,71 +5921,63 @@
 
             elif la_ == 9:
                 self.enterOuterAlt(localctx, 9)
                 self.state = 967
                 self.match(PSParser.EXP_E)
                 self.state = 969
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 83, self._ctx)
                 if la_ == 1:
                     self.state = 968
                     self.supexpr()
 
-
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class ArgsContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.ArgsContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def COMMA(self):
             return self.getToken(PSParser.COMMA, 0)
 
         def args(self):
-            return self.getTypedRuleContext(PSParser.ArgsContext,0)
-
+            return self.getTypedRuleContext(PSParser.ArgsContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_args
 
         def enterRule(self, listener):
             if hasattr(listener, "enterArgs"):
                 listener.enterArgs(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitArgs"):
                 listener.exitArgs(self)
 
-
-
-
     def args(self):
 
         localctx = PSParser.ArgsContext(self, self._ctx, self.state)
         self.enterRule(localctx, 104, self.RULE_args)
         try:
             self.state = 978
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 85, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 973
                 self.expr()
                 self.state = 974
                 self.match(PSParser.COMMA)
                 self.state = 975
@@ -6365,67 +5986,59 @@
 
             elif la_ == 2:
                 self.enterOuterAlt(localctx, 2)
                 self.state = 977
                 self.expr()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_common_argsContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_common_argsContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def COMMA(self):
             return self.getToken(PSParser.COMMA, 0)
 
         def args(self):
-            return self.getTypedRuleContext(PSParser.ArgsContext,0)
-
+            return self.getTypedRuleContext(PSParser.ArgsContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_common_args
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_common_args"):
                 listener.enterFunc_common_args(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_common_args"):
                 listener.exitFunc_common_args(self)
 
-
-
-
     def func_common_args(self):
 
         localctx = PSParser.Func_common_argsContext(self, self._ctx, self.state)
         self.enterRule(localctx, 106, self.RULE_func_common_args)
         try:
             self.state = 988
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 86, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 980
                 self.atom()
                 pass
 
             elif la_ == 2:
@@ -6442,24 +6055,22 @@
                 self.expr()
                 self.state = 985
                 self.match(PSParser.COMMA)
                 self.state = 986
                 self.args()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Limit_subContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Limit_subContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def UNDERSCORE(self):
@@ -6471,16 +6082,15 @@
             else:
                 return self.getToken(PSParser.L_BRACE, i)
 
         def LIM_APPROACH_SYM(self):
             return self.getToken(PSParser.LIM_APPROACH_SYM, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_BRACE(self, i=None):
             if i is None:
                 return self.getTokens(PSParser.R_BRACE)
             else:
                 return self.getToken(PSParser.R_BRACE, i)
 
@@ -6509,22 +6119,19 @@
             if hasattr(listener, "enterLimit_sub"):
                 listener.enterLimit_sub(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitLimit_sub"):
                 listener.exitLimit_sub(self)
 
-
-
-
     def limit_sub(self):
 
         localctx = PSParser.Limit_subContext(self, self._ctx, self.state)
         self.enterRule(localctx, 108, self.RULE_limit_sub)
-        self._la = 0 # Token type
+        self._la = 0  # Token type
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 990
             self.match(PSParser.UNDERSCORE)
             self.state = 991
             self.match(PSParser.L_BRACE)
             self.state = 992
@@ -6537,65 +6144,59 @@
             self.state = 993
             self.match(PSParser.LIM_APPROACH_SYM)
             self.state = 994
             self.expr()
             self.state = 999
             self._errHandler.sync(self)
             _la = self._input.LA(1)
-            if _la==PSParser.CARET:
+            if _la == PSParser.CARET:
                 self.state = 995
                 self.match(PSParser.CARET)
                 self.state = 996
                 self.match(PSParser.L_BRACE)
                 self.state = 997
                 _la = self._input.LA(1)
-                if not(_la==PSParser.ADD or _la==PSParser.SUB):
+                if not(_la == PSParser.ADD or _la == PSParser.SUB):
                     self._errHandler.recoverInline(self)
                 else:
                     self._errHandler.reportMatch(self)
                     self.consume()
                 self.state = 998
                 self.match(PSParser.R_BRACE)
 
-
             self.state = 1001
             self.match(PSParser.R_BRACE)
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_single_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_single_argContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_single_arg
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_single_arg"):
                 listener.enterFunc_single_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_single_arg"):
                 listener.exitFunc_single_arg(self)
 
-
-
-
     def func_single_arg(self):
 
         localctx = PSParser.Func_single_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 110, self.RULE_func_single_arg)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1003
@@ -6604,39 +6205,34 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_single_arg_noparensContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_single_arg_noparensContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def mp_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Mp_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Mp_nofuncContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_single_arg_noparens
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_single_arg_noparens"):
                 listener.enterFunc_single_arg_noparens(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_single_arg_noparens"):
                 listener.exitFunc_single_arg_noparens(self)
 
-
-
-
     def func_single_arg_noparens(self):
 
         localctx = PSParser.Func_single_arg_noparensContext(self, self._ctx, self.state)
         self.enterRule(localctx, 112, self.RULE_func_single_arg_noparens)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1005
@@ -6645,54 +6241,48 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_multi_argContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_multi_argContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def COMMA(self):
             return self.getToken(PSParser.COMMA, 0)
 
         def func_multi_arg(self):
-            return self.getTypedRuleContext(PSParser.Func_multi_argContext,0)
-
+            return self.getTypedRuleContext(PSParser.Func_multi_argContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_multi_arg
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_multi_arg"):
                 listener.enterFunc_multi_arg(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_multi_arg"):
                 listener.exitFunc_multi_arg(self)
 
-
-
-
     def func_multi_arg(self):
 
         localctx = PSParser.Func_multi_argContext(self, self._ctx, self.state)
         self.enterRule(localctx, 114, self.RULE_func_multi_arg)
         try:
             self.state = 1012
             self._errHandler.sync(self)
-            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
+            la_ = self._interp.adaptivePredict(self._input, 88, self._ctx)
             if la_ == 1:
                 self.enterOuterAlt(localctx, 1)
                 self.state = 1007
                 self.expr()
                 pass
 
             elif la_ == 2:
@@ -6701,48 +6291,42 @@
                 self.expr()
                 self.state = 1009
                 self.match(PSParser.COMMA)
                 self.state = 1010
                 self.func_multi_arg()
                 pass
 
-
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class Func_multi_arg_noparensContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.Func_multi_arg_noparensContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def mp_nofunc(self):
-            return self.getTypedRuleContext(PSParser.Mp_nofuncContext,0)
-
+            return self.getTypedRuleContext(PSParser.Mp_nofuncContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_func_multi_arg_noparens
 
         def enterRule(self, listener):
             if hasattr(listener, "enterFunc_multi_arg_noparens"):
                 listener.enterFunc_multi_arg_noparens(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitFunc_multi_arg_noparens"):
                 listener.exitFunc_multi_arg_noparens(self)
 
-
-
-
     def func_multi_arg_noparens(self):
 
         localctx = PSParser.Func_multi_arg_noparensContext(self, self._ctx, self.state)
         self.enterRule(localctx, 116, self.RULE_func_multi_arg_noparens)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1014
@@ -6751,56 +6335,49 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class SubexprContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.SubexprContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def UNDERSCORE(self):
             return self.getToken(PSParser.UNDERSCORE, 0)
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def args(self):
-            return self.getTypedRuleContext(PSParser.ArgsContext,0)
-
+            return self.getTypedRuleContext(PSParser.ArgsContext, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_subexpr
 
         def enterRule(self, listener):
             if hasattr(listener, "enterSubexpr"):
                 listener.enterSubexpr(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitSubexpr"):
                 listener.exitSubexpr(self)
 
-
-
-
     def subexpr(self):
 
         localctx = PSParser.SubexprContext(self, self._ctx, self.state)
         self.enterRule(localctx, 118, self.RULE_subexpr)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1016
@@ -6813,60 +6390,56 @@
                 self.atom()
                 pass
             elif token in [PSParser.L_BRACE]:
                 self.state = 1018
                 self.match(PSParser.L_BRACE)
                 self.state = 1021
                 self._errHandler.sync(self)
-                la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
+                la_ = self._interp.adaptivePredict(self._input, 89, self._ctx)
                 if la_ == 1:
                     self.state = 1019
                     self.expr()
                     pass
 
                 elif la_ == 2:
                     self.state = 1020
                     self.args()
                     pass
 
-
                 self.state = 1023
                 self.match(PSParser.R_BRACE)
                 pass
             else:
                 raise NoViableAltException(self)
 
         except RecognitionException as re:
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class SupexprContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.SupexprContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def CARET(self):
             return self.getToken(PSParser.CARET, 0)
 
         def atom(self):
-            return self.getTypedRuleContext(PSParser.AtomContext,0)
-
+            return self.getTypedRuleContext(PSParser.AtomContext, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def expr(self):
-            return self.getTypedRuleContext(PSParser.ExprContext,0)
-
+            return self.getTypedRuleContext(PSParser.ExprContext, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_supexpr
 
@@ -6874,17 +6447,14 @@
             if hasattr(listener, "enterSupexpr"):
                 listener.enterSupexpr(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitSupexpr"):
                 listener.exitSupexpr(self)
 
-
-
-
     def supexpr(self):
 
         localctx = PSParser.SupexprContext(self, self._ctx, self.state)
         self.enterRule(localctx, 120, self.RULE_supexpr)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1027
@@ -6911,30 +6481,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class SubeqContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.SubeqContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def UNDERSCORE(self):
             return self.getToken(PSParser.UNDERSCORE, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def equality(self):
-            return self.getTypedRuleContext(PSParser.EqualityContext,0)
-
+            return self.getTypedRuleContext(PSParser.EqualityContext, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_subeq
 
@@ -6942,17 +6510,14 @@
             if hasattr(listener, "enterSubeq"):
                 listener.enterSubeq(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitSubeq"):
                 listener.exitSubeq(self)
 
-
-
-
     def subeq(self):
 
         localctx = PSParser.SubeqContext(self, self._ctx, self.state)
         self.enterRule(localctx, 122, self.RULE_subeq)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1035
@@ -6967,30 +6532,28 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
     class SupeqContext(ParserRuleContext):
 
         def __init__(self, parser, parent=None, invokingState=-1):
             super(PSParser.SupeqContext, self).__init__(parent, invokingState)
             self.parser = parser
 
         def UNDERSCORE(self):
             return self.getToken(PSParser.UNDERSCORE, 0)
 
         def L_BRACE(self):
             return self.getToken(PSParser.L_BRACE, 0)
 
         def equality(self):
-            return self.getTypedRuleContext(PSParser.EqualityContext,0)
-
+            return self.getTypedRuleContext(PSParser.EqualityContext, 0)
 
         def R_BRACE(self):
             return self.getToken(PSParser.R_BRACE, 0)
 
         def getRuleIndex(self):
             return PSParser.RULE_supeq
 
@@ -6998,17 +6561,14 @@
             if hasattr(listener, "enterSupeq"):
                 listener.enterSupeq(self)
 
         def exitRule(self, listener):
             if hasattr(listener, "exitSupeq"):
                 listener.exitSupeq(self)
 
-
-
-
     def supeq(self):
 
         localctx = PSParser.SupeqContext(self, self._ctx, self.state)
         self.enterRule(localctx, 124, self.RULE_supeq)
         try:
             self.enterOuterAlt(localctx, 1)
             self.state = 1040
@@ -7023,16 +6583,14 @@
             localctx.exception = re
             self._errHandler.reportError(self, re)
             self._errHandler.recover(self, re)
         finally:
             self.exitRule()
         return localctx
 
-
-
     def sempred(self, localctx, ruleIndex, predIndex):
         if self._predicates == None:
             self._predicates = dict()
         self._predicates[12] = self.relation_sempred
         self._predicates[17] = self.additive_sempred
         self._predicates[18] = self.mp_sempred
         self._predicates[19] = self.mp_nofunc_sempred
@@ -7041,39 +6599,29 @@
         pred = self._predicates.get(ruleIndex, None)
         if pred is None:
             raise Exception("No predicate with index:" + str(ruleIndex))
         else:
             return pred(localctx, predIndex)
 
     def relation_sempred(self, localctx, predIndex):
-            if predIndex == 0:
-                return self.precpred(self._ctx, 2)
-         
+        if predIndex == 0:
+            return self.precpred(self._ctx, 2)
 
     def additive_sempred(self, localctx, predIndex):
-            if predIndex == 1:
-                return self.precpred(self._ctx, 2)
-         
+        if predIndex == 1:
+            return self.precpred(self._ctx, 2)
 
     def mp_sempred(self, localctx, predIndex):
-            if predIndex == 2:
-                return self.precpred(self._ctx, 2)
-         
+        if predIndex == 2:
+            return self.precpred(self._ctx, 2)
 
     def mp_nofunc_sempred(self, localctx, predIndex):
-            if predIndex == 3:
-                return self.precpred(self._ctx, 2)
-         
+        if predIndex == 3:
+            return self.precpred(self._ctx, 2)
 
     def exp_sempred(self, localctx, predIndex):
-            if predIndex == 4:
-                return self.precpred(self._ctx, 2)
-         
+        if predIndex == 4:
+            return self.precpred(self._ctx, 2)
 
     def exp_nofunc_sempred(self, localctx, predIndex):
-            if predIndex == 5:
-                return self.precpred(self._ctx, 2)
-         
-
-
-
-
+        if predIndex == 5:
+            return self.precpred(self._ctx, 2)
```

## Comparing `latex2sympy2-1.9.0.dist-info/LICENSE.txt` & `latex2sympy2-1.9.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `latex2sympy2-1.9.0.dist-info/METADATA` & `latex2sympy2-1.9.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: latex2sympy2
-Version: 1.9.0
+Version: 1.9.1
 Summary: Convert latex to sympy with ANTLR and support Matrix, Linear Algebra and CAS functions.
 Home-page: https://github.com/OrangeX4/latex2sympy
 Author: OrangeX4
 Author-email: 318483724@qq.com
 License: MIT
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
```

## Comparing `latex2sympy2-1.9.0.dist-info/RECORD` & `latex2sympy2-1.9.1.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 asciimath_printer.py,sha256=PbzNyCvqCYz_yKRpAEwXb3FI11vF7Be8BBmvibbURGw,1698
-latex2sympy2.py,sha256=y1_VB9uNDkvqw-lvKglvgvlGufl5rExaP2N20CWDMLY,40465
-gen/PSLexer.py,sha256=ymD3p0SsPJsB81O7tbPpJN-NaerlF-U72dsOq7doGjY,122308
-gen/PSListener.py,sha256=Bn2ZUk0hPAxA2l5_Vs0huLMt1kiC2aervZvM1HNgSJw,14716
-gen/PSParser.py,sha256=TzU98imI0XMSZmKCjJwWL0cXmkof_24TONpQbIX4ej0,272010
+latex2sympy2.py,sha256=nUrIyWPYbEZLqqeOQhAbhKoLVpLVziFuY83YwkoZKj8,40500
+gen/PSLexer.py,sha256=WZV7NRFExRTYaaR_VjsLwVLslfDl9ziAfGtqDETOedo,122711
+gen/PSListener.py,sha256=Gza8ZJV9qxbIv-9NQSlnWwHXeUA0zsp9xIl8yfDjpqI,14716
+gen/PSParser.py,sha256=7qTJmGZKjhjHPKMGvEafasOM6dzjtEKckNZglOtkb7Y,271559
 gen/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/abs_test.py,sha256=SbLVUSCE0CHFJWr8C6iXCkrqnaAraM6uTzb7O3rH1kk,773
 tests/all_bad_test.py,sha256=ODJqfh9ntDN6_ug6G1_FPqBSPyrfudIYmqmcC-f4K2w,1767
 tests/all_good_test.py,sha256=QkQCNGjolz-CklNGyXgURESCmrfivqgTPpy9MrVhGd0,13138
 tests/atom_expr_test.py,sha256=zLK-ZWc0Z34q4WVvDS5SzunnRjhewrSoCaWW8zzXVK0,2245
 tests/binomial_test.py,sha256=-gdwXaHYM7rk2CDMY3Vb7T536pSJPo6j6aqBCmkTUvY,902
@@ -24,12 +24,12 @@
 tests/max_test.py,sha256=n6eMJc6LZEECNrDfeer6s_u243J7ISxZMrs4Ai0yYj8,3756
 tests/min_test.py,sha256=foeyHxJ7rmuSk4tQTmaoBsJZU4QECJtP6N8LWVF1rDk,3756
 tests/mod_test.py,sha256=aUPJAjFkyk6VOadMej1U3HumHczEJZ_83No7BeXK0_U,3261
 tests/overline_test.py,sha256=OCwWJAN2vWYOPAMTLgewbqmiPv2GiHERiJBuDDh0fKs,221
 tests/pi_test.py,sha256=zLzJBX2Ug9L8zdZcBNyz0HWVDiiE_BykJPngC0u68kQ,404
 tests/trig_test.py,sha256=Rd5yezNS4z1uD1-BlvjFSOGYLnJOgWZWrNQyG46ADxY,526
 tests/variable_test.py,sha256=HxpKCgM5sc8PfaiAcnS4WAKxIk8LvWRIB2njVULVb7o,4274
-latex2sympy2-1.9.0.dist-info/LICENSE.txt,sha256=AHvDClj6QKmW53IEcSDeTq8x9REOT5w7X5P8374urKE,1075
-latex2sympy2-1.9.0.dist-info/METADATA,sha256=AtOwQpmdhPzmAX9oqhNaEJhrEzD_zUGrr8oHWRf4XiA,6557
-latex2sympy2-1.9.0.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-latex2sympy2-1.9.0.dist-info/top_level.txt,sha256=cAgO96mdUTteyz2gMpMWrtuwu0mGGiIrlpoMii-X7qA,41
-latex2sympy2-1.9.0.dist-info/RECORD,,
+latex2sympy2-1.9.1.dist-info/LICENSE.txt,sha256=AHvDClj6QKmW53IEcSDeTq8x9REOT5w7X5P8374urKE,1075
+latex2sympy2-1.9.1.dist-info/METADATA,sha256=wky1lTB7f5WZnPLvtac1LgBmqljWN6pz-xn_3LpKbXs,6557
+latex2sympy2-1.9.1.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+latex2sympy2-1.9.1.dist-info/top_level.txt,sha256=cAgO96mdUTteyz2gMpMWrtuwu0mGGiIrlpoMii-X7qA,41
+latex2sympy2-1.9.1.dist-info/RECORD,,
```

